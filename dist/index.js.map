{"version":3,"file":"index.js","sources":["../webpack://typescript-action/./lib/conda.js","../webpack://typescript-action/./lib/docker.js","../webpack://typescript-action/./lib/exec.js","../webpack://typescript-action/./lib/main.js","../webpack://typescript-action/./lib/util.js","../webpack://typescript-action/./node_modules/@actions/core/lib/command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/core.js","../webpack://typescript-action/./node_modules/@actions/core/lib/file-command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/utils.js","../webpack://typescript-action/./node_modules/@actions/exec/lib/exec.js","../webpack://typescript-action/./node_modules/@actions/exec/lib/toolrunner.js","../webpack://typescript-action/./node_modules/@actions/http-client/index.js","../webpack://typescript-action/./node_modules/@actions/http-client/proxy.js","../webpack://typescript-action/./node_modules/@actions/io/lib/io-util.js","../webpack://typescript-action/./node_modules/@actions/io/lib/io.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/lib/manifest.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/lib/retry-helper.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/lib/tool-cache.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/node_modules/uuid/lib/bytesToUuid.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/node_modules/uuid/lib/rng.js","../webpack://typescript-action/./node_modules/@actions/tool-cache/node_modules/uuid/v4.js","../webpack://typescript-action/./node_modules/asn1/lib/ber/errors.js","../webpack://typescript-action/./node_modules/asn1/lib/ber/index.js","../webpack://typescript-action/./node_modules/asn1/lib/ber/reader.js","../webpack://typescript-action/./node_modules/asn1/lib/ber/types.js","../webpack://typescript-action/./node_modules/asn1/lib/ber/writer.js","../webpack://typescript-action/./node_modules/asn1/lib/index.js","../webpack://typescript-action/./node_modules/bcrypt-pbkdf/index.js","../webpack://typescript-action/./node_modules/bl/BufferList.js","../webpack://typescript-action/./node_modules/bl/bl.js","../webpack://typescript-action/./node_modules/chownr/chownr.js","../webpack://typescript-action/./node_modules/debug/src/browser.js","../webpack://typescript-action/./node_modules/debug/src/common.js","../webpack://typescript-action/./node_modules/debug/src/index.js","../webpack://typescript-action/./node_modules/debug/src/node.js","../webpack://typescript-action/./node_modules/docker-modem/lib/http.js","../webpack://typescript-action/./node_modules/docker-modem/lib/http_duplex.js","../webpack://typescript-action/./node_modules/docker-modem/lib/modem.js","../webpack://typescript-action/./node_modules/docker-modem/lib/ssh.js","../webpack://typescript-action/./node_modules/docker-modem/lib/utils.js","../webpack://typescript-action/./node_modules/dockerode/lib/config.js","../webpack://typescript-action/./node_modules/dockerode/lib/container.js","../webpack://typescript-action/./node_modules/dockerode/lib/docker.js","../webpack://typescript-action/./node_modules/dockerode/lib/exec.js","../webpack://typescript-action/./node_modules/dockerode/lib/image.js","../webpack://typescript-action/./node_modules/dockerode/lib/network.js","../webpack://typescript-action/./node_modules/dockerode/lib/node.js","../webpack://typescript-action/./node_modules/dockerode/lib/plugin.js","../webpack://typescript-action/./node_modules/dockerode/lib/secret.js","../webpack://typescript-action/./node_modules/dockerode/lib/service.js","../webpack://typescript-action/./node_modules/dockerode/lib/task.js","../webpack://typescript-action/./node_modules/dockerode/lib/util.js","../webpack://typescript-action/./node_modules/dockerode/lib/volume.js","../webpack://typescript-action/./node_modules/end-of-stream/index.js","../webpack://typescript-action/./node_modules/fs-constants/index.js","../webpack://typescript-action/./node_modules/has-flag/index.js","../webpack://typescript-action/./node_modules/inherits/inherits.js","../webpack://typescript-action/./node_modules/inherits/inherits_browser.js","../webpack://typescript-action/./node_modules/mkdirp-classic/index.js","../webpack://typescript-action/./node_modules/ms/index.js","../webpack://typescript-action/./node_modules/once/once.js","../webpack://typescript-action/./node_modules/pump/index.js","../webpack://typescript-action/./node_modules/readable-stream/errors.js","../webpack://typescript-action/./node_modules/readable-stream/lib/_stream_duplex.js","../webpack://typescript-action/./node_modules/readable-stream/lib/_stream_passthrough.js","../webpack://typescript-action/./node_modules/readable-stream/lib/_stream_readable.js","../webpack://typescript-action/./node_modules/readable-stream/lib/_stream_transform.js","../webpack://typescript-action/./node_modules/readable-stream/lib/_stream_writable.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/async_iterator.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/buffer_list.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/destroy.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/from.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/pipeline.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/state.js","../webpack://typescript-action/./node_modules/readable-stream/lib/internal/streams/stream.js","../webpack://typescript-action/./node_modules/readable-stream/readable.js","../webpack://typescript-action/./node_modules/safer-buffer/safer.js","../webpack://typescript-action/./node_modules/semver/semver.js","../webpack://typescript-action/./node_modules/split-ca/index.js","../webpack://typescript-action/./node_modules/ssh2-streams/index.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/buffer-helpers.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/constants.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/jsbn.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/keyParser.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/node-fs-compat.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/sftp.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/ssh.js","../webpack://typescript-action/./node_modules/ssh2-streams/lib/utils.js","../webpack://typescript-action/./node_modules/ssh2/lib/Channel.js","../webpack://typescript-action/./node_modules/ssh2/lib/SFTPWrapper.js","../webpack://typescript-action/./node_modules/ssh2/lib/agent.js","../webpack://typescript-action/./node_modules/ssh2/lib/buffer-helpers.js","../webpack://typescript-action/./node_modules/ssh2/lib/client.js","../webpack://typescript-action/./node_modules/ssh2/lib/http-agents.js","../webpack://typescript-action/./node_modules/ssh2/lib/keepalivemgr.js","../webpack://typescript-action/./node_modules/ssh2/lib/server.js","../webpack://typescript-action/./node_modules/streamsearch/lib/sbmh.js","../webpack://typescript-action/./node_modules/string_decoder/lib/string_decoder.js","../webpack://typescript-action/./node_modules/string_decoder/node_modules/safe-buffer/index.js","../webpack://typescript-action/./node_modules/supports-color/index.js","../webpack://typescript-action/./node_modules/tar-fs/index.js","../webpack://typescript-action/./node_modules/tar-stream/extract.js","../webpack://typescript-action/./node_modules/tar-stream/headers.js","../webpack://typescript-action/./node_modules/tar-stream/index.js","../webpack://typescript-action/./node_modules/tar-stream/pack.js","../webpack://typescript-action/./node_modules/tunnel/index.js","../webpack://typescript-action/./node_modules/tunnel/lib/tunnel.js","../webpack://typescript-action/./node_modules/tweetnacl/nacl-fast.js","../webpack://typescript-action/./node_modules/util-deprecate/node.js","../webpack://typescript-action/./node_modules/uuid/dist/index.js","../webpack://typescript-action/./node_modules/uuid/dist/md5.js","../webpack://typescript-action/./node_modules/uuid/dist/nil.js","../webpack://typescript-action/./node_modules/uuid/dist/parse.js","../webpack://typescript-action/./node_modules/uuid/dist/regex.js","../webpack://typescript-action/./node_modules/uuid/dist/rng.js","../webpack://typescript-action/./node_modules/uuid/dist/sha1.js","../webpack://typescript-action/./node_modules/uuid/dist/stringify.js","../webpack://typescript-action/./node_modules/uuid/dist/v1.js","../webpack://typescript-action/./node_modules/uuid/dist/v3.js","../webpack://typescript-action/./node_modules/uuid/dist/v35.js","../webpack://typescript-action/./node_modules/uuid/dist/v4.js","../webpack://typescript-action/./node_modules/uuid/dist/v5.js","../webpack://typescript-action/./node_modules/uuid/dist/validate.js","../webpack://typescript-action/./node_modules/uuid/dist/version.js","../webpack://typescript-action/./node_modules/wrappy/wrappy.js","../webpack://typescript-action/external \"assert\"","../webpack://typescript-action/external \"buffer\"","../webpack://typescript-action/external \"child_process\"","../webpack://typescript-action/external \"constants\"","../webpack://typescript-action/external \"crypto\"","../webpack://typescript-action/external \"dns\"","../webpack://typescript-action/external \"events\"","../webpack://typescript-action/external \"fs\"","../webpack://typescript-action/external \"http\"","../webpack://typescript-action/external \"https\"","../webpack://typescript-action/external \"net\"","../webpack://typescript-action/external \"os\"","../webpack://typescript-action/external \"path\"","../webpack://typescript-action/external \"querystring\"","../webpack://typescript-action/external \"stream\"","../webpack://typescript-action/external \"string_decoder\"","../webpack://typescript-action/external \"timers\"","../webpack://typescript-action/external \"tls\"","../webpack://typescript-action/external \"tty\"","../webpack://typescript-action/external \"url\"","../webpack://typescript-action/external \"util\"","../webpack://typescript-action/external \"zlib\"","../webpack://typescript-action/webpack/bootstrap","../webpack://typescript-action/webpack/runtime/compat","../webpack://typescript-action/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ensureConda = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst exec = __importStar(require(\"./exec\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst tc = __importStar(require(\"@actions/tool-cache\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nfunction ensureConda() {\n    return __awaiter(this, void 0, void 0, function* () {\n        let condaPrefix = core.getInput('conda-prefix', { required: false });\n        if (condaPrefix) {\n            condaPrefix = condaPrefix.replace('~', os_1.default.homedir);\n            const condaInstallerUrl = core.getInput('conda-installer-url');\n            let cmdFromPrefix = path_1.default.join(condaPrefix, 'condabin', 'conda');\n            try {\n                yield io.which('conda', true);\n                return 'conda';\n            }\n            catch (error) {\n                core.warning(`conda not found, start looking for: ${cmdFromPrefix}`);\n            }\n            try {\n                yield exec.exec(cmdFromPrefix, ['--version']);\n            }\n            catch (error) {\n                core.warning(`start installing with installer: ${condaInstallerUrl}`);\n                const installerPath = yield tc.downloadTool(condaInstallerUrl);\n                exec.exec('bash', [installerPath, '-b', '-u', '-s', '-p', condaPrefix]);\n            }\n            cmdFromPrefix = yield io.which(cmdFromPrefix, true);\n            return cmdFromPrefix;\n        }\n        else {\n            return 'conda';\n        }\n    });\n}\nexports.ensureConda = ensureConda;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildOneFlow = exports.runExec = exports.buildManylinuxAndTag = exports.tagFromversion = exports.ensureDocker = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst exec = __importStar(require(\"@actions/exec\"));\nconst tc = __importStar(require(\"@actions/tool-cache\"));\nconst dockerode_1 = __importDefault(require(\"dockerode\"));\nconst util_1 = require(\"./util\");\nconst io = __importStar(require(\"@actions/io\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst assert_1 = require(\"assert\");\nfunction load_img(tag, url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield exec.exec('docker', ['ps'], { silent: true });\n        const inspect = yield exec.exec('docker', ['inspect', tag], {\n            ignoreReturnCode: true,\n            silent: true\n        });\n        if (inspect !== 0) {\n            const imgPath = yield tc.downloadTool(url);\n            yield exec.exec('docker', ['load', '-i', imgPath]);\n        }\n    });\n}\nfunction ensureDocker() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exec.exec('docker', ['ps'], { silent: true });\n            yield load_img('quay.io/pypa/manylinux1_x86_64', 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/img/quay.iopypamanylinux1_x86_64.tar.gz');\n            yield load_img('quay.io/pypa/manylinux2010_x86_64', 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/img/quay.iopypamanylinux2010_x86_64.tar.gz');\n            yield load_img('quay.io/pypa/manylinux2014_x86_64:latest', 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/img/quay.iopypamanylinux2014_x86_64.tar.gz');\n            yield load_img('quay.io/pypa/manylinux_2_24_x86_64', 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/img/quay.iopypamanylinux_2_24_x86_64.tar.gz');\n        }\n        catch (error) {\n            core.warning(error.message);\n        }\n    });\n}\nexports.ensureDocker = ensureDocker;\nfunction tagFromversion(version) {\n    const repo = 'quay.io/pypa/';\n    switch (version) {\n        case '1':\n        case '2010':\n        case '2014':\n            return repo.concat('manylinux').concat(version).concat('_x86_64');\n        case '2_24':\n            return repo.concat('manylinux_').concat(version).concat('_x86_64');\n        default:\n            throw new Error(`${version} not supported`);\n    }\n}\nexports.tagFromversion = tagFromversion;\nfunction buildManylinuxAndTag(version) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const fromTag = tagFromversion(version);\n        const splits = fromTag.split('/');\n        const toTag = 'oneflowinc/'.concat(splits[splits.length - 1]);\n        const docker = new dockerode_1.default({ socketPath: '/var/run/docker.sock' });\n        let buildArgs = {\n            from: fromTag,\n            HTTP_PROXY: process.env.HTTP_PROXY,\n            http_proxy: process.env.http_proxy,\n            HTTPS_PROXY: process.env.HTTPS_PROXY,\n            https_proxy: process.env.https_proxy\n        };\n        if (util_1.isSelfHosted()) {\n            const selfHostedBuildArgs = {\n                SCCACHE_RELEASE_URL: 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/sccache-v0.2.15-x86_64-unknown-linux-musl.tar.gz',\n                LLVM_SRC_URL: 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/llvm-project-12.0.1.src.tar.xz',\n                BAZEL_URL: 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/bazel-3.4.1-linux-x86_64'\n            };\n            buildArgs = Object.assign(Object.assign({}, buildArgs), selfHostedBuildArgs);\n        }\n        const stream = yield docker.buildImage({\n            context: version === '2_24' ? 'manylinux/debian' : 'manylinux/centos',\n            src: ['Dockerfile']\n        }, {\n            t: toTag,\n            networkmode: 'host',\n            buildargs: buildArgs\n        });\n        new dockerode_1.default().modem.demuxStream(stream, process.stdout, process.stderr);\n        yield new Promise((resolve, reject) => {\n            new dockerode_1.default().modem.followProgress(stream, (err, res) => {\n                const lastFrame = res[res.length - 1];\n                lastFrame.error ? reject(res) : resolve(res);\n                err ? reject(err) : resolve(res);\n            });\n        });\n        return toTag;\n    });\n}\nexports.buildManylinuxAndTag = buildManylinuxAndTag;\nfunction runExec(container, cmd, cwd) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const exec_ = yield container.exec({\n            Cmd: cmd,\n            AttachStdout: true,\n            AttachStderr: true,\n            WorkingDir: cwd\n        });\n        const stream = yield exec_.start({ Tty: false, Detach: false });\n        yield container.modem.demuxStream(stream, process.stdout, process.stderr);\n        yield new Promise((resolve, reject) => {\n            const cb = () => {\n                exec_.inspect((error, info) => {\n                    if (info) {\n                        if (info.Running === false) {\n                            if (info.ExitCode === 0) {\n                                resolve(info);\n                            }\n                            else {\n                                reject(info);\n                            }\n                        }\n                    }\n                    if (error) {\n                        reject(error);\n                    }\n                });\n            };\n            cb();\n            stream.on('end', cb);\n            stream.on('error', cb);\n            stream.on('close', cb);\n            setTimeout(cb, 1000);\n        });\n    });\n}\nexports.runExec = runExec;\nconst PythonExeMap = new Map([\n    ['3.6', '/opt/python/cp36-cp36m/bin/python3'],\n    ['3.7', '/opt/python/cp37-cp37m/bin/python3'],\n    ['3.8', '/opt/python/cp38-cp38/bin/python3'],\n    ['3.9', '/opt/python/cp39-cp39/bin/python3'],\n    ['3.10', '/opt/python/cp310-cp310/bin/python3']\n]);\nfunction getPythonExe(pythonVersion) {\n    const exe = PythonExeMap.get(pythonVersion);\n    assert_1.ok(exe);\n    return exe;\n}\nfunction buildOneFlow(tag) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const oneflowSrc = util_1.getPathInput('oneflow-src', { required: true });\n        const wheelhouseDir = util_1.getPathInput('wheelhouse-dir', { required: true });\n        const docker = new dockerode_1.default({ socketPath: '/var/run/docker.sock' });\n        const CUDA_TOOLKIT_ROOT_DIR = '/usr/local/cuda';\n        const CUDNN_ROOT_DIR = '/usr/local/cudnn';\n        const containerName = 'ci-test-build-oneflow';\n        const containerInfos = yield docker.listContainers();\n        for (const containerInfo of containerInfos) {\n            if (containerInfo.Names.includes(containerName) ||\n                containerInfo.Names.includes('/'.concat(containerName))) {\n                core.info(`removing docker container: ${containerInfo.Names}`);\n                yield docker.getContainer(containerInfo.Id).kill();\n                yield docker.getContainer(containerInfo.Id).wait({\n                    condition: 'removed'\n                });\n            }\n        }\n        let httpProxyEnvs = [];\n        const manylinuxCacheDir = util_1.getPathInput('manylinux-cache-dir');\n        yield io.mkdirP(manylinuxCacheDir);\n        if (core.getBooleanInput('use-system-http-proxy', { required: false })) {\n            httpProxyEnvs = [\n                `HTTP_PROXY=${process.env.HTTP_PROXY}`,\n                `http_proxy=${process.env.http_proxy}`,\n                `HTTPS_PROXY=${process.env.HTTPS_PROXY}`,\n                `https_proxy=${process.env.https_proxy}`\n            ];\n        }\n        let llvmDir = '';\n        const shouldMountLLVM = false;\n        const mounts = [\n            {\n                Source: CUDA_TOOLKIT_ROOT_DIR,\n                Target: '/usr/local/cuda',\n                ReadOnly: true,\n                Type: 'bind'\n            },\n            {\n                Source: CUDNN_ROOT_DIR,\n                Target: '/usr/local/cudnn',\n                ReadOnly: true,\n                Type: 'bind'\n            }\n        ];\n        if (shouldMountLLVM) {\n            llvmDir = yield util_1.ensureTool('llvm', '9.0.1', '~/tools/llvm-9.01');\n            mounts.push({\n                Source: llvmDir,\n                Target: '/usr/local/llvm',\n                ReadOnly: true,\n                Type: 'bind'\n            });\n        }\n        const buildDir = path_1.default.join(manylinuxCacheDir, 'build');\n        const container = yield docker.createContainer({\n            Cmd: ['sleep', '3600'],\n            Image: tag,\n            name: containerName,\n            HostConfig: {\n                AutoRemove: true,\n                NetworkMode: 'host',\n                Binds: [\n                    `${manylinuxCacheDir}:${manylinuxCacheDir}`,\n                    `${path_1.default.join(manylinuxCacheDir, 'ccache')}:/root/.ccache`,\n                    `${path_1.default.join(manylinuxCacheDir, 'local')}:/root/.local`,\n                    `${oneflowSrc}:${oneflowSrc}`,\n                    `${wheelhouseDir}:${wheelhouseDir}`\n                ],\n                Mounts: mounts\n            },\n            Env: [\n                `ONEFLOW_CI_BUILD_DIR=${buildDir}`,\n                `ONEFLOW_CI_SRC_DIR=${oneflowSrc}`,\n                `ONEFLOW_CI_LLVM_DIR=${llvmDir}`\n            ].concat(httpProxyEnvs)\n        });\n        yield container.start();\n        const pythonVersions = core.getMultilineInput('python-versions', {\n            required: true\n        });\n        for (const pythonVersion of pythonVersions) {\n            const pythonExe = getPythonExe(pythonVersion);\n            yield buildOnePythonVersion(container, oneflowSrc, buildDir, pythonExe);\n        }\n        const distDir = path_1.default.join(oneflowSrc, 'python', 'dist');\n        const whlFiles = yield fs_1.default.promises.readdir(distDir);\n        assert_1.ok(whlFiles.length);\n        yield Promise.all(whlFiles.map((whl) => __awaiter(this, void 0, void 0, function* () {\n            return runExec(container, ['auditwheel', 'repair', whl, '--wheel-dir', wheelhouseDir], distDir);\n        })));\n    });\n}\nexports.buildOneFlow = buildOneFlow;\nfunction buildOnePythonVersion(container, oneflowSrc, buildDir, pythonExe) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const cmakeInitCache = util_1.getPathInput('cmake-init-cache');\n        const argsExclude = ['-e', '!dist', '-e', '!dist/**'];\n        yield runExec(container, ['git', 'clean', '-nXd'].concat(argsExclude), path_1.default.join(oneflowSrc, 'python'));\n        yield runExec(container, ['git', 'clean', '-fXd'].concat(argsExclude), path_1.default.join(oneflowSrc, 'python'));\n        yield runExec(container, ['mkdir', '-p', buildDir]);\n        yield runExec(container, [\n            'cmake',\n            '-S',\n            oneflowSrc,\n            '-C',\n            cmakeInitCache,\n            '-B',\n            buildDir,\n            `-DPython3_EXECUTABLE=${pythonExe}`\n        ]);\n        yield runExec(container, [\n            'cmake',\n            '--build',\n            buildDir,\n            '--parallel',\n            (yield exec.getExecOutput('nproc')).stdout.trim()\n        ]);\n        yield runExec(container, [pythonExe, 'setup.py', 'bdist_wheel'], path_1.default.join(oneflowSrc, 'python'));\n    });\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getExecOutput = exports.exec = void 0;\nconst exec_ = __importStar(require(\"@actions/exec\"));\nconst core = __importStar(require(\"@actions/core\"));\n/**\n * Exec a command.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.\n * @param     args               optional arguments for tool. Escaping is handled by the lib.\n * @param     options            optional exec options.  See ExecOptions\n * @returns   Promise<number>    exit code\n */\nfunction exec(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const isDryRun = core.getBooleanInput('dry-run');\n        if (isDryRun) {\n            return 0;\n        }\n        else {\n            return yield exec_.exec(commandLine, args, options);\n        }\n    });\n}\nexports.exec = exec;\n/**\n * Exec a command and get the output.\n * Output will be streamed to the live console.\n * Returns promise with the exit code and collected stdout and stderr\n *\n * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.\n * @param     args                  optional arguments for tool. Escaping is handled by the lib.\n * @param     options               optional exec options.  See ExecOptions\n * @returns   Promise<ExecOutput>   exit code, stdout, and stderr\n */\nfunction getExecOutput(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const isDryRun = core.getBooleanInput('dry-run');\n        if (isDryRun) {\n            return {\n                exitCode: 0,\n                stdout: 'dry-run',\n                stderr: 'dry-run'\n            };\n        }\n        else {\n            return yield exec_.getExecOutput(commandLine, args, options);\n        }\n    });\n}\nexports.getExecOutput = getExecOutput;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core = __importStar(require(\"@actions/core\"));\nconst exec = __importStar(require(\"./exec\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst tc = __importStar(require(\"@actions/tool-cache\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst conda_1 = require(\"./conda\");\nconst docker_1 = require(\"./docker\");\nconst util_1 = require(\"./util\");\nfunction condaRun(condaEnvName, commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let condaCmd = 'conda';\n        try {\n            condaCmd = yield io.which(condaCmd, true);\n        }\n        catch (error) {\n            condaCmd = yield conda_1.ensureConda();\n        }\n        return yield exec.exec(condaCmd, ['run', '-n', condaEnvName, commandLine].concat(args || []), options);\n    });\n}\nfunction buildWithConda() {\n    return __awaiter(this, void 0, void 0, function* () {\n        let envFile = core\n            .getInput('conda-env-file', { required: true })\n            .replace('~', os_1.default.homedir);\n        const oneflowSrc = core\n            .getInput('oneflow-src', { required: true })\n            .replace('~', os_1.default.homedir);\n        const cmakeInitCache = core\n            .getInput('cmake-init-cache', {\n            required: true\n        })\n            .replace('~', os_1.default.homedir);\n        const isDryRun = core.getBooleanInput('dry-run');\n        const isEnvFileExist = yield fs_1.default.promises\n            .access(envFile, fs_1.default.constants.F_OK)\n            // eslint-disable-next-line github/no-then\n            .then(() => true)\n            // eslint-disable-next-line github/no-then\n            .catch(() => false);\n        if (isEnvFileExist === false && isDryRun === false) {\n            envFile = yield tc.downloadTool(envFile);\n        }\n        if (isDryRun === false) {\n            yield conda_1.ensureConda();\n        }\n        if (isDryRun === false) {\n            yield exec.exec(yield conda_1.ensureConda(), [\n                'env',\n                'update',\n                '-f',\n                envFile,\n                '--prune'\n            ]);\n            const buildDir = 'build';\n            yield io.mkdirP(buildDir);\n            const condaEnvName = 'oneflow-dev-clang10-v2';\n            yield condaRun(condaEnvName, 'cmake', [\n                '-S',\n                oneflowSrc,\n                '-C',\n                cmakeInitCache,\n                '-B',\n                buildDir\n            ]);\n            if (util_1.isSelfHosted()) {\n                yield condaRun(condaEnvName, 'cmake', [\n                    '--build',\n                    buildDir,\n                    '--parallel',\n                    (yield exec.getExecOutput('nproc')).stdout.trim()\n                ]);\n                yield condaRun(condaEnvName, 'python3', ['setup.py', 'bdist_wheel'], {\n                    cwd: path_1.default.join(oneflowSrc, 'python')\n                });\n            }\n        }\n    });\n}\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const buildEnv = core.getInput('oneflow-build-env');\n            if (['conda', 'manylinux'].includes(buildEnv) === false) {\n                core.setFailed('oneflow-build-env must be conda or manylinux');\n            }\n            if (buildEnv === 'conda') {\n                yield buildWithConda();\n            }\n            if (buildEnv === 'manylinux') {\n                const manylinuxVersion = '2014';\n                const tag = yield docker_1.buildManylinuxAndTag(manylinuxVersion);\n                if (util_1.isSelfHosted()) {\n                    yield docker_1.buildOneFlow(tag);\n                }\n            }\n        }\n        catch (error) {\n            core.setFailed(error.message);\n        }\n    });\n}\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ensureTool = exports.extractTarX = exports.getLLVM1201URL = exports.getLLVM1001URL = exports.getLLVM901URL = exports.getToolURL = exports.isSelfHosted = exports.getPathInput = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst tc = __importStar(require(\"@actions/tool-cache\"));\nconst exec = __importStar(require(\"@actions/exec\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst assert_1 = require(\"assert\");\nconst uuid_1 = require(\"uuid\");\nfunction getPathInput(name, options) {\n    let val = core.getInput(name, options).replace('~', os_1.default.homedir);\n    if (val.startsWith('/') === false) {\n        val = path_1.default.join(process.cwd(), val);\n    }\n    return val;\n}\nexports.getPathInput = getPathInput;\nfunction isSelfHosted() {\n    return core.getBooleanInput('self-hosted');\n}\nexports.isSelfHosted = isSelfHosted;\nfunction getToolURL(tool, version) {\n    if (tool === 'llvm') {\n        if (version === '9.0.1') {\n            return getLLVM901URL();\n        }\n        if (version === '10.0.1') {\n            return getLLVM1001URL();\n        }\n        if (version === '12.0.1') {\n            return getLLVM1201URL();\n        }\n    }\n    throw new Error(`no url found tool ${tool} version ${version}`);\n}\nexports.getToolURL = getToolURL;\nfunction getLLVM901URL() {\n    if (isSelfHosted()) {\n        return 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/clang%2Bllvm-9.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz';\n    }\n    else {\n        return 'https://github.com/llvm/llvm-project/releases/download/llvmorg-9.0.1/clang+llvm-9.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz';\n    }\n}\nexports.getLLVM901URL = getLLVM901URL;\nfunction getLLVM1001URL() {\n    if (isSelfHosted()) {\n        return 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/clang%2Bllvm-10.0.1-x86_64-linux-sles12.4.tar.xz';\n    }\n    else {\n        return 'https://github.com/llvm/llvm-project/releases/download/llvmorg-10.0.1/clang+llvm-10.0.1-x86_64-linux-sles12.4.tar.xz';\n    }\n}\nexports.getLLVM1001URL = getLLVM1001URL;\nfunction getLLVM1201URL() {\n    if (isSelfHosted()) {\n        return 'https://oneflow-static.oss-cn-beijing.aliyuncs.com/downloads/clang%2Bllvm-12.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz';\n    }\n    else {\n        return 'https://github.com/llvm/llvm-project/releases/download/llvmorg-12.0.1/clang+llvm-12.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz';\n    }\n}\nexports.getLLVM1201URL = getLLVM1201URL;\nfunction _getTempDirectory() {\n    const tempDirectory = process.env['RUNNER_TEMP'] || '';\n    assert_1.ok(tempDirectory, 'Expected RUNNER_TEMP to be defined');\n    return tempDirectory;\n}\nfunction _createExtractFolder(dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!dest) {\n            // create a temp dir\n            dest = path_1.default.join(_getTempDirectory(), uuid_1.v4());\n        }\n        yield io.mkdirP(dest);\n        return dest;\n    });\n}\nfunction extractTarX(file, dest, flags = 'xz') {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!file) {\n            throw new Error(\"parameter 'file' is required\");\n        }\n        // Create dest\n        dest = yield _createExtractFolder(dest);\n        // Determine whether GNU tar\n        core.debug('Checking tar --version');\n        let versionOutput = '';\n        yield exec.exec('tar --version', [], {\n            ignoreReturnCode: true,\n            silent: true,\n            listeners: {\n                stdout: (data) => (versionOutput += data.toString()),\n                stderr: (data) => (versionOutput += data.toString())\n            }\n        });\n        core.debug(versionOutput.trim());\n        const isGnuTar = versionOutput.toUpperCase().includes('GNU TAR');\n        // Initialize args\n        let args = [file];\n        if (flags instanceof Array) {\n            args = flags.concat(args);\n        }\n        else {\n            args = [flags];\n        }\n        if (core.isDebug() && !flags.includes('v')) {\n            args.push('-v');\n        }\n        if (isGnuTar) {\n            // Suppress warnings when using GNU tar to extract archives created by BSD tar\n            args.push('--warning=no-unknown-keyword');\n            args.push('--overwrite');\n        }\n        args.push('-C', dest);\n        yield exec.exec(`tar`, args);\n        return dest;\n    });\n}\nexports.extractTarX = extractTarX;\nfunction ensureTool(tool, version, dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let cachedPath = tc.find(tool, version);\n        if (cachedPath === '') {\n            const url = getToolURL(tool, version);\n            // TODO: wrap oss node sdk around tc.downloadTool\n            const downloaded = yield tc.downloadTool(url);\n            const destExpanded = dest.replace('~', os_1.default.homedir);\n            if (url.endsWith('tar.gz')) {\n                const extracted = yield tc.extractTar(downloaded, destExpanded);\n                cachedPath = yield tc.cacheDir(extracted, tool, version);\n            }\n            else if (url.endsWith('tar.xz')) {\n                const extracted = yield extractTarX(downloaded, destExpanded, ['xf']);\n                cachedPath = yield tc.cacheDir(extracted, tool, version);\n            }\n            else {\n                throw new Error(`not supported: ${url}`);\n            }\n        }\n        // TODO: parse from URL\n        if (tool === 'llvm') {\n            if (version === '10.0.1') {\n                cachedPath = path_1.default.join(cachedPath, 'clang+llvm-10.0.1-x86_64-linux-sles12.4');\n            }\n            if (version === '9.0.1') {\n                cachedPath = path_1.default.join(cachedPath, 'clang+llvm-9.0.1-x86_64-linux-gnu-ubuntu-16.04');\n            }\n        }\n        return cachedPath;\n    });\n}\nexports.ensureTool = ensureTool;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getExecOutput = exports.exec = void 0;\nconst string_decoder_1 = require(\"string_decoder\");\nconst tr = __importStar(require(\"./toolrunner\"));\n/**\n * Exec a command.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.\n * @param     args               optional arguments for tool. Escaping is handled by the lib.\n * @param     options            optional exec options.  See ExecOptions\n * @returns   Promise<number>    exit code\n */\nfunction exec(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const commandArgs = tr.argStringToArray(commandLine);\n        if (commandArgs.length === 0) {\n            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);\n        }\n        // Path to tool to execute should be first arg\n        const toolPath = commandArgs[0];\n        args = commandArgs.slice(1).concat(args || []);\n        const runner = new tr.ToolRunner(toolPath, args, options);\n        return runner.exec();\n    });\n}\nexports.exec = exec;\n/**\n * Exec a command and get the output.\n * Output will be streamed to the live console.\n * Returns promise with the exit code and collected stdout and stderr\n *\n * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.\n * @param     args                  optional arguments for tool. Escaping is handled by the lib.\n * @param     options               optional exec options.  See ExecOptions\n * @returns   Promise<ExecOutput>   exit code, stdout, and stderr\n */\nfunction getExecOutput(commandLine, args, options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        let stdout = '';\n        let stderr = '';\n        //Using string decoder covers the case where a mult-byte character is split\n        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');\n        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');\n        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;\n        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;\n        const stdErrListener = (data) => {\n            stderr += stderrDecoder.write(data);\n            if (originalStdErrListener) {\n                originalStdErrListener(data);\n            }\n        };\n        const stdOutListener = (data) => {\n            stdout += stdoutDecoder.write(data);\n            if (originalStdoutListener) {\n                originalStdoutListener(data);\n            }\n        };\n        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });\n        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));\n        //flush any remaining characters\n        stdout += stdoutDecoder.end();\n        stderr += stderrDecoder.end();\n        return {\n            exitCode,\n            stdout,\n            stderr\n        };\n    });\n}\nexports.getExecOutput = getExecOutput;\n//# sourceMappingURL=exec.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argStringToArray = exports.ToolRunner = void 0;\nconst os = __importStar(require(\"os\"));\nconst events = __importStar(require(\"events\"));\nconst child = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst ioUtil = __importStar(require(\"@actions/io/lib/io-util\"));\nconst timers_1 = require(\"timers\");\n/* eslint-disable @typescript-eslint/unbound-method */\nconst IS_WINDOWS = process.platform === 'win32';\n/*\n * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.\n */\nclass ToolRunner extends events.EventEmitter {\n    constructor(toolPath, args, options) {\n        super();\n        if (!toolPath) {\n            throw new Error(\"Parameter 'toolPath' cannot be null or empty.\");\n        }\n        this.toolPath = toolPath;\n        this.args = args || [];\n        this.options = options || {};\n    }\n    _debug(message) {\n        if (this.options.listeners && this.options.listeners.debug) {\n            this.options.listeners.debug(message);\n        }\n    }\n    _getCommandString(options, noPrefix) {\n        const toolPath = this._getSpawnFileName();\n        const args = this._getSpawnArgs(options);\n        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool\n        if (IS_WINDOWS) {\n            // Windows + cmd file\n            if (this._isCmdFile()) {\n                cmd += toolPath;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows + verbatim\n            else if (options.windowsVerbatimArguments) {\n                cmd += `\"${toolPath}\"`;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows (regular)\n            else {\n                cmd += this._windowsQuoteCmdArg(toolPath);\n                for (const a of args) {\n                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;\n                }\n            }\n        }\n        else {\n            // OSX/Linux - this can likely be improved with some form of quoting.\n            // creating processes on Unix is fundamentally different than Windows.\n            // on Unix, execvp() takes an arg array.\n            cmd += toolPath;\n            for (const a of args) {\n                cmd += ` ${a}`;\n            }\n        }\n        return cmd;\n    }\n    _processLineBuffer(data, strBuffer, onLine) {\n        try {\n            let s = strBuffer + data.toString();\n            let n = s.indexOf(os.EOL);\n            while (n > -1) {\n                const line = s.substring(0, n);\n                onLine(line);\n                // the rest of the string ...\n                s = s.substring(n + os.EOL.length);\n                n = s.indexOf(os.EOL);\n            }\n            return s;\n        }\n        catch (err) {\n            // streaming lines to console is best effort.  Don't fail a build.\n            this._debug(`error processing line. Failed with error ${err}`);\n            return '';\n        }\n    }\n    _getSpawnFileName() {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                return process.env['COMSPEC'] || 'cmd.exe';\n            }\n        }\n        return this.toolPath;\n    }\n    _getSpawnArgs(options) {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                let argline = `/D /S /C \"${this._windowsQuoteCmdArg(this.toolPath)}`;\n                for (const a of this.args) {\n                    argline += ' ';\n                    argline += options.windowsVerbatimArguments\n                        ? a\n                        : this._windowsQuoteCmdArg(a);\n                }\n                argline += '\"';\n                return [argline];\n            }\n        }\n        return this.args;\n    }\n    _endsWith(str, end) {\n        return str.endsWith(end);\n    }\n    _isCmdFile() {\n        const upperToolPath = this.toolPath.toUpperCase();\n        return (this._endsWith(upperToolPath, '.CMD') ||\n            this._endsWith(upperToolPath, '.BAT'));\n    }\n    _windowsQuoteCmdArg(arg) {\n        // for .exe, apply the normal quoting rules that libuv applies\n        if (!this._isCmdFile()) {\n            return this._uvQuoteCmdArg(arg);\n        }\n        // otherwise apply quoting rules specific to the cmd.exe command line parser.\n        // the libuv rules are generic and are not designed specifically for cmd.exe\n        // command line parser.\n        //\n        // for a detailed description of the cmd.exe command line parser, refer to\n        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912\n        // need quotes for empty arg\n        if (!arg) {\n            return '\"\"';\n        }\n        // determine whether the arg needs to be quoted\n        const cmdSpecialChars = [\n            ' ',\n            '\\t',\n            '&',\n            '(',\n            ')',\n            '[',\n            ']',\n            '{',\n            '}',\n            '^',\n            '=',\n            ';',\n            '!',\n            \"'\",\n            '+',\n            ',',\n            '`',\n            '~',\n            '|',\n            '<',\n            '>',\n            '\"'\n        ];\n        let needsQuotes = false;\n        for (const char of arg) {\n            if (cmdSpecialChars.some(x => x === char)) {\n                needsQuotes = true;\n                break;\n            }\n        }\n        // short-circuit if quotes not needed\n        if (!needsQuotes) {\n            return arg;\n        }\n        // the following quoting rules are very similar to the rules that by libuv applies.\n        //\n        // 1) wrap the string in quotes\n        //\n        // 2) double-up quotes - i.e. \" => \"\"\n        //\n        //    this is different from the libuv quoting rules. libuv replaces \" with \\\", which unfortunately\n        //    doesn't work well with a cmd.exe command line.\n        //\n        //    note, replacing \" with \"\" also works well if the arg is passed to a downstream .NET console app.\n        //    for example, the command line:\n        //          foo.exe \"myarg:\"\"my val\"\"\"\n        //    is parsed by a .NET console app into an arg array:\n        //          [ \"myarg:\\\"my val\\\"\" ]\n        //    which is the same end result when applying libuv quoting rules. although the actual\n        //    command line from libuv quoting rules would look like:\n        //          foo.exe \"myarg:\\\"my val\\\"\"\n        //\n        // 3) double-up slashes that precede a quote,\n        //    e.g.  hello \\world    => \"hello \\world\"\n        //          hello\\\"world    => \"hello\\\\\"\"world\"\n        //          hello\\\\\"world   => \"hello\\\\\\\\\"\"world\"\n        //          hello world\\    => \"hello world\\\\\"\n        //\n        //    technically this is not required for a cmd.exe command line, or the batch argument parser.\n        //    the reasons for including this as a .cmd quoting rule are:\n        //\n        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an\n        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.\n        //\n        //    b) it's what we've been doing previously (by deferring to node default behavior) and we\n        //       haven't heard any complaints about that aspect.\n        //\n        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be\n        // escaped when used on the command line directly - even though within a .cmd file % can be escaped\n        // by using %%.\n        //\n        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts\n        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.\n        //\n        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would\n        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the\n        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args\n        // to an external program.\n        //\n        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.\n        // % can be escaped within a .cmd file.\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\'; // double the slash\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\"'; // double the quote\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _uvQuoteCmdArg(arg) {\n        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as\n        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments\n        // is used.\n        //\n        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,\n        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),\n        // pasting copyright notice from Node within this function:\n        //\n        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n        //\n        //      Permission is hereby granted, free of charge, to any person obtaining a copy\n        //      of this software and associated documentation files (the \"Software\"), to\n        //      deal in the Software without restriction, including without limitation the\n        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n        //      sell copies of the Software, and to permit persons to whom the Software is\n        //      furnished to do so, subject to the following conditions:\n        //\n        //      The above copyright notice and this permission notice shall be included in\n        //      all copies or substantial portions of the Software.\n        //\n        //      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n        //      IN THE SOFTWARE.\n        if (!arg) {\n            // Need double quotation for empty argument\n            return '\"\"';\n        }\n        if (!arg.includes(' ') && !arg.includes('\\t') && !arg.includes('\"')) {\n            // No quotation needed\n            return arg;\n        }\n        if (!arg.includes('\"') && !arg.includes('\\\\')) {\n            // No embedded double quotes or backslashes, so I can just wrap\n            // quote marks around the whole thing.\n            return `\"${arg}\"`;\n        }\n        // Expected input/output:\n        //   input : hello\"world\n        //   output: \"hello\\\"world\"\n        //   input : hello\"\"world\n        //   output: \"hello\\\"\\\"world\"\n        //   input : hello\\world\n        //   output: hello\\world\n        //   input : hello\\\\world\n        //   output: hello\\\\world\n        //   input : hello\\\"world\n        //   output: \"hello\\\\\\\"world\"\n        //   input : hello\\\\\"world\n        //   output: \"hello\\\\\\\\\\\"world\"\n        //   input : hello world\\\n        //   output: \"hello world\\\\\" - note the comment in libuv actually reads \"hello world\\\"\n        //                             but it appears the comment is wrong, it should be \"hello world\\\\\"\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\';\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\\\\';\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _cloneExecOptions(options) {\n        options = options || {};\n        const result = {\n            cwd: options.cwd || process.cwd(),\n            env: options.env || process.env,\n            silent: options.silent || false,\n            windowsVerbatimArguments: options.windowsVerbatimArguments || false,\n            failOnStdErr: options.failOnStdErr || false,\n            ignoreReturnCode: options.ignoreReturnCode || false,\n            delay: options.delay || 10000\n        };\n        result.outStream = options.outStream || process.stdout;\n        result.errStream = options.errStream || process.stderr;\n        return result;\n    }\n    _getSpawnOptions(options, toolPath) {\n        options = options || {};\n        const result = {};\n        result.cwd = options.cwd;\n        result.env = options.env;\n        result['windowsVerbatimArguments'] =\n            options.windowsVerbatimArguments || this._isCmdFile();\n        if (options.windowsVerbatimArguments) {\n            result.argv0 = `\"${toolPath}\"`;\n        }\n        return result;\n    }\n    /**\n     * Exec a tool.\n     * Output will be streamed to the live console.\n     * Returns promise with return code\n     *\n     * @param     tool     path to tool to exec\n     * @param     options  optional exec options.  See ExecOptions\n     * @returns   number\n     */\n    exec() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // root the tool path if it is unrooted and contains relative pathing\n            if (!ioUtil.isRooted(this.toolPath) &&\n                (this.toolPath.includes('/') ||\n                    (IS_WINDOWS && this.toolPath.includes('\\\\')))) {\n                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted\n                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);\n            }\n            // if the tool is only a file name, then resolve it from the PATH\n            // otherwise verify it exists (add extension on Windows if necessary)\n            this.toolPath = yield io.which(this.toolPath, true);\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                this._debug(`exec tool: ${this.toolPath}`);\n                this._debug('arguments:');\n                for (const arg of this.args) {\n                    this._debug(`   ${arg}`);\n                }\n                const optionsNonNull = this._cloneExecOptions(this.options);\n                if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n                }\n                const state = new ExecState(optionsNonNull, this.toolPath);\n                state.on('debug', (message) => {\n                    this._debug(message);\n                });\n                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {\n                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));\n                }\n                const fileName = this._getSpawnFileName();\n                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));\n                let stdbuffer = '';\n                if (cp.stdout) {\n                    cp.stdout.on('data', (data) => {\n                        if (this.options.listeners && this.options.listeners.stdout) {\n                            this.options.listeners.stdout(data);\n                        }\n                        if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                            optionsNonNull.outStream.write(data);\n                        }\n                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.stdline) {\n                                this.options.listeners.stdline(line);\n                            }\n                        });\n                    });\n                }\n                let errbuffer = '';\n                if (cp.stderr) {\n                    cp.stderr.on('data', (data) => {\n                        state.processStderr = true;\n                        if (this.options.listeners && this.options.listeners.stderr) {\n                            this.options.listeners.stderr(data);\n                        }\n                        if (!optionsNonNull.silent &&\n                            optionsNonNull.errStream &&\n                            optionsNonNull.outStream) {\n                            const s = optionsNonNull.failOnStdErr\n                                ? optionsNonNull.errStream\n                                : optionsNonNull.outStream;\n                            s.write(data);\n                        }\n                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.errline) {\n                                this.options.listeners.errline(line);\n                            }\n                        });\n                    });\n                }\n                cp.on('error', (err) => {\n                    state.processError = err.message;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    state.CheckComplete();\n                });\n                cp.on('exit', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                cp.on('close', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                state.on('done', (error, exitCode) => {\n                    if (stdbuffer.length > 0) {\n                        this.emit('stdline', stdbuffer);\n                    }\n                    if (errbuffer.length > 0) {\n                        this.emit('errline', errbuffer);\n                    }\n                    cp.removeAllListeners();\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(exitCode);\n                    }\n                });\n                if (this.options.input) {\n                    if (!cp.stdin) {\n                        throw new Error('child process missing stdin');\n                    }\n                    cp.stdin.end(this.options.input);\n                }\n            }));\n        });\n    }\n}\nexports.ToolRunner = ToolRunner;\n/**\n * Convert an arg string to an array of args. Handles escaping\n *\n * @param    argString   string of arguments\n * @returns  string[]    array of arguments\n */\nfunction argStringToArray(argString) {\n    const args = [];\n    let inQuotes = false;\n    let escaped = false;\n    let arg = '';\n    function append(c) {\n        // we only escape double quotes.\n        if (escaped && c !== '\"') {\n            arg += '\\\\';\n        }\n        arg += c;\n        escaped = false;\n    }\n    for (let i = 0; i < argString.length; i++) {\n        const c = argString.charAt(i);\n        if (c === '\"') {\n            if (!escaped) {\n                inQuotes = !inQuotes;\n            }\n            else {\n                append(c);\n            }\n            continue;\n        }\n        if (c === '\\\\' && escaped) {\n            append(c);\n            continue;\n        }\n        if (c === '\\\\' && inQuotes) {\n            escaped = true;\n            continue;\n        }\n        if (c === ' ' && !inQuotes) {\n            if (arg.length > 0) {\n                args.push(arg);\n                arg = '';\n            }\n            continue;\n        }\n        append(c);\n    }\n    if (arg.length > 0) {\n        args.push(arg.trim());\n    }\n    return args;\n}\nexports.argStringToArray = argStringToArray;\nclass ExecState extends events.EventEmitter {\n    constructor(options, toolPath) {\n        super();\n        this.processClosed = false; // tracks whether the process has exited and stdio is closed\n        this.processError = '';\n        this.processExitCode = 0;\n        this.processExited = false; // tracks whether the process has exited\n        this.processStderr = false; // tracks whether stderr was written to\n        this.delay = 10000; // 10 seconds\n        this.done = false;\n        this.timeout = null;\n        if (!toolPath) {\n            throw new Error('toolPath must not be empty');\n        }\n        this.options = options;\n        this.toolPath = toolPath;\n        if (options.delay) {\n            this.delay = options.delay;\n        }\n    }\n    CheckComplete() {\n        if (this.done) {\n            return;\n        }\n        if (this.processClosed) {\n            this._setResult();\n        }\n        else if (this.processExited) {\n            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);\n        }\n    }\n    _debug(message) {\n        this.emit('debug', message);\n    }\n    _setResult() {\n        // determine whether there is an error\n        let error;\n        if (this.processExited) {\n            if (this.processError) {\n                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);\n            }\n            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {\n                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);\n            }\n            else if (this.processStderr && this.options.failOnStdErr) {\n                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);\n            }\n        }\n        // clear the timeout\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.done = true;\n        this.emit('done', error, this.processExitCode);\n    }\n    static HandleTimeout(state) {\n        if (state.done) {\n            return;\n        }\n        if (!state.processClosed && state.processExited) {\n            const message = `The STDIO streams did not close within ${state.delay /\n                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;\n            state._debug(message);\n        }\n        state._setResult();\n    }\n}\n//# sourceMappingURL=toolrunner.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rename = exports.readlink = exports.readdir = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\n_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\nexports.IS_WINDOWS = process.platform === 'win32';\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n// Get the path of cmd.exe in windows\nfunction getCmdPath() {\n    var _a;\n    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;\n}\nexports.getCmdPath = getCmdPath;\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;\nconst assert_1 = require(\"assert\");\nconst childProcess = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst util_1 = require(\"util\");\nconst ioUtil = __importStar(require(\"./io-util\"));\nconst exec = util_1.promisify(childProcess.exec);\nconst execFile = util_1.promisify(childProcess.execFile);\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive, copySourceDirectory } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory() && copySourceDirectory\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another\n            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.\n            // Check for invalid characters\n            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n            if (/[*\"<>|]/.test(inputPath)) {\n                throw new Error('File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows');\n            }\n            try {\n                const cmdPath = ioUtil.getCmdPath();\n                if (yield ioUtil.isDirectory(inputPath, true)) {\n                    yield exec(`${cmdPath} /s /c \"rd /s /q \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n                else {\n                    yield exec(`${cmdPath} /s /c \"del /f /a \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that\n            try {\n                yield ioUtil.unlink(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n        }\n        else {\n            let isDir = false;\n            try {\n                isDir = yield ioUtil.isDirectory(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n                return;\n            }\n            if (isDir) {\n                yield execFile(`rm`, [`-rf`, `${inputPath}`]);\n            }\n            else {\n                yield ioUtil.unlink(inputPath);\n            }\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        yield ioUtil.mkdir(fsPath, { recursive: true });\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n            return result;\n        }\n        const matches = yield findInPath(tool);\n        if (matches && matches.length > 0) {\n            return matches[0];\n        }\n        return '';\n    });\n}\nexports.which = which;\n/**\n * Returns a list of all occurrences of the given tool on the system path.\n *\n * @returns   Promise<string[]>  the paths of the tool\n */\nfunction findInPath(tool) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // build the list of extensions to try\n        const extensions = [];\n        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {\n            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {\n                if (extension) {\n                    extensions.push(extension);\n                }\n            }\n        }\n        // if it's rooted, return it if exists. otherwise return empty.\n        if (ioUtil.isRooted(tool)) {\n            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n            if (filePath) {\n                return [filePath];\n            }\n            return [];\n        }\n        // if any path separators, return empty\n        if (tool.includes(path.sep)) {\n            return [];\n        }\n        // build the list of directories\n        //\n        // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n        // it feels like we should not do this. Checking the current directory seems like more of a use\n        // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n        // across platforms.\n        const directories = [];\n        if (process.env.PATH) {\n            for (const p of process.env.PATH.split(path.delimiter)) {\n                if (p) {\n                    directories.push(p);\n                }\n            }\n        }\n        // find all matches\n        const matches = [];\n        for (const directory of directories) {\n            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);\n            if (filePath) {\n                matches.push(filePath);\n            }\n        }\n        return matches;\n    });\n}\nexports.findInPath = findInPath;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    const copySourceDirectory = options.copySourceDirectory == null\n        ? true\n        : Boolean(options.copySourceDirectory);\n    return { force, recursive, copySourceDirectory };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._readLinuxVersionFile = exports._getOsVersion = exports._findMatch = void 0;\nconst semver = __importStar(require(\"semver\"));\nconst core_1 = require(\"@actions/core\");\n// needs to be require for core node modules to be mocked\n/* eslint @typescript-eslint/no-require-imports: 0 */\nconst os = require(\"os\");\nconst cp = require(\"child_process\");\nconst fs = require(\"fs\");\nfunction _findMatch(versionSpec, stable, candidates, archFilter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const platFilter = os.platform();\n        let result;\n        let match;\n        let file;\n        for (const candidate of candidates) {\n            const version = candidate.version;\n            core_1.debug(`check ${version} satisfies ${versionSpec}`);\n            if (semver.satisfies(version, versionSpec) &&\n                (!stable || candidate.stable === stable)) {\n                file = candidate.files.find(item => {\n                    core_1.debug(`${item.arch}===${archFilter} && ${item.platform}===${platFilter}`);\n                    let chk = item.arch === archFilter && item.platform === platFilter;\n                    if (chk && item.platform_version) {\n                        const osVersion = module.exports._getOsVersion();\n                        if (osVersion === item.platform_version) {\n                            chk = true;\n                        }\n                        else {\n                            chk = semver.satisfies(osVersion, item.platform_version);\n                        }\n                    }\n                    return chk;\n                });\n                if (file) {\n                    core_1.debug(`matched ${candidate.version}`);\n                    match = candidate;\n                    break;\n                }\n            }\n        }\n        if (match && file) {\n            // clone since we're mutating the file list to be only the file that matches\n            result = Object.assign({}, match);\n            result.files = [file];\n        }\n        return result;\n    });\n}\nexports._findMatch = _findMatch;\nfunction _getOsVersion() {\n    // TODO: add windows and other linux, arm variants\n    // right now filtering on version is only an ubuntu and macos scenario for tools we build for hosted (python)\n    const plat = os.platform();\n    let version = '';\n    if (plat === 'darwin') {\n        version = cp.execSync('sw_vers -productVersion').toString();\n    }\n    else if (plat === 'linux') {\n        // lsb_release process not in some containers, readfile\n        // Run cat /etc/lsb-release\n        // DISTRIB_ID=Ubuntu\n        // DISTRIB_RELEASE=18.04\n        // DISTRIB_CODENAME=bionic\n        // DISTRIB_DESCRIPTION=\"Ubuntu 18.04.4 LTS\"\n        const lsbContents = module.exports._readLinuxVersionFile();\n        if (lsbContents) {\n            const lines = lsbContents.split('\\n');\n            for (const line of lines) {\n                const parts = line.split('=');\n                if (parts.length === 2 &&\n                    (parts[0].trim() === 'VERSION_ID' ||\n                        parts[0].trim() === 'DISTRIB_RELEASE')) {\n                    version = parts[1]\n                        .trim()\n                        .replace(/^\"/, '')\n                        .replace(/\"$/, '');\n                    break;\n                }\n            }\n        }\n    }\n    return version;\n}\nexports._getOsVersion = _getOsVersion;\nfunction _readLinuxVersionFile() {\n    const lsbReleaseFile = '/etc/lsb-release';\n    const osReleaseFile = '/etc/os-release';\n    let contents = '';\n    if (fs.existsSync(lsbReleaseFile)) {\n        contents = fs.readFileSync(lsbReleaseFile).toString();\n    }\n    else if (fs.existsSync(osReleaseFile)) {\n        contents = fs.readFileSync(osReleaseFile).toString();\n    }\n    return contents;\n}\nexports._readLinuxVersionFile = _readLinuxVersionFile;\n//# sourceMappingURL=manifest.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RetryHelper = void 0;\nconst core = __importStar(require(\"@actions/core\"));\n/**\n * Internal class for retries\n */\nclass RetryHelper {\n    constructor(maxAttempts, minSeconds, maxSeconds) {\n        if (maxAttempts < 1) {\n            throw new Error('max attempts should be greater than or equal to 1');\n        }\n        this.maxAttempts = maxAttempts;\n        this.minSeconds = Math.floor(minSeconds);\n        this.maxSeconds = Math.floor(maxSeconds);\n        if (this.minSeconds > this.maxSeconds) {\n            throw new Error('min seconds should be less than or equal to max seconds');\n        }\n    }\n    execute(action, isRetryable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let attempt = 1;\n            while (attempt < this.maxAttempts) {\n                // Try\n                try {\n                    return yield action();\n                }\n                catch (err) {\n                    if (isRetryable && !isRetryable(err)) {\n                        throw err;\n                    }\n                    core.info(err.message);\n                }\n                // Sleep\n                const seconds = this.getSleepAmount();\n                core.info(`Waiting ${seconds} seconds before trying again`);\n                yield this.sleep(seconds);\n                attempt++;\n            }\n            // Last attempt\n            return yield action();\n        });\n    }\n    getSleepAmount() {\n        return (Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) +\n            this.minSeconds);\n    }\n    sleep(seconds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n        });\n    }\n}\nexports.RetryHelper = RetryHelper;\n//# sourceMappingURL=retry-helper.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.evaluateVersions = exports.isExplicitVersion = exports.findFromManifest = exports.getManifestFromRepo = exports.findAllVersions = exports.find = exports.cacheFile = exports.cacheDir = exports.extractZip = exports.extractXar = exports.extractTar = exports.extract7z = exports.downloadTool = exports.HTTPError = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst fs = __importStar(require(\"fs\"));\nconst mm = __importStar(require(\"./manifest\"));\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst httpm = __importStar(require(\"@actions/http-client\"));\nconst semver = __importStar(require(\"semver\"));\nconst stream = __importStar(require(\"stream\"));\nconst util = __importStar(require(\"util\"));\nconst v4_1 = __importDefault(require(\"uuid/v4\"));\nconst exec_1 = require(\"@actions/exec/lib/exec\");\nconst assert_1 = require(\"assert\");\nconst retry_helper_1 = require(\"./retry-helper\");\nclass HTTPError extends Error {\n    constructor(httpStatusCode) {\n        super(`Unexpected HTTP response: ${httpStatusCode}`);\n        this.httpStatusCode = httpStatusCode;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.HTTPError = HTTPError;\nconst IS_WINDOWS = process.platform === 'win32';\nconst IS_MAC = process.platform === 'darwin';\nconst userAgent = 'actions/tool-cache';\n/**\n * Download a tool from an url and stream it into a file\n *\n * @param url       url of tool to download\n * @param dest      path to download tool\n * @param auth      authorization header\n * @param headers   other headers\n * @returns         path to downloaded tool\n */\nfunction downloadTool(url, dest, auth, headers) {\n    return __awaiter(this, void 0, void 0, function* () {\n        dest = dest || path.join(_getTempDirectory(), v4_1.default());\n        yield io.mkdirP(path.dirname(dest));\n        core.debug(`Downloading ${url}`);\n        core.debug(`Destination ${dest}`);\n        const maxAttempts = 3;\n        const minSeconds = _getGlobal('TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS', 10);\n        const maxSeconds = _getGlobal('TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS', 20);\n        const retryHelper = new retry_helper_1.RetryHelper(maxAttempts, minSeconds, maxSeconds);\n        return yield retryHelper.execute(() => __awaiter(this, void 0, void 0, function* () {\n            return yield downloadToolAttempt(url, dest || '', auth, headers);\n        }), (err) => {\n            if (err instanceof HTTPError && err.httpStatusCode) {\n                // Don't retry anything less than 500, except 408 Request Timeout and 429 Too Many Requests\n                if (err.httpStatusCode < 500 &&\n                    err.httpStatusCode !== 408 &&\n                    err.httpStatusCode !== 429) {\n                    return false;\n                }\n            }\n            // Otherwise retry\n            return true;\n        });\n    });\n}\nexports.downloadTool = downloadTool;\nfunction downloadToolAttempt(url, dest, auth, headers) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (fs.existsSync(dest)) {\n            throw new Error(`Destination file path ${dest} already exists`);\n        }\n        // Get the response headers\n        const http = new httpm.HttpClient(userAgent, [], {\n            allowRetries: false\n        });\n        if (auth) {\n            core.debug('set auth');\n            if (headers === undefined) {\n                headers = {};\n            }\n            headers.authorization = auth;\n        }\n        const response = yield http.get(url, headers);\n        if (response.message.statusCode !== 200) {\n            const err = new HTTPError(response.message.statusCode);\n            core.debug(`Failed to download from \"${url}\". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);\n            throw err;\n        }\n        // Download the response body\n        const pipeline = util.promisify(stream.pipeline);\n        const responseMessageFactory = _getGlobal('TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY', () => response.message);\n        const readStream = responseMessageFactory();\n        let succeeded = false;\n        try {\n            yield pipeline(readStream, fs.createWriteStream(dest));\n            core.debug('download complete');\n            succeeded = true;\n            return dest;\n        }\n        finally {\n            // Error, delete dest before retry\n            if (!succeeded) {\n                core.debug('download failed');\n                try {\n                    yield io.rmRF(dest);\n                }\n                catch (err) {\n                    core.debug(`Failed to delete '${dest}'. ${err.message}`);\n                }\n            }\n        }\n    });\n}\n/**\n * Extract a .7z file\n *\n * @param file     path to the .7z file\n * @param dest     destination directory. Optional.\n * @param _7zPath  path to 7zr.exe. Optional, for long path support. Most .7z archives do not have this\n * problem. If your .7z archive contains very long paths, you can pass the path to 7zr.exe which will\n * gracefully handle long paths. By default 7zdec.exe is used because it is a very small program and is\n * bundled with the tool lib. However it does not support long paths. 7zr.exe is the reduced command line\n * interface, it is smaller than the full command line interface, and it does support long paths. At the\n * time of this writing, it is freely available from the LZMA SDK that is available on the 7zip website.\n * Be sure to check the current license agreement. If 7zr.exe is bundled with your action, then the path\n * to 7zr.exe can be pass to this function.\n * @returns        path to the destination directory\n */\nfunction extract7z(file, dest, _7zPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(IS_WINDOWS, 'extract7z() not supported on current OS');\n        assert_1.ok(file, 'parameter \"file\" is required');\n        dest = yield _createExtractFolder(dest);\n        const originalCwd = process.cwd();\n        process.chdir(dest);\n        if (_7zPath) {\n            try {\n                const logLevel = core.isDebug() ? '-bb1' : '-bb0';\n                const args = [\n                    'x',\n                    logLevel,\n                    '-bd',\n                    '-sccUTF-8',\n                    file\n                ];\n                const options = {\n                    silent: true\n                };\n                yield exec_1.exec(`\"${_7zPath}\"`, args, options);\n            }\n            finally {\n                process.chdir(originalCwd);\n            }\n        }\n        else {\n            const escapedScript = path\n                .join(__dirname, '..', 'scripts', 'Invoke-7zdec.ps1')\n                .replace(/'/g, \"''\")\n                .replace(/\"|\\n|\\r/g, ''); // double-up single quotes, remove double quotes and newlines\n            const escapedFile = file.replace(/'/g, \"''\").replace(/\"|\\n|\\r/g, '');\n            const escapedTarget = dest.replace(/'/g, \"''\").replace(/\"|\\n|\\r/g, '');\n            const command = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}'`;\n            const args = [\n                '-NoLogo',\n                '-Sta',\n                '-NoProfile',\n                '-NonInteractive',\n                '-ExecutionPolicy',\n                'Unrestricted',\n                '-Command',\n                command\n            ];\n            const options = {\n                silent: true\n            };\n            try {\n                const powershellPath = yield io.which('powershell', true);\n                yield exec_1.exec(`\"${powershellPath}\"`, args, options);\n            }\n            finally {\n                process.chdir(originalCwd);\n            }\n        }\n        return dest;\n    });\n}\nexports.extract7z = extract7z;\n/**\n * Extract a compressed tar archive\n *\n * @param file     path to the tar\n * @param dest     destination directory. Optional.\n * @param flags    flags for the tar command to use for extraction. Defaults to 'xz' (extracting gzipped tars). Optional.\n * @returns        path to the destination directory\n */\nfunction extractTar(file, dest, flags = 'xz') {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!file) {\n            throw new Error(\"parameter 'file' is required\");\n        }\n        // Create dest\n        dest = yield _createExtractFolder(dest);\n        // Determine whether GNU tar\n        core.debug('Checking tar --version');\n        let versionOutput = '';\n        yield exec_1.exec('tar --version', [], {\n            ignoreReturnCode: true,\n            silent: true,\n            listeners: {\n                stdout: (data) => (versionOutput += data.toString()),\n                stderr: (data) => (versionOutput += data.toString())\n            }\n        });\n        core.debug(versionOutput.trim());\n        const isGnuTar = versionOutput.toUpperCase().includes('GNU TAR');\n        // Initialize args\n        let args;\n        if (flags instanceof Array) {\n            args = flags;\n        }\n        else {\n            args = [flags];\n        }\n        if (core.isDebug() && !flags.includes('v')) {\n            args.push('-v');\n        }\n        let destArg = dest;\n        let fileArg = file;\n        if (IS_WINDOWS && isGnuTar) {\n            args.push('--force-local');\n            destArg = dest.replace(/\\\\/g, '/');\n            // Technically only the dest needs to have `/` but for aesthetic consistency\n            // convert slashes in the file arg too.\n            fileArg = file.replace(/\\\\/g, '/');\n        }\n        if (isGnuTar) {\n            // Suppress warnings when using GNU tar to extract archives created by BSD tar\n            args.push('--warning=no-unknown-keyword');\n            args.push('--overwrite');\n        }\n        args.push('-C', destArg, '-f', fileArg);\n        yield exec_1.exec(`tar`, args);\n        return dest;\n    });\n}\nexports.extractTar = extractTar;\n/**\n * Extract a xar compatible archive\n *\n * @param file     path to the archive\n * @param dest     destination directory. Optional.\n * @param flags    flags for the xar. Optional.\n * @returns        path to the destination directory\n */\nfunction extractXar(file, dest, flags = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(IS_MAC, 'extractXar() not supported on current OS');\n        assert_1.ok(file, 'parameter \"file\" is required');\n        dest = yield _createExtractFolder(dest);\n        let args;\n        if (flags instanceof Array) {\n            args = flags;\n        }\n        else {\n            args = [flags];\n        }\n        args.push('-x', '-C', dest, '-f', file);\n        if (core.isDebug()) {\n            args.push('-v');\n        }\n        const xarPath = yield io.which('xar', true);\n        yield exec_1.exec(`\"${xarPath}\"`, _unique(args));\n        return dest;\n    });\n}\nexports.extractXar = extractXar;\n/**\n * Extract a zip\n *\n * @param file     path to the zip\n * @param dest     destination directory. Optional.\n * @returns        path to the destination directory\n */\nfunction extractZip(file, dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!file) {\n            throw new Error(\"parameter 'file' is required\");\n        }\n        dest = yield _createExtractFolder(dest);\n        if (IS_WINDOWS) {\n            yield extractZipWin(file, dest);\n        }\n        else {\n            yield extractZipNix(file, dest);\n        }\n        return dest;\n    });\n}\nexports.extractZip = extractZip;\nfunction extractZipWin(file, dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // build the powershell command\n        const escapedFile = file.replace(/'/g, \"''\").replace(/\"|\\n|\\r/g, ''); // double-up single quotes, remove double quotes and newlines\n        const escapedDest = dest.replace(/'/g, \"''\").replace(/\"|\\n|\\r/g, '');\n        const pwshPath = yield io.which('pwsh', false);\n        //To match the file overwrite behavior on nix systems, we use the overwrite = true flag for ExtractToDirectory\n        //and the -Force flag for Expand-Archive as a fallback\n        if (pwshPath) {\n            //attempt to use pwsh with ExtractToDirectory, if this fails attempt Expand-Archive\n            const pwshCommand = [\n                `$ErrorActionPreference = 'Stop' ;`,\n                `try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;`,\n                `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`,\n                `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force } else { throw $_ } } ;`\n            ].join(' ');\n            const args = [\n                '-NoLogo',\n                '-NoProfile',\n                '-NonInteractive',\n                '-ExecutionPolicy',\n                'Unrestricted',\n                '-Command',\n                pwshCommand\n            ];\n            core.debug(`Using pwsh at path: ${pwshPath}`);\n            yield exec_1.exec(`\"${pwshPath}\"`, args);\n        }\n        else {\n            const powershellCommand = [\n                `$ErrorActionPreference = 'Stop' ;`,\n                `try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;`,\n                `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force }`,\n                `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`\n            ].join(' ');\n            const args = [\n                '-NoLogo',\n                '-Sta',\n                '-NoProfile',\n                '-NonInteractive',\n                '-ExecutionPolicy',\n                'Unrestricted',\n                '-Command',\n                powershellCommand\n            ];\n            const powershellPath = yield io.which('powershell', true);\n            core.debug(`Using powershell at path: ${powershellPath}`);\n            yield exec_1.exec(`\"${powershellPath}\"`, args);\n        }\n    });\n}\nfunction extractZipNix(file, dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const unzipPath = yield io.which('unzip', true);\n        const args = [file];\n        if (!core.isDebug()) {\n            args.unshift('-q');\n        }\n        args.unshift('-o'); //overwrite with -o, otherwise a prompt is shown which freezes the run\n        yield exec_1.exec(`\"${unzipPath}\"`, args, { cwd: dest });\n    });\n}\n/**\n * Caches a directory and installs it into the tool cacheDir\n *\n * @param sourceDir    the directory to cache into tools\n * @param tool          tool name\n * @param version       version of the tool.  semver format\n * @param arch          architecture of the tool.  Optional.  Defaults to machine architecture\n */\nfunction cacheDir(sourceDir, tool, version, arch) {\n    return __awaiter(this, void 0, void 0, function* () {\n        version = semver.clean(version) || version;\n        arch = arch || os.arch();\n        core.debug(`Caching tool ${tool} ${version} ${arch}`);\n        core.debug(`source dir: ${sourceDir}`);\n        if (!fs.statSync(sourceDir).isDirectory()) {\n            throw new Error('sourceDir is not a directory');\n        }\n        // Create the tool dir\n        const destPath = yield _createToolPath(tool, version, arch);\n        // copy each child item. do not move. move can fail on Windows\n        // due to anti-virus software having an open handle on a file.\n        for (const itemName of fs.readdirSync(sourceDir)) {\n            const s = path.join(sourceDir, itemName);\n            yield io.cp(s, destPath, { recursive: true });\n        }\n        // write .complete\n        _completeToolPath(tool, version, arch);\n        return destPath;\n    });\n}\nexports.cacheDir = cacheDir;\n/**\n * Caches a downloaded file (GUID) and installs it\n * into the tool cache with a given targetName\n *\n * @param sourceFile    the file to cache into tools.  Typically a result of downloadTool which is a guid.\n * @param targetFile    the name of the file name in the tools directory\n * @param tool          tool name\n * @param version       version of the tool.  semver format\n * @param arch          architecture of the tool.  Optional.  Defaults to machine architecture\n */\nfunction cacheFile(sourceFile, targetFile, tool, version, arch) {\n    return __awaiter(this, void 0, void 0, function* () {\n        version = semver.clean(version) || version;\n        arch = arch || os.arch();\n        core.debug(`Caching tool ${tool} ${version} ${arch}`);\n        core.debug(`source file: ${sourceFile}`);\n        if (!fs.statSync(sourceFile).isFile()) {\n            throw new Error('sourceFile is not a file');\n        }\n        // create the tool dir\n        const destFolder = yield _createToolPath(tool, version, arch);\n        // copy instead of move. move can fail on Windows due to\n        // anti-virus software having an open handle on a file.\n        const destPath = path.join(destFolder, targetFile);\n        core.debug(`destination file ${destPath}`);\n        yield io.cp(sourceFile, destPath);\n        // write .complete\n        _completeToolPath(tool, version, arch);\n        return destFolder;\n    });\n}\nexports.cacheFile = cacheFile;\n/**\n * Finds the path to a tool version in the local installed tool cache\n *\n * @param toolName      name of the tool\n * @param versionSpec   version of the tool\n * @param arch          optional arch.  defaults to arch of computer\n */\nfunction find(toolName, versionSpec, arch) {\n    if (!toolName) {\n        throw new Error('toolName parameter is required');\n    }\n    if (!versionSpec) {\n        throw new Error('versionSpec parameter is required');\n    }\n    arch = arch || os.arch();\n    // attempt to resolve an explicit version\n    if (!isExplicitVersion(versionSpec)) {\n        const localVersions = findAllVersions(toolName, arch);\n        const match = evaluateVersions(localVersions, versionSpec);\n        versionSpec = match;\n    }\n    // check for the explicit version in the cache\n    let toolPath = '';\n    if (versionSpec) {\n        versionSpec = semver.clean(versionSpec) || '';\n        const cachePath = path.join(_getCacheDirectory(), toolName, versionSpec, arch);\n        core.debug(`checking cache: ${cachePath}`);\n        if (fs.existsSync(cachePath) && fs.existsSync(`${cachePath}.complete`)) {\n            core.debug(`Found tool in cache ${toolName} ${versionSpec} ${arch}`);\n            toolPath = cachePath;\n        }\n        else {\n            core.debug('not found');\n        }\n    }\n    return toolPath;\n}\nexports.find = find;\n/**\n * Finds the paths to all versions of a tool that are installed in the local tool cache\n *\n * @param toolName  name of the tool\n * @param arch      optional arch.  defaults to arch of computer\n */\nfunction findAllVersions(toolName, arch) {\n    const versions = [];\n    arch = arch || os.arch();\n    const toolPath = path.join(_getCacheDirectory(), toolName);\n    if (fs.existsSync(toolPath)) {\n        const children = fs.readdirSync(toolPath);\n        for (const child of children) {\n            if (isExplicitVersion(child)) {\n                const fullPath = path.join(toolPath, child, arch || '');\n                if (fs.existsSync(fullPath) && fs.existsSync(`${fullPath}.complete`)) {\n                    versions.push(child);\n                }\n            }\n        }\n    }\n    return versions;\n}\nexports.findAllVersions = findAllVersions;\nfunction getManifestFromRepo(owner, repo, auth, branch = 'master') {\n    return __awaiter(this, void 0, void 0, function* () {\n        let releases = [];\n        const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}`;\n        const http = new httpm.HttpClient('tool-cache');\n        const headers = {};\n        if (auth) {\n            core.debug('set auth');\n            headers.authorization = auth;\n        }\n        const response = yield http.getJson(treeUrl, headers);\n        if (!response.result) {\n            return releases;\n        }\n        let manifestUrl = '';\n        for (const item of response.result.tree) {\n            if (item.path === 'versions-manifest.json') {\n                manifestUrl = item.url;\n                break;\n            }\n        }\n        headers['accept'] = 'application/vnd.github.VERSION.raw';\n        let versionsRaw = yield (yield http.get(manifestUrl, headers)).readBody();\n        if (versionsRaw) {\n            // shouldn't be needed but protects against invalid json saved with BOM\n            versionsRaw = versionsRaw.replace(/^\\uFEFF/, '');\n            try {\n                releases = JSON.parse(versionsRaw);\n            }\n            catch (_a) {\n                core.debug('Invalid json');\n            }\n        }\n        return releases;\n    });\n}\nexports.getManifestFromRepo = getManifestFromRepo;\nfunction findFromManifest(versionSpec, stable, manifest, archFilter = os.arch()) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // wrap the internal impl\n        const match = yield mm._findMatch(versionSpec, stable, manifest, archFilter);\n        return match;\n    });\n}\nexports.findFromManifest = findFromManifest;\nfunction _createExtractFolder(dest) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!dest) {\n            // create a temp dir\n            dest = path.join(_getTempDirectory(), v4_1.default());\n        }\n        yield io.mkdirP(dest);\n        return dest;\n    });\n}\nfunction _createToolPath(tool, version, arch) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch || '');\n        core.debug(`destination ${folderPath}`);\n        const markerPath = `${folderPath}.complete`;\n        yield io.rmRF(folderPath);\n        yield io.rmRF(markerPath);\n        yield io.mkdirP(folderPath);\n        return folderPath;\n    });\n}\nfunction _completeToolPath(tool, version, arch) {\n    const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch || '');\n    const markerPath = `${folderPath}.complete`;\n    fs.writeFileSync(markerPath, '');\n    core.debug('finished caching tool');\n}\n/**\n * Check if version string is explicit\n *\n * @param versionSpec      version string to check\n */\nfunction isExplicitVersion(versionSpec) {\n    const c = semver.clean(versionSpec) || '';\n    core.debug(`isExplicit: ${c}`);\n    const valid = semver.valid(c) != null;\n    core.debug(`explicit? ${valid}`);\n    return valid;\n}\nexports.isExplicitVersion = isExplicitVersion;\n/**\n * Get the highest satisfiying semantic version in `versions` which satisfies `versionSpec`\n *\n * @param versions        array of versions to evaluate\n * @param versionSpec     semantic version spec to satisfy\n */\nfunction evaluateVersions(versions, versionSpec) {\n    let version = '';\n    core.debug(`evaluating ${versions.length} versions`);\n    versions = versions.sort((a, b) => {\n        if (semver.gt(a, b)) {\n            return 1;\n        }\n        return -1;\n    });\n    for (let i = versions.length - 1; i >= 0; i--) {\n        const potential = versions[i];\n        const satisfied = semver.satisfies(potential, versionSpec);\n        if (satisfied) {\n            version = potential;\n            break;\n        }\n    }\n    if (version) {\n        core.debug(`matched: ${version}`);\n    }\n    else {\n        core.debug('match not found');\n    }\n    return version;\n}\nexports.evaluateVersions = evaluateVersions;\n/**\n * Gets RUNNER_TOOL_CACHE\n */\nfunction _getCacheDirectory() {\n    const cacheDirectory = process.env['RUNNER_TOOL_CACHE'] || '';\n    assert_1.ok(cacheDirectory, 'Expected RUNNER_TOOL_CACHE to be defined');\n    return cacheDirectory;\n}\n/**\n * Gets RUNNER_TEMP\n */\nfunction _getTempDirectory() {\n    const tempDirectory = process.env['RUNNER_TEMP'] || '';\n    assert_1.ok(tempDirectory, 'Expected RUNNER_TEMP to be defined');\n    return tempDirectory;\n}\n/**\n * Gets a global variable\n */\nfunction _getGlobal(key, defaultValue) {\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    const value = global[key];\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return value !== undefined ? value : defaultValue;\n}\n/**\n * Returns an array of unique values.\n * @param values Values to make unique.\n */\nfunction _unique(values) {\n    return Array.from(new Set(values));\n}\n//# sourceMappingURL=tool-cache.js.map","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n\n  newInvalidAsn1Error: function (msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = require('./errors');\nvar types = require('./types');\n\nvar Reader = require('./reader');\nvar Writer = require('./writer');\n\n\n// --- Exports\n\nmodule.exports = {\n\n  Reader: Reader,\n\n  Writer: Writer\n\n};\n\nfor (var t in types) {\n  if (types.hasOwnProperty(t))\n    module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e))\n    module.exports[e] = errors[e];\n}\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n// --- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\n\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () { return (this._len); }\n});\n\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () { return (this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () { return (this._size - this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () { return (this._buf.slice(this._offset)); }\n});\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) === 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB === 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function () {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return retbuf ? Buffer.alloc(0) : '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function (tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.readString(tag, true);\n  if (b === null)\n    return null;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) === 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) === 0x80 && i !== 4)\n    value -= (1 << (i * 8));\n\n  return value >> 0;\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Reader;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9, // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = require('./ber/index');\n\n\n\n// --- Exported API\n\nmodule.exports = {\n\n  Ber: Ber,\n\n  BerReader: Ber.Reader,\n\n  BerWriter: Ber.Writer\n\n};\n","'use strict';\n\nvar crypto_hash_sha512 = require('tweetnacl').lowlevel.crypto_hash;\n\n/*\n * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a\n * result, it retains the original copyright and license. The two files are\n * under slightly different (but compatible) licenses, and are here combined in\n * one file.\n *\n * Credit for the actual porting work goes to:\n *  Devi Mandiri <me@devi.web.id>\n */\n\n/*\n * The Blowfish portions are under the following license:\n *\n * Blowfish block cipher for OpenBSD\n * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>\n * All rights reserved.\n *\n * Implementation advice by David Mazieres <dm@lcs.mit.edu>.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * The bcrypt_pbkdf portions are under the following license:\n *\n * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Performance improvements (Javascript-specific):\n *\n * Copyright 2016, Joyent Inc\n * Author: Alex Wilson <alex.wilson@joyent.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// Ported from OpenBSD bcrypt_pbkdf.c v1.9\n\nvar BLF_J = 0;\n\nvar Blowfish = function() {\n  this.S = [\n    new Uint32Array([\n      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,\n      0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,\n      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,\n      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,\n      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,\n      0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,\n      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,\n      0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,\n      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,\n      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,\n      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,\n      0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,\n      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,\n      0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,\n      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,\n      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,\n      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,\n      0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,\n      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,\n      0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,\n      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,\n      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,\n      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,\n      0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,\n      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,\n      0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,\n      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,\n      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,\n      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,\n      0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,\n      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,\n      0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,\n      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,\n      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,\n      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,\n      0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,\n      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,\n      0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,\n      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,\n      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,\n      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,\n      0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,\n      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,\n      0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,\n      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,\n      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,\n      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,\n      0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,\n      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,\n      0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,\n      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,\n      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,\n      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,\n      0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,\n      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,\n      0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,\n      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,\n      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,\n      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,\n      0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,\n      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,\n      0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,\n      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,\n      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]),\n    new Uint32Array([\n      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,\n      0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,\n      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,\n      0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,\n      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,\n      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,\n      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,\n      0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,\n      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,\n      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,\n      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,\n      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,\n      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,\n      0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,\n      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,\n      0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,\n      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,\n      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,\n      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,\n      0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,\n      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,\n      0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,\n      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,\n      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,\n      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,\n      0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,\n      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,\n      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,\n      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,\n      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,\n      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,\n      0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,\n      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,\n      0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,\n      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,\n      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,\n      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,\n      0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,\n      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,\n      0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,\n      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,\n      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,\n      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,\n      0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,\n      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,\n      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,\n      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,\n      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,\n      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,\n      0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,\n      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,\n      0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,\n      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,\n      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,\n      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,\n      0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,\n      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,\n      0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,\n      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,\n      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,\n      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,\n      0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,\n      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,\n      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]),\n    new Uint32Array([\n      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,\n      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,\n      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,\n      0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,\n      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,\n      0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,\n      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,\n      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,\n      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,\n      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,\n      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,\n      0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,\n      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,\n      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,\n      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,\n      0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,\n      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,\n      0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,\n      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,\n      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,\n      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,\n      0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,\n      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,\n      0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,\n      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,\n      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,\n      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,\n      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,\n      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,\n      0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,\n      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,\n      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,\n      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,\n      0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,\n      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,\n      0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,\n      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,\n      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,\n      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,\n      0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,\n      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,\n      0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,\n      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,\n      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,\n      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,\n      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,\n      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,\n      0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,\n      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,\n      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,\n      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,\n      0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,\n      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,\n      0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,\n      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,\n      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,\n      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,\n      0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,\n      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,\n      0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,\n      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,\n      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,\n      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,\n      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]),\n    new Uint32Array([\n      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,\n      0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,\n      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,\n      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,\n      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,\n      0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,\n      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,\n      0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,\n      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,\n      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,\n      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,\n      0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,\n      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,\n      0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,\n      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,\n      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,\n      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,\n      0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,\n      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,\n      0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,\n      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,\n      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,\n      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,\n      0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,\n      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,\n      0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,\n      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,\n      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,\n      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,\n      0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,\n      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,\n      0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,\n      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,\n      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,\n      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,\n      0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,\n      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,\n      0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,\n      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,\n      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,\n      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,\n      0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,\n      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,\n      0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,\n      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,\n      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,\n      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,\n      0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\n      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,\n      0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,\n      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,\n      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,\n      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,\n      0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,\n      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,\n      0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,\n      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,\n      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,\n      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,\n      0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,\n      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,\n      0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,\n      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,\n      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])\n    ];\n  this.P = new Uint32Array([\n    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,\n    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,\n    0x9216d5d9, 0x8979fb1b]);\n};\n\nfunction F(S, x8, i) {\n  return (((S[0][x8[i+3]] +\n            S[1][x8[i+2]]) ^\n            S[2][x8[i+1]]) +\n            S[3][x8[i]]);\n};\n\nBlowfish.prototype.encipher = function(x, x8) {\n  if (x8 === undefined) {\n    x8 = new Uint8Array(x.buffer);\n    if (x.byteOffset !== 0)\n      x8 = x8.subarray(x.byteOffset);\n  }\n  x[0] ^= this.P[0];\n  for (var i = 1; i < 16; i += 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i+1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[17];\n  x[1] = t;\n};\n\nBlowfish.prototype.decipher = function(x) {\n  var x8 = new Uint8Array(x.buffer);\n  if (x.byteOffset !== 0)\n    x8 = x8.subarray(x.byteOffset);\n  x[0] ^= this.P[17];\n  for (var i = 16; i > 0; i -= 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i-1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[0];\n  x[1] = t;\n};\n\nfunction stream2word(data, databytes){\n  var i, temp = 0;\n  for (i = 0; i < 4; i++, BLF_J++) {\n    if (BLF_J >= databytes) BLF_J = 0;\n    temp = (temp << 8) | data[BLF_J];\n  }\n  return temp;\n};\n\nBlowfish.prototype.expand0state = function(key, keybytes) {\n  var d = new Uint32Array(2), i, k;\n  var d8 = new Uint8Array(d.buffer);\n\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n  BLF_J = 0;\n\n  for (i = 0; i < 18; i += 2) {\n    this.encipher(d, d8);\n    this.P[i]   = d[0];\n    this.P[i+1] = d[1];\n  }\n\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      this.encipher(d, d8);\n      this.S[i][k]   = d[0];\n      this.S[i][k+1] = d[1];\n    }\n  }\n};\n\nBlowfish.prototype.expandstate = function(data, databytes, key, keybytes) {\n  var d = new Uint32Array(2), i, k;\n\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n\n  for (i = 0, BLF_J = 0; i < 18; i += 2) {\n    d[0] ^= stream2word(data, databytes);\n    d[1] ^= stream2word(data, databytes);\n    this.encipher(d);\n    this.P[i]   = d[0];\n    this.P[i+1] = d[1];\n  }\n\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      d[0] ^= stream2word(data, databytes);\n      d[1] ^= stream2word(data, databytes);\n      this.encipher(d);\n      this.S[i][k]   = d[0];\n      this.S[i][k+1] = d[1];\n    }\n  }\n  BLF_J = 0;\n};\n\nBlowfish.prototype.enc = function(data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.encipher(data.subarray(i*2));\n  }\n};\n\nBlowfish.prototype.dec = function(data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.decipher(data.subarray(i*2));\n  }\n};\n\nvar BCRYPT_BLOCKS = 8,\n    BCRYPT_HASHSIZE = 32;\n\nfunction bcrypt_hash(sha2pass, sha2salt, out) {\n  var state = new Blowfish(),\n      cdata = new Uint32Array(BCRYPT_BLOCKS), i,\n      ciphertext = new Uint8Array([79,120,121,99,104,114,111,109,97,116,105,\n            99,66,108,111,119,102,105,115,104,83,119,97,116,68,121,110,97,109,\n            105,116,101]); //\"OxychromaticBlowfishSwatDynamite\"\n\n  state.expandstate(sha2salt, 64, sha2pass, 64);\n  for (i = 0; i < 64; i++) {\n    state.expand0state(sha2salt, 64);\n    state.expand0state(sha2pass, 64);\n  }\n\n  for (i = 0; i < BCRYPT_BLOCKS; i++)\n    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);\n  for (i = 0; i < 64; i++)\n    state.enc(cdata, cdata.byteLength / 8);\n\n  for (i = 0; i < BCRYPT_BLOCKS; i++) {\n    out[4*i+3] = cdata[i] >>> 24;\n    out[4*i+2] = cdata[i] >>> 16;\n    out[4*i+1] = cdata[i] >>> 8;\n    out[4*i+0] = cdata[i];\n  }\n};\n\nfunction bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {\n  var sha2pass = new Uint8Array(64),\n      sha2salt = new Uint8Array(64),\n      out = new Uint8Array(BCRYPT_HASHSIZE),\n      tmpout = new Uint8Array(BCRYPT_HASHSIZE),\n      countsalt = new Uint8Array(saltlen+4),\n      i, j, amt, stride, dest, count,\n      origkeylen = keylen;\n\n  if (rounds < 1)\n    return -1;\n  if (passlen === 0 || saltlen === 0 || keylen === 0 ||\n      keylen > (out.byteLength * out.byteLength) || saltlen > (1<<20))\n    return -1;\n\n  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);\n  amt = Math.floor((keylen + stride - 1) / stride);\n\n  for (i = 0; i < saltlen; i++)\n    countsalt[i] = salt[i];\n\n  crypto_hash_sha512(sha2pass, pass, passlen);\n\n  for (count = 1; keylen > 0; count++) {\n    countsalt[saltlen+0] = count >>> 24;\n    countsalt[saltlen+1] = count >>> 16;\n    countsalt[saltlen+2] = count >>>  8;\n    countsalt[saltlen+3] = count;\n\n    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n    bcrypt_hash(sha2pass, sha2salt, tmpout);\n    for (i = out.byteLength; i--;)\n      out[i] = tmpout[i];\n\n    for (i = 1; i < rounds; i++) {\n      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);\n      bcrypt_hash(sha2pass, sha2salt, tmpout);\n      for (j = 0; j < out.byteLength; j++)\n        out[j] ^= tmpout[j];\n    }\n\n    amt = Math.min(amt, keylen);\n    for (i = 0; i < amt; i++) {\n      dest = i * stride + (count - 1);\n      if (dest >= origkeylen)\n        break;\n      key[dest] = out[i];\n    }\n    keylen -= i;\n  }\n\n  return 0;\n};\n\nmodule.exports = {\n      BLOCKS: BCRYPT_BLOCKS,\n      HASHSIZE: BCRYPT_HASHSIZE,\n      hash: bcrypt_hash,\n      pbkdf: bcrypt_pbkdf\n};\n","'use strict'\n\nconst { Buffer } = require('buffer')\nconst symbol = Symbol.for('BufferList')\n\nfunction BufferList (buf) {\n  if (!(this instanceof BufferList)) {\n    return new BufferList(buf)\n  }\n\n  BufferList._init.call(this, buf)\n}\n\nBufferList._init = function _init (buf) {\n  Object.defineProperty(this, symbol, { value: true })\n\n  this._bufs = []\n  this.length = 0\n\n  if (buf) {\n    this.append(buf)\n  }\n}\n\nBufferList.prototype._new = function _new (buf) {\n  return new BufferList(buf)\n}\n\nBufferList.prototype._offset = function _offset (offset) {\n  if (offset === 0) {\n    return [0, 0]\n  }\n\n  let tot = 0\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    const _t = tot + this._bufs[i].length\n    if (offset < _t || i === this._bufs.length - 1) {\n      return [i, offset - tot]\n    }\n    tot = _t\n  }\n}\n\nBufferList.prototype._reverseOffset = function (blOffset) {\n  const bufferId = blOffset[0]\n  let offset = blOffset[1]\n\n  for (let i = 0; i < bufferId; i++) {\n    offset += this._bufs[i].length\n  }\n\n  return offset\n}\n\nBufferList.prototype.get = function get (index) {\n  if (index > this.length || index < 0) {\n    return undefined\n  }\n\n  const offset = this._offset(index)\n\n  return this._bufs[offset[0]][offset[1]]\n}\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start === 'number' && start < 0) {\n    start += this.length\n  }\n\n  if (typeof end === 'number' && end < 0) {\n    end += this.length\n  }\n\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart !== 'number' || srcStart < 0) {\n    srcStart = 0\n  }\n\n  if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n    srcEnd = this.length\n  }\n\n  if (srcStart >= this.length) {\n    return dst || Buffer.alloc(0)\n  }\n\n  if (srcEnd <= 0) {\n    return dst || Buffer.alloc(0)\n  }\n\n  const copy = !!dst\n  const off = this._offset(srcStart)\n  const len = srcEnd - srcStart\n  let bytes = len\n  let bufoff = (copy && dstStart) || 0\n  let start = off[1]\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd === this.length) {\n    if (!copy) {\n      // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (let i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) {\n    // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n  }\n\n  for (let i = off[0]; i < this._bufs.length; i++) {\n    const l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start) {\n      start = 0\n    }\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = typeof end !== 'number' ? this.length : end\n\n  if (start < 0) {\n    start += this.length\n  }\n\n  if (end < 0) {\n    end += this.length\n  }\n\n  if (start === end) {\n    return this._new()\n  }\n\n  const startOffset = this._offset(start)\n  const endOffset = this._offset(end)\n  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] === 0) {\n    buffers.pop()\n  } else {\n    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])\n  }\n\n  if (startOffset[1] !== 0) {\n    buffers[0] = buffers[0].slice(startOffset[1])\n  }\n\n  return this._new(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n\n  return this\n}\n\nBufferList.prototype.duplicate = function duplicate () {\n  const copy = this._new()\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    copy.append(this._bufs[i])\n  }\n\n  return copy\n}\n\nBufferList.prototype.append = function append (buf) {\n  if (buf == null) {\n    return this\n  }\n\n  if (buf.buffer) {\n    // append a view of the underlying ArrayBuffer\n    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))\n  } else if (Array.isArray(buf)) {\n    for (let i = 0; i < buf.length; i++) {\n      this.append(buf[i])\n    }\n  } else if (this._isBufferList(buf)) {\n    // unwrap argument into individual BufferLists\n    for (let i = 0; i < buf._bufs.length; i++) {\n      this.append(buf._bufs[i])\n    }\n  } else {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf === 'number') {\n      buf = buf.toString()\n    }\n\n    this._appendBuffer(Buffer.from(buf))\n  }\n\n  return this\n}\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype.indexOf = function (search, offset, encoding) {\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n  }\n\n  if (typeof search === 'function' || Array.isArray(search)) {\n    throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.')\n  } else if (typeof search === 'number') {\n    search = Buffer.from([search])\n  } else if (typeof search === 'string') {\n    search = Buffer.from(search, encoding)\n  } else if (this._isBufferList(search)) {\n    search = search.slice()\n  } else if (Array.isArray(search.buffer)) {\n    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)\n  } else if (!Buffer.isBuffer(search)) {\n    search = Buffer.from(search)\n  }\n\n  offset = Number(offset || 0)\n\n  if (isNaN(offset)) {\n    offset = 0\n  }\n\n  if (offset < 0) {\n    offset = this.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0\n  }\n\n  if (search.length === 0) {\n    return offset > this.length ? this.length : offset\n  }\n\n  const blOffset = this._offset(offset)\n  let blIndex = blOffset[0] // index of which internal buffer we're working on\n  let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n\n  // scan over each buffer\n  for (; blIndex < this._bufs.length; blIndex++) {\n    const buff = this._bufs[blIndex]\n\n    while (buffOffset < buff.length) {\n      const availableWindow = buff.length - buffOffset\n\n      if (availableWindow >= search.length) {\n        const nativeSearchResult = buff.indexOf(search, buffOffset)\n\n        if (nativeSearchResult !== -1) {\n          return this._reverseOffset([blIndex, nativeSearchResult])\n        }\n\n        buffOffset = buff.length - search.length + 1 // end of native search window\n      } else {\n        const revOffset = this._reverseOffset([blIndex, buffOffset])\n\n        if (this._match(revOffset, search)) {\n          return revOffset\n        }\n\n        buffOffset++\n      }\n    }\n\n    buffOffset = 0\n  }\n\n  return -1\n}\n\nBufferList.prototype._match = function (offset, search) {\n  if (this.length - offset < search.length) {\n    return false\n  }\n\n  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n    if (this.get(offset + searchOffset) !== search[searchOffset]) {\n      return false\n    }\n  }\n  return true\n}\n\n;(function () {\n  const methods = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  }\n\n  for (const m in methods) {\n    (function (m) {\n      if (methods[m] === null) {\n        BufferList.prototype[m] = function (offset, byteLength) {\n          return this.slice(offset, offset + byteLength)[m](0, byteLength)\n        }\n      } else {\n        BufferList.prototype[m] = function (offset = 0) {\n          return this.slice(offset, offset + methods[m])[m](0)\n        }\n      }\n    }(m))\n  }\n}())\n\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferList || BufferList.isBufferList(b)\n}\n\nBufferList.isBufferList = function isBufferList (b) {\n  return b != null && b[symbol]\n}\n\nmodule.exports = BufferList\n","'use strict'\n\nconst DuplexStream = require('readable-stream').Duplex\nconst inherits = require('inherits')\nconst BufferList = require('./BufferList')\n\nfunction BufferListStream (callback) {\n  if (!(this instanceof BufferListStream)) {\n    return new BufferListStream(callback)\n  }\n\n  if (typeof callback === 'function') {\n    this._callback = callback\n\n    const piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n\n    callback = null\n  }\n\n  BufferList._init.call(this, callback)\n  DuplexStream.call(this)\n}\n\ninherits(BufferListStream, DuplexStream)\nObject.assign(BufferListStream.prototype, BufferList.prototype)\n\nBufferListStream.prototype._new = function _new (callback) {\n  return new BufferListStream(callback)\n}\n\nBufferListStream.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback === 'function') {\n    callback()\n  }\n}\n\nBufferListStream.prototype._read = function _read (size) {\n  if (!this.length) {\n    return this.push(null)\n  }\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferListStream.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferListStream.prototype._destroy = function _destroy (err, cb) {\n  this._bufs.length = 0\n  this.length = 0\n  cb(err)\n}\n\nBufferListStream.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)\n}\n\nBufferListStream.isBufferList = BufferList.isBufferList\n\nmodule.exports = BufferListStream\nmodule.exports.BufferListStream = BufferListStream\nmodule.exports.BufferList = BufferList\n","'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","//Based on follow-redirects v0.0.x\n\nvar nativeHttps = require('https'),\n  nativeHttp = require('http'),\n  url = require('url'),\n  utils = require('./utils');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\n\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n};\n\nfor (var protocol in protocols) {\n  var h = function() {};\n  h.prototype = protocols[protocol];\n  h = new h();\n\n  h.request = function(h) {\n    return function(options, callback, redirectOptions) {\n\n      redirectOptions = redirectOptions || {};\n\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = utils.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions);\n\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n\n      var reqUrl;\n      if (typeof options === 'string') {\n        reqUrl = options;\n      } else {\n        reqUrl = url.format(utils.extend({\n          protocol: protocol\n        }, options));\n      }\n\n      var clientRequest = Object.getPrototypeOf(h).request(options, redirectCallback(reqUrl, redirect));\n\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n\n      function redirectCallback(reqUrl, redirect) {\n        return function(res) {\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            return redirect.userCallback(res);\n          }\n\n          if (!('location' in res.headers)) {\n            return redirect.userCallback(res);\n          }\n\n          var redirectUrl = url.resolve(reqUrl, res.headers.location);\n\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1);\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    };\n  }(h);\n\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n  h.get = function(h) {\n    return function(options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n\n  module.exports[protocol] = h;\n}\n","module.exports = HttpDuplex;\n\nvar util = require('util'),\n  stream = require('readable-stream');\n\nutil.inherits(HttpDuplex, stream.Duplex);\n\nfunction HttpDuplex(req, res, options) {\n  var self = this;\n\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res, options);\n\n  stream.Duplex.call(self, options);\n  self._output = null;\n\n  self.connect(req, res);\n}\n\nHttpDuplex.prototype.connect = function(req, res) {\n  var self = this;\n  self.req = req;\n  self._output = res;\n  self.emit('response', res);\n\n  res.on('data', function(c) {\n    if (!self.push(c)) self._output.pause();\n  });\n  res.on('end', function() {\n    self.push(null);\n  });\n};\n\nHttpDuplex.prototype._read = function(n) {\n  if (this._output) this._output.resume();\n};\n\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {\n  this.req.write(chunk, encoding);\n  cb();\n};\n\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {\n  this._output.socket.destroy();\n  return this.req.end(chunk, encoding, cb);\n};\n\nHttpDuplex.prototype.destroy = function() {\n  this.req.destroy();\n  this._output.socket.destroy();\n};\n","var querystring = require('querystring'),\n  http = require('./http'),\n  fs = require('fs'),\n  path = require('path'),\n  url = require('url'),\n  ssh = require('./ssh'),\n  HttpDuplex = require('./http_duplex'),\n  debug = require('debug')('modem'),\n  utils = require('./utils'),\n  util = require('util'),\n  url = require('url'),\n  splitca = require('split-ca'),\n  isWin = require('os').type() === 'Windows_NT';\n\nvar defaultOpts = function () {\n  var host;\n  var opts = {};\n\n  if (!process.env.DOCKER_HOST) {\n    // Windows socket path: //./pipe/docker_engine ( Windows 10 )\n    // Linux & Darwin socket path: /var/run/docker.sock\n    opts.socketPath = isWin ? '//./pipe/docker_engine' : '/var/run/docker.sock';\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {\n    // Strip off unix://, fall back to default of /var/run/docker.sock if\n    // unix:// was passed without a path\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';\n  } else if (process.env.DOCKER_HOST.indexOf('npipe://') === 0) {\n    // Strip off npipe://, fall back to default of //./pipe/docker_engine if\n    // npipe:// was passed without a path\n    opts.socketPath = process.env.DOCKER_HOST.substring(8) || '//./pipe/docker_engine';\n  } else {\n    var hostStr = process.env.DOCKER_HOST;\n    if (hostStr.indexOf('\\/\\/') < 0) {\n      hostStr = 'tcp://' + hostStr;\n    }\n    try {\n      host = new url.URL(hostStr);\n    } catch (err) {\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');\n    }\n\n    opts.port = host.port;\n\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {\n      opts.protocol = 'https';\n    } else if (host.protocol === 'ssh:') {\n      opts.protocol = 'ssh';\n      opts.username = host.username;\n      opts.sshOptions = {\n        agent: process.env.SSH_AUTH_SOCK,\n      }\n    } else {\n      opts.protocol = 'http';\n    }\n\n    opts.host = host.hostname;\n\n    if (process.env.DOCKER_CERT_PATH) {\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));\n    }\n\n    if (process.env.DOCKER_CLIENT_TIMEOUT) {\n      opts.timeout = parseInt(process.env.DOCKER_CLIENT_TIMEOUT, 10);\n    }\n  }\n\n  return opts;\n};\n\n\nvar Modem = function (options) {\n  var optDefaults = defaultOpts();\n  var opts = Object.assign({}, optDefaults, options);\n\n  this.host = opts.host;\n\n  if(!this.host) {\n    this.socketPath = opts.socketPath;\n  }\n\n  this.port = opts.port;\n  this.username = opts.username;\n  this.password = opts.password;\n  this.version = opts.version;\n  this.key = opts.key;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.timeout = opts.timeout;\n  this.connectionTimeout = opts.connectionTimeout;\n  this.checkServerIdentity = opts.checkServerIdentity;\n  this.agent = opts.agent;\n  this.headers = opts.headers || {};\n  this.sshOptions = Object.assign({}, options ? options.sshOptions : {}, optDefaults.sshOptions);\n  //retrocompabitlity\n  if(this.sshOptions.agentForward === undefined) {\n    this.sshOptions.agentForward = opts.agentForward;\n  }\n\n  if (this.key && this.cert && this.ca) {\n    this.protocol = 'https';\n  }\n  this.protocol = opts.protocol || this.protocol || 'http';\n};\n\nModem.prototype.dial = function (options, callback) {\n  var opts, address, data;\n  var self = this;\n\n  if (options.options) {\n    opts = options.options;\n  }\n\n  // Prevent credentials from showing up in URL\n  if (opts && opts.authconfig) {\n    delete opts.authconfig;\n  }\n\n  if (this.version) {\n    options.path = '/' + this.version + options.path;\n  }\n\n  if (this.host) {\n    var parsed = url.parse(self.host);\n    address = url.format({\n      'protocol': parsed.protocol || self.protocol,\n      'hostname': parsed.hostname || self.host,\n      'port': self.port\n    });\n    address = url.resolve(address, options.path);\n  } else {\n    address = options.path;\n  }\n\n  if (options.path.indexOf('?') !== -1) {\n    if (opts && Object.keys(opts).length > 0) {\n      address += this.buildQuerystring(opts._query || opts);\n    } else {\n      address = address.substring(0, address.length - 1);\n    }\n  }\n\n  var optionsf = {\n    path: address,\n    method: options.method,\n    headers: options.headers || Object.assign({}, self.headers),\n    key: self.key,\n    cert: self.cert,\n    ca: self.ca\n  };\n\n  if (this.checkServerIdentity) {\n    optionsf.checkServerIdentity = this.checkServerIdentity;\n  }\n\n  if (this.agent) {\n    optionsf.agent = this.agent;\n  }\n\n  if (options.authconfig) {\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||\n      Buffer.from(JSON.stringify(options.authconfig)).toString('base64');\n  }\n\n  if (options.registryconfig) {\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||\n      Buffer.from(JSON.stringify(options.registryconfig)).toString('base64');\n  }\n\n  if (options.file) {\n    if (typeof options.file === 'string') {\n      data = fs.createReadStream(path.resolve(options.file));\n    } else {\n      data = options.file;\n    }\n    optionsf.headers['Content-Type'] = 'application/tar';\n  } else if (opts && options.method === 'POST') {\n    data = JSON.stringify(opts._body || opts);\n    if (options.allowEmpty) {\n      optionsf.headers['Content-Type'] = 'application/json';\n    } else {\n      if (data !== '{}' && data !== '\"\"') {\n        optionsf.headers['Content-Type'] = 'application/json';\n      } else {\n        data = undefined;\n      }\n    }\n  }\n\n  if (typeof data === 'string') {\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);\n  } else if (Buffer.isBuffer(data) === true) {\n    optionsf.headers['Content-Length'] = data.length;\n  } else if (optionsf.method === 'PUT' || options.hijack || options.openStdin) {\n    optionsf.headers['Transfer-Encoding'] = 'chunked';\n  }\n\n  if (options.hijack) {\n    optionsf.headers.Connection = 'Upgrade';\n    optionsf.headers.Upgrade = 'tcp';\n  }\n\n  if (this.socketPath) {\n    optionsf.socketPath = this.socketPath;\n  } else {\n    var urlp = url.parse(address);\n    optionsf.hostname = urlp.hostname;\n    optionsf.port = urlp.port;\n    optionsf.path = urlp.path;\n  }\n\n  this.buildRequest(optionsf, options, data, callback);\n};\n\nModem.prototype.buildRequest = function (options, context, data, callback) {\n  var self = this;\n  var connectionTimeoutTimer;\n\n  var opts = self.protocol === 'ssh' ? Object.assign(options, {\n    agent: ssh(Object.assign({}, self.sshOptions, {\n      'host': self.host,\n      'port': self.port,\n      'username': self.username,\n      'password': self.password,\n    })),\n    protocol: 'http:',\n  }) : options;\n\n  var req = http[self.protocol === 'ssh' ? 'http' : self.protocol].request(opts, function () { });\n\n  debug('Sending: %s', util.inspect(options, {\n    showHidden: true,\n    depth: null\n  }));\n\n  if (self.connectionTimeout) {\n    connectionTimeoutTimer = setTimeout(function () {\n      debug('Connection Timeout of %s ms exceeded', self.connectionTimeout);\n      req.abort();\n    }, self.connectionTimeout);\n  }\n\n  if (self.timeout) {\n    req.on('socket', function (socket) {\n      socket.setTimeout(self.timeout);\n      socket.on('timeout', function () {\n        debug('Timeout of %s ms exceeded', self.timeout);\n        req.abort();\n      });\n    });\n  }\n\n  if (context.hijack === true) {\n    clearTimeout(connectionTimeoutTimer);\n    req.on('upgrade', function (res, sock, head) {\n      return callback(null, sock);\n    });\n  }\n\n  req.on('connect', function () {\n    clearTimeout(connectionTimeoutTimer);\n  });\n\n  req.on('disconnect', function () {\n    clearTimeout(connectionTimeoutTimer);\n  });\n\n  req.on('response', function (res) {\n    clearTimeout(connectionTimeoutTimer);\n    if (context.isStream === true) {\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);\n    } else {\n      var chunks = [];\n      res.on('data', function (chunk) {\n        chunks.push(chunk);\n      });\n\n      res.on('end', function () {\n        var buffer = Buffer.concat(chunks);\n        var result = buffer.toString();\n\n        debug('Received: %s', result);\n\n        var json = utils.parseJSON(result) || buffer;\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);\n      });\n    }\n  });\n\n  req.on('error', function (error) {\n    clearTimeout(connectionTimeoutTimer);\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);\n  });\n\n  if (typeof data === 'string' || Buffer.isBuffer(data)) {\n    req.write(data);\n  } else if (data) {\n    data.on('error', function (error) {\n      req.destroy(error);\n    });\n    data.pipe(req);\n  }\n\n  if (!context.hijack && !context.openStdin && (typeof data === 'string' || data === undefined || Buffer.isBuffer(data))) {\n    req.end();\n  }\n};\n\nModem.prototype.buildPayload = function (err, isStream, statusCodes, openStdin, req, res, json, cb) {\n  if (err) return cb(err, null);\n\n  if (statusCodes[res.statusCode] !== true) {\n    getCause(isStream, res, json, function (err, cause) {\n      var msg = new Error(\n        '(HTTP code ' + res.statusCode + ') ' +\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +\n        (cause.message || cause) + ' '\n      );\n      msg.reason = statusCodes[res.statusCode];\n      msg.statusCode = res.statusCode;\n      msg.json = json;\n      cb(msg, null);\n    });\n  } else {\n    if (openStdin) {\n      cb(null, new HttpDuplex(req, res));\n    } else if (isStream) {\n      cb(null, res);\n    } else {\n      cb(null, json);\n    }\n  }\n\n  function getCause(isStream, res, json, callback) {\n    var chunks = '';\n    if (isStream) {\n      res.on('data', function (chunk) {\n        chunks += chunk;\n      });\n      res.on('end', function () {\n        callback(null, utils.parseJSON(chunks) || chunks);\n      });\n    } else {\n      callback(null, json);\n    }\n  }\n};\n\nModem.prototype.demuxStream = function (stream, stdout, stderr) {\n  var nextDataType = null;\n  var nextDataLength = null;\n  var buffer = Buffer.from('');\n  function processData(data) {\n    if (data) {\n      buffer = Buffer.concat([buffer, data]);\n    }\n    if (!nextDataType) {\n      if (buffer.length >= 8) {\n        var header = bufferSlice(8);\n        nextDataType = header.readUInt8(0);\n        nextDataLength = header.readUInt32BE(4);\n        // It's possible we got a \"data\" that contains multiple messages\n        // Process the next one\n        processData();\n      }\n    } else {\n      if (buffer.length >= nextDataLength) {\n        var content = bufferSlice(nextDataLength);\n        if (nextDataType === 1) {\n          stdout.write(content);\n        } else {\n          stderr.write(content);\n        }\n        nextDataType = null;\n        // It's possible we got a \"data\" that contains multiple messages\n        // Process the next one\n        processData();\n      }\n    }\n  }\n\n  function bufferSlice(end) {\n    var out = buffer.slice(0, end);\n    buffer = Buffer.from(buffer.slice(end, buffer.length));\n    return out;\n  }\n\n  stream.on('data', processData);\n};\n\nModem.prototype.followProgress = function (stream, onFinished, onProgress) {\n  var buf = '';\n  var output = [];\n  var finished = false;\n\n  stream.on('data', onStreamEvent);\n  stream.on('error', onStreamError);\n  stream.on('end', onStreamEnd);\n  stream.on('close', onStreamEnd);\n\n  function onStreamEvent(data) {\n    buf += data.toString();\n    pump();\n\n    function pump() {\n      var pos;\n      while ((pos = buf.indexOf('\\n')) >= 0) {\n        if (pos == 0) {\n          buf = buf.slice(1);\n          continue;\n        }\n        processLine(buf.slice(0, pos));\n        buf = buf.slice(pos + 1);\n      }\n    }\n\n    function processLine(line) {\n      if (line[line.length - 1] == '\\r') line = line.substr(0, line.length - 1);\n      if (line.length > 0) {\n        var obj = JSON.parse(line);\n        output.push(obj);\n        if (onProgress) {\n          onProgress(obj);\n        }\n      }\n    }\n  };\n\n  function onStreamError(err) {\n    finished = true;\n    stream.removeListener('data', onStreamEvent);\n    stream.removeListener('error', onStreamError);\n    stream.removeListener('end', onStreamEnd);\n    stream.removeListener('close', onStreamEnd);\n    onFinished(err, output);\n  }\n\n  function onStreamEnd() {\n    if(!finished) onFinished(null, output);\n    finished = true;\n  }\n};\n\nModem.prototype.buildQuerystring = function (opts) {\n  var clone = {};\n\n  // serialize map values as JSON strings, else querystring truncates.\n  Object.keys(opts).map(function (key, i) {\n    clone[key] = opts[key] && typeof opts[key] === 'object' && key !== 't' ?\n      JSON.stringify(opts[key]) : opts[key];\n  });\n\n  return querystring.stringify(clone);\n};\n\nmodule.exports = Modem;\n","var Client = require('ssh2').Client,\n  http = require('http');\n\nmodule.exports = function(opt) {\n  var conn = new Client();\n  var agent = new http.Agent();\n\n  agent.createConnection = function(options, fn) {\n    conn.once('ready', function() {\n      conn.exec('docker system dial-stdio', function(err, stream) {\n        if (err) {\n          conn.end();\n          agent.destroy();\n          return;\n        }\n\n        fn(null, stream);\n\n        stream.once('close', () => {\n          conn.end();\n          agent.destroy();\n        });\n      });\n    }).connect(opt);\n\n    conn.once('end', () => agent.destroy());\n  };\n\n  return agent;\n};\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.parseJSON = function(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n};\n","var util = require('./util');\n\n/**\n * Represents a config\n * @param {Object} modem docker-modem\n * @param {String} id  Config's id\n */\nvar Config = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nConfig.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nConfig.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/configs/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update a config.\n *\n * @param {object} opts\n * @param {function} callback\n */\nConfig.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/configs/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Removes the config\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nConfig.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/configs/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Config;\n","var extend = require('./util').extend,\n  Exec = require('./exec'),\n  util = require('./util');\n\n/**\n * Represents a Container\n * @param {Object} modem docker-modem\n * @param {String} id    Container's ID\n */\nvar Container = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n\n  this.defaultOptions = {\n    top: {},\n    start: {},\n    commit: {},\n    stop: {},\n    pause: {},\n    unpause: {},\n    restart: {},\n    resize: {},\n    attach: {},\n    remove: {},\n    copy: {},\n    kill: {},\n    exec: {},\n    rename: {},\n    log: {},\n    stats: {},\n    getArchive: {},\n    infoArchive: {},\n    putArchive: {},\n    update: {},\n    wait: {}\n  };\n};\n\nContainer.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Object}   opts     Options (optional)\n * @param  {Function} callback Callback, if supplied will query Docker.\n * @return {Object}            ID only and only if callback isn't supplied.\n */\nContainer.prototype.inspect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Rename\n * @param  {Object}   opts     Rename options\n * @param  {Function} callback Callback\n */\nContainer.prototype.rename = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/rename?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Update\n * @param  {Object}   opts     Update options\n * @param  {Function} callback Callback\n */\nContainer.prototype.update = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/update',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Top\n * @param  {Object}   opts like 'ps_args' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.top = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/top?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Containers changes\n * @param  {Function} callback Callback\n */\nContainer.prototype.changes = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/' + this.id + '/changes',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Checkpoints list\n * @param  {Object}   opts     List checkpoints options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.listCheckpoint = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Delete checkpoint\n * @param  {Object}   opts     Delete checkpoint options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.deleteCheckpoint = function(checkpoint, opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints/' + checkpoint + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Create checkpoint\n * @param  {Object}   opts     Create checkpoint options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.createCheckpoint = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints',\n    method: 'POST',\n    allowEmpty: true,\n    statusCodes: {\n      200: true, //unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Export\n * @param  {Function} callback Callback with the octet-stream.\n */\nContainer.prototype.export = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/' + this.id + '/export',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Start\n * @param  {Object}   opts     Container start options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.start = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/start?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      304: 'container already started',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Pause\n * @param  {Object}   opts     Pause options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.pause = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/pause',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Unpause\n * @param  {Object}   opts     Unpause options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.unpause = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/unpause',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Setup an exec call to a running container\n *\n * @param {object} opts\n * @param {function} callback\n */\nContainer.prototype.exec = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/exec',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      409: 'container stopped/paused',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(new Exec(self.modem, data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, new Exec(self.modem, data.Id));\n    });\n  }\n};\n\n/**\n * Commit\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.commit = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);\n\n  args.opts.container = this.id;\n\n  var optsf = {\n    path: '/commit?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Stop\n * @param  {Object}   opts     Container stop options, like 't' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.stop = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/stop?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      304: 'container already stopped',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Restart\n * @param  {Object}   opts     Container restart options, like 't' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.restart = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/restart?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Kill\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.kill = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/kill?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container resize\n * @param  {[type]}   opts     Resize options. (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.resize = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/resize?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Attach\n * @param  {Object}   opts     Attach options, like 'logs' (optional)\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.attach = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/attach?',\n    method: 'POST',\n    isStream: true,\n    hijack: args.opts.hijack,\n    openStdin: args.opts.stdin,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, stream) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(stream);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, stream) {\n      args.callback(err, stream);\n    });\n  }\n};\n\n/**\n * Waits for a container to end.\n * @param  {[type]}   opts     Container wait options, like condition. (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.wait = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.wait);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/wait?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes a container\n * @param  {Object}   opts     Remove options, like 'force' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);\n\n  var optsf = {\n    path: '/containers/' + this.id + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Copy (WARNING: DEPRECATED since RAPI v1.20)\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.copy = function(opts, callback) {\n  var self = this;\n  console.log('container.copy is deprecated since Docker v1.8.x');\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/copy',\n    method: 'POST',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * getArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.getArchive = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * infoArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.infoArchive = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'HEAD',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * putArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.putArchive = function(file, opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'PUT',\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      403: 'client error, permission denied',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nContainer.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container stats\n * @param  {Object}   opts     Stats options. (optional)\n * @param  {Function} callback Callback with data\n */\nContainer.prototype.stats = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);\n  var isStream = true;\n  if (args.opts.stream === false) {\n    isStream = false;\n  }\n  var optsf = {\n    path: '/containers/' + this.id + '/stats?',\n    method: 'GET',\n    isStream: isStream,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Container;\n","var EventEmitter = require('events').EventEmitter,\n  Modem = require('docker-modem'),\n  tar = require('tar-fs'),\n  zlib = require('zlib'),\n  Container = require('./container'),\n  Image = require('./image'),\n  Volume = require('./volume'),\n  Network = require('./network'),\n  Service = require('./service'),\n  Plugin = require('./plugin'),\n  Secret = require('./secret'),\n  Config = require('./config'),\n  Task = require('./task'),\n  Node = require('./node'),\n  Exec = require('./exec'),\n  util = require('./util'),\n  extend = util.extend;\n\nvar Docker = function(opts) {\n  if (!(this instanceof Docker)) return new Docker(opts);\n\n  var plibrary = global.Promise;\n\n  if (opts && opts.Promise) {\n    plibrary = opts.Promise;\n\n    if (Object.keys(opts).length === 1) {\n      opts = undefined;\n    }\n  }\n\n  this.modem = new Modem(opts);\n  this.modem.Promise = plibrary;\n};\n\n/**\n * Creates a new container\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createContainer = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/create?',\n    method: 'POST',\n    options: opts,\n    authconfig: opts.authconfig,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      406: 'impossible to attach',\n      500: 'server error'\n    }\n  };\n\n  delete opts.authconfig;\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getContainer(data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, self.getContainer(data.Id));\n    });\n  }\n};\n\n/**\n * Creates a new image\n * @param {Object}   auth     Authentication (optional)\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createImage = function(auth, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  } else if (!callback && !opts) {\n    opts = auth;\n    auth = opts.authconfig;\n  }\n\n  var optsf = {\n    path: '/images/create?',\n    method: 'POST',\n    options: opts,\n    authconfig: auth,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Load image\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.loadImage = function(file, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  var optsf = {\n    path: '/images/load?',\n    method: 'POST',\n    options: opts,\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Import image from a tar archive\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.importImage = function(file, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = undefined;\n  }\n  \n  if (!opts)\n    opts = {};\n\n  opts.fromSrc = '-';\n\n  var optsf = {\n    path: '/images/create?',\n    method: 'POST',\n    options: opts,\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Verifies auth\n * @param {Object}   opts     Options\n * @param {Function} callback Callback\n */\nDocker.prototype.checkAuth = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/auth',\n    method: 'POST',\n    options: opts,\n    statusCodes: {\n      200: true,\n      204: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Builds an image\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.buildImage = function(file, opts, callback) {\n  var self = this;\n  var content;\n\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  function build(file) {\n    var optsf = {\n      path: '/build?',\n      method: 'POST',\n      file: file,\n      options: opts,\n      isStream: true,\n      statusCodes: {\n        200: true,\n        500: 'server error'\n      }\n    };\n\n    if (opts) {\n      if (opts.registryconfig) {\n        optsf.registryconfig = optsf.options.registryconfig;\n        delete optsf.options.registryconfig;\n      }\n\n      //undocumented?\n      if (opts.authconfig) {\n        optsf.authconfig = optsf.options.authconfig;\n        delete optsf.options.authconfig;\n      }\n    }\n\n    if (callback === undefined) {\n      return new self.modem.Promise(function(resolve, reject) {\n        self.modem.dial(optsf, function(err, data) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(data);\n        });\n      });\n    } else {\n      self.modem.dial(optsf, function(err, data) {\n        callback(err, data);\n      });\n    }\n  }\n\n  if (file && file.context) {\n    var pack = tar.pack(file.context, {\n      entries: file.src\n    });\n    return build(pack.pipe(zlib.createGzip()));\n  } else {\n    return build(file);\n  }\n};\n\n/**\n * Fetches a Container by ID\n * @param {String} id Container's ID\n */\nDocker.prototype.getContainer = function(id) {\n  return new Container(this.modem, id);\n};\n\n/**\n * Fetches an Image by name\n * @param {String} name Image's name\n */\nDocker.prototype.getImage = function(name) {\n  return new Image(this.modem, name);\n};\n\n/**\n * Fetches a Volume by name\n * @param {String} name Volume's name\n */\nDocker.prototype.getVolume = function(name) {\n  return new Volume(this.modem, name);\n};\n\n/**\n * Fetches a Plugin by name\n * @param {String} name Volume's name\n */\nDocker.prototype.getPlugin = function(name, remote) {\n  return new Plugin(this.modem, name, remote);\n};\n\n/**\n * Fetches a Service by id\n * @param {String} id Services's id\n */\nDocker.prototype.getService = function(id) {\n  return new Service(this.modem, id);\n};\n\n/**\n * Fetches a Task by id\n * @param {String} id Task's id\n */\nDocker.prototype.getTask = function(id) {\n  return new Task(this.modem, id);\n};\n\n/**\n * Fetches Node by id\n * @param {String} id Node's id\n */\nDocker.prototype.getNode = function(id) {\n  return new Node(this.modem, id);\n};\n\n/**\n * Fetches a Network by id\n * @param {String} id network's id\n */\nDocker.prototype.getNetwork = function(id) {\n  return new Network(this.modem, id);\n};\n\n/**\n * Fetches a Secret by id\n * @param {String} id network's id\n */\nDocker.prototype.getSecret = function(id) {\n  return new Secret(this.modem, id);\n};\n\n/**\n * Fetches a Config by id\n * @param {String} id network's id\n */\nDocker.prototype.getConfig = function(id) {\n  return new Config(this.modem, id);\n};\n\n/**\n * Fetches an Exec instance by ID\n * @param {String} id Exec instance's ID\n */\nDocker.prototype.getExec = function(id) {\n  return new Exec(this.modem, id);\n};\n\n/**\n * Lists containers\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listContainers = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Get images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.getImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/get?',\n    method: 'GET',\n    options: args.opts,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Services\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listServices = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/services?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Nodes\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listNodes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/nodes?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such node',\n      500: 'server error',\n      503: 'node is not part of a swarm',\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Tasks\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listTasks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/tasks?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new secret\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createSecret = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n  var optsf = {\n    path: '/secrets/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      406: 'server error or node is not part of a swarm',\n      409: 'name conflicts with an existing object',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getSecret(data.ID));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getSecret(data.ID));\n    });\n  }\n};\n\n\n/**\n * Creates a new config\n * @param {Object}   opts     Config options\n * @param {Function} callback Callback\n */\nDocker.prototype.createConfig = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n  var optsf = {\n    path: '/configs/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      406: 'server error or node is not part of a swarm',\n      409: 'name conflicts with an existing object',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getConfig(data.ID));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getConfig(data.ID));\n    });\n  }\n};\n\n\n/**\n * Lists secrets\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listSecrets = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/secrets?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists configs\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listConfigs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/configs?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new plugin\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createPlugin = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/plugins/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getPlugin(args.opts.name));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getPlugin(args.opts.name));\n    });\n  }\n};\n\n\n/**\n * Lists plugins\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listPlugins = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune builder\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneBuilder = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/build/prune',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune containers\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneContainers = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune volumes\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneVolumes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune networks\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneNetworks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Creates a new volume\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createVolume = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/volumes/create?',\n    method: 'POST',\n    allowEmpty: true,\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getVolume(data.Name));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getVolume(data.Name));\n    });\n  }\n};\n\n/**\n * Creates a new service\n * @param {Object}   auth\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createService = function(auth, opts, callback) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  } else if (!opts && !callback) {\n    opts = auth;\n  }\n\n\n  var self = this;\n  var optsf = {\n    path: '/services/create',\n    method: 'POST',\n    options: opts,\n    authconfig: auth,\n    statusCodes: {\n      200: true,\n      201: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getService(data.ID || data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, self.getService(data.ID || data.Id));\n    });\n  }\n};\n\n/**\n * Lists volumes\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listVolumes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new network\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createNetwork = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/networks/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'driver not found',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getNetwork(data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getNetwork(data.Id));\n    });\n  }\n};\n\n/**\n * Lists networks\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listNetworks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Search images\n * @param {Object}   opts     Options\n * @param {Function} callback Callback\n */\nDocker.prototype.searchImages = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/images/search?',\n    method: 'GET',\n    options: opts,\n    authconfig: opts.authconfig,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Info\n * @param  {Function} callback Callback with info\n */\nDocker.prototype.info = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/info',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Version\n * @param  {Function} callback Callback\n */\nDocker.prototype.version = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/version',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Ping\n * @param  {Function} callback Callback\n */\nDocker.prototype.ping = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/_ping',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * SystemDf \tequivalent to system/df API Engine\n *\t\tget usage data information\n * @param  {Function} callback Callback\n */\nDocker.prototype.df = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/system/df',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Events\n * @param {Object}   opts     Events options, like 'since' (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.getEvents = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/events?',\n    method: 'GET',\n    options: args.opts,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Pull is a wrapper around createImage, parsing image's tags.\n * @param  {String}   repoTag  Repository tag\n * @param  {Object}   opts     Options (optional)\n * @param  {Function} callback Callback\n * @param  {Object}   auth     Authentication (optional)\n * @return {Object}            Image\n */\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {\n  var args = util.processArgs(opts, callback);\n\n  var imageSrc = util.parseRepositoryTag(repoTag);\n  args.opts.fromImage = imageSrc.repository;\n  args.opts.tag = imageSrc.tag || 'latest';\n\n  var argsf = [args.opts, args.callback];\n  if (auth) {\n    argsf = [auth, args.opts, args.callback];\n  }\n  return this.createImage.apply(this, argsf);\n};\n\n/**\n * Like run command from Docker's CLI\n * @param  {String}   image         Image name to be used.\n * @param  {Array}   cmd           Command to run in array format.\n * @param  {Object}   streamo       Output stream\n * @param  {Object}   createOptions Container create options (optional)\n * @param  {Object}   startOptions  Container start options (optional)\n * @param  {Function} callback      Callback\n * @return {Object}                 EventEmitter\n */\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {\n  if (typeof arguments[arguments.length - 1] === 'function') {\n    return this.runCallback(image, cmd, streamo, createOptions, startOptions, callback);\n  } else {\n    return this.runPromise(image, cmd, streamo, createOptions, startOptions);\n  }\n};\n\n\nDocker.prototype.runCallback = function(image, cmd, streamo, createOptions, startOptions, callback) {\n  if (!callback && typeof createOptions === 'function') {\n    callback = createOptions;\n    createOptions = {};\n    startOptions = {};\n  } else if (!callback && typeof startOptions === 'function') {\n    callback = startOptions;\n    startOptions = {};\n  }\n\n  var hub = new EventEmitter();\n\n  function handler(err, container) {\n    if (err) return callback(err, null, container);\n\n    hub.emit('container', container);\n\n    container.attach({\n      stream: true,\n      stdout: true,\n      stderr: true\n    }, function handler(err, stream) {\n      if (err) return callback(err, null, container);\n\n      hub.emit('stream', stream);\n\n      if (streamo) {\n        if (streamo instanceof Array) {\n          stream.on('end', function() {\n            try {\n              streamo[0].end();\n            } catch (e) {}\n            try {\n              streamo[1].end();\n            } catch (e) {}\n          });\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);\n        } else {\n          stream.setEncoding('utf8');\n          stream.pipe(streamo, {\n            end: true\n          });\n        }\n      }\n\n      container.start(startOptions, function(err, data) {\n        if (err) return callback(err, data, container);\n        hub.emit('start', container);\n\n        container.wait(function(err, data) {\n          hub.emit('data', data);\n          callback(err, data, container);\n        });\n      });\n    });\n  }\n\n  var optsc = {\n    'Hostname': '',\n    'User': '',\n    'AttachStdin': false,\n    'AttachStdout': true,\n    'AttachStderr': true,\n    'Tty': true,\n    'OpenStdin': false,\n    'StdinOnce': false,\n    'Env': null,\n    'Cmd': cmd,\n    'Image': image,\n    'Volumes': {},\n    'VolumesFrom': []\n  };\n\n  extend(optsc, createOptions);\n\n  this.createContainer(optsc, handler);\n\n  return hub;\n};\n\nDocker.prototype.runPromise = function(image, cmd, streamo, createOptions, startOptions) {\n  var self = this;\n\n  createOptions = createOptions || {};\n  startOptions = startOptions || {};\n\n  var optsc = {\n    'Hostname': '',\n    'User': '',\n    'AttachStdin': false,\n    'AttachStdout': true,\n    'AttachStderr': true,\n    'Tty': true,\n    'OpenStdin': false,\n    'StdinOnce': false,\n    'Env': null,\n    'Cmd': cmd,\n    'Image': image,\n    'Volumes': {},\n    'VolumesFrom': []\n  };\n\n  extend(optsc, createOptions);\n\n  var containero;\n\n  return new this.modem.Promise(function(resolve, reject) {\n    self.createContainer(optsc).then(function(container) {\n      containero = container;\n      return container.attach({\n        stream: true,\n        stdout: true,\n        stderr: true\n      });\n    }).then(function(stream) {\n      if (streamo) {\n        if (streamo instanceof Array) {\n          stream.on('end', function() {\n            try {\n              streamo[0].end();\n            } catch (e) {}\n            try {\n              streamo[1].end();\n            } catch (e) {}\n          });\n          containero.modem.demuxStream(stream, streamo[0], streamo[1]);\n        } else {\n          stream.setEncoding('utf8');\n          stream.pipe(streamo, {\n            end: true\n          });\n        }\n      }\n      return containero.start(startOptions);\n    }).then(function(data) {\n      return containero.wait();\n    }).then(function(data) {\n      resolve([data, containero]);\n    }).catch(function(err) {\n      reject(err);\n    });\n  });\n};\n\n/**\n * Init swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmInit = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/init',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Join swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmJoin = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/join',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Leave swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmLeave = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/leave?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      406: 'node is not part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Update swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmUpdate = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Inspect a Swarm.\n * Warning: This method is not documented in the API\n *\n * @param  {Function} callback Callback\n */\nDocker.prototype.swarmInspect = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/swarm',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      406: 'This node is not a swarm manager',\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\nDocker.Container = Container;\nDocker.Image = Image;\nDocker.Volume = Volume;\nDocker.Network = Network;\nDocker.Service = Service;\nDocker.Plugin = Plugin;\nDocker.Secret = Secret;\nDocker.Task = Task;\nDocker.Node = Node;\nDocker.Exec = Exec;\n\nmodule.exports = Docker;\n","var util = require('./util');\n\n/**\n * Represents an Exec\n * @param {Object} modem docker-modem\n * @param {String} id    Exec's ID\n */\nvar Exec = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nExec.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Start the exec call that was setup.\n *\n * @param {object} opts\n * @param {function} callback\n */\nExec.prototype.start = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/exec/' + this.id + '/start',\n    method: 'POST',\n    isStream: true,\n    allowEmpty: true,\n    hijack: args.opts.hijack,\n    openStdin: args.opts.stdin,\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such exec',\n      409: 'container stopped/paused',\n      500: 'container not running'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Resize the exec call that was setup.\n *\n * @param {object} opts\n * @param {function} callback\n */\nExec.prototype.resize = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/exec/' + this.id + '/resize?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such exec',\n      500: 'container not running'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Get low-level information about the exec call.\n *\n * @param {function} callback\n */\nExec.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/exec/' + this.id + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such exec',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Exec;\n","var util = require('./util');\n\n/**\n * Represents an image\n * @param {Object} modem docker-modem\n * @param {String} name  Image's name\n */\nvar Image = function(modem, name) {\n  this.modem = modem;\n  this.name = name;\n};\n\nImage.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nImage.prototype.inspect = function(callback) {\n  var self = this;\n\n  var opts = {\n    path: '/images/' + this.name + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Distribution\n * @param {Object} opts\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nImage.prototype.distribution = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n\n  var fopts = {\n    path: '/distribution/' + this.name + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      401: 'no such image',\n      500: 'server error'\n    },\n    authconfig: (args.opts) ? args.opts.authconfig : undefined\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(fopts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(fopts, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * History\n * @param  {Function} callback Callback\n */\nImage.prototype.history = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/images/' + this.name + '/history',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Get\n * @param  {Function} callback Callback with data stream.\n */\nImage.prototype.get = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/images/' + this.name + '/get',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Push\n * @param  {Object}   opts     Push options, like 'registry' (optional)\n * @param  {Function} callback Callback with stream.\n * @param  {Object}   auth     Registry authentication\n */\nImage.prototype.push = function(opts, callback, auth) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var isStream = true;\n  if (args.opts.stream === false) {\n    isStream = false;\n  }\n  var optsf = {\n    path: '/images/' + this.name + '/push?',\n    method: 'POST',\n    options: args.opts,\n    authconfig: args.opts.authconfig || auth,\n    isStream: isStream,\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  delete optsf.options.authconfig;\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Tag\n * @param  {Object}   opts     Tag options, like 'repo' (optional)\n * @param  {Function} callback Callback\n */\nImage.prototype.tag = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/images/' + this.name + '/tag?',\n    method: 'POST',\n    options: opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      400: 'bad parameter',\n      404: 'no such image',\n      409: 'conflict',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the image\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nImage.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n\n  var optsf = {\n    path: '/images/' + this.name + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Image;\n","var util = require('./util');\n\n/**\n * Represents an network\n * @param {Object} modem docker-modem\n * @param {String} id  Network's id\n */\nvar Network = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nNetwork.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Id only if callback isn't specified.\n */\nNetwork.prototype.inspect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var opts = {\n    path: '/networks/' + this.id + '?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such network',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the network\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such network',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Connects a container to a network\n * @param  {[Object]}   opts     Connect options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.connect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id + '/connect',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      201: true,\n      404: 'network or container is not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Disconnects a container from a network\n * @param  {[Object]}   opts     Disconnect options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.disconnect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id + '/disconnect',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      201: true,\n      404: 'network or container is not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\n\nmodule.exports = Network;\n","var util = require('./util');\n\n/**\n * Represents an Node\n * @param {Object} modem docker-modem\n * @param {String} id    Node's ID\n */\nvar Node = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nNode.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for Node details.\n *\n * @param {function} callback\n */\nNode.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/nodes/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Update a node.\n *\n * @param {object} opts\n * @param {function} callback\n */\nNode.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/nodes/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      406: 'node is not part of a swarm',\n      500: 'server error'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Remove a Node.\n * Warning: This method is not documented in the API.\n *\n * @param {object} opts\n * @param {function} callback\n */\nNode.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/nodes/' + this.id + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Node;\n","var util = require('./util');\n\n/**\n * Represents a plugin\n * @param {Object} modem docker-modem\n * @param {String} name  Plugin's name\n */\nvar Plugin = function(modem, name, remote) {\n  this.modem = modem;\n  this.name = name;\n  this.remote = remote || name;\n};\n\nPlugin.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nPlugin.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/plugins/' + this.name,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'plugin is not installed',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the plugin\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'plugin is not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * get privileges\n * @param  {Function} callback Callback\n * @return {Object}            Name only if callback isn't specified.\n */\nPlugin.prototype.privileges = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/plugins/privileges?',\n    method: 'GET',\n    options: {\n      'remote': this.remote\n    },\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Installs a new plugin\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nPlugin.prototype.pull = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  if(args.opts._query && !args.opts._query.name) {\n    args.opts._query.name = this.name;\n  }\n  if(args.opts._query && !args.opts._query.remote) {\n    args.opts._query.remote = this.remote;\n  }\n\n  var optsf = {\n    path: '/plugins/pull?',\n    method: 'POST',\n    isStream: true,\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    }\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Enable\n * @param  {Object}   opts     Plugin enable options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.enable = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/enable?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Disable\n * @param  {Object}   opts     Plugin disable options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.disable = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/disable',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Push\n * @param  {Object}   opts     Plugin push options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.push = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/push',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * COnfigure\n * @param  {Object}   opts     Plugin configure options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.configure = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/set',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Upgrade plugin\n *\n * @param {object} auth\n * @param {object} opts\n * @param {function} callback\n */\nPlugin.prototype.upgrade = function(auth, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  }\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/upgrade?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    authconfig: auth,\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Plugin;\n","var util = require('./util');\n\n/**\n * Represents a secret\n * @param {Object} modem docker-modem\n * @param {String} id  Secret's id\n */\nvar Secret = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nSecret.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nSecret.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/secrets/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'secret not found',\n      406: 'node is not part of a swarm',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update a secret.\n *\n * @param {object} opts\n * @param {function} callback\n */\nSecret.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/secrets/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'secret not found',\n      500: 'server error'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Removes the secret\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nSecret.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/secrets/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'secret not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Secret;\n","var util = require('./util');\n\n/**\n * Represents an Service\n * @param {Object} modem docker-modem\n * @param {String} id    Service's ID\n */\nvar Service = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nService.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for service details.\n *\n * @param {function} callback\n */\nService.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/services/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Delete Service\n *\n * @param {function} callback\n */\nService.prototype.remove = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/services/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such service',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update service\n *\n * @param {object} auth\n * @param {object} opts\n * @param {function} callback\n */\nService.prototype.update = function(auth, opts, callback) {\n  var self = this;\n  if (!callback) {\n    var t = typeof opts;\n    if(t === 'function'){\n      callback = opts;\n      opts = auth;\n      auth = opts.authconfig || undefined;\n    } else if (t === 'undefined'){\n      opts = auth;\n      auth = opts.authconfig || undefined;\n    }\n  }\n\n  var optsf = {\n    path: '/services/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error'\n    },\n    authconfig: auth,\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n\n/**\n * Service logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nService.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, {});\n\n  var optsf = {\n    path: '/services/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Service;\n","var util = require('./util');\n\n/**\n * Represents an Task\n * @param {Object} modem docker-modem\n * @param {String} id    Task's ID\n */\nvar Task = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n\n  this.defaultOptions = {\n    log: {}\n  };\n};\n\nTask.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for Task details.\n *\n * @param {function} callback\n */\nTask.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/tasks/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'unknown task',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Task logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nTask.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\n\n  var optsf = {\n    path: '/tasks/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      101: true,\n      200: true,\n      404: 'no such container',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Task;\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n  return {\n    callback: callback,\n    opts: module.exports.extend({}, defaultOpts, opts)\n  };\n};\n\n\n/**\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.\n * // if given the input http://localhost:8080/woot:latest\n * {\n *   repository: 'http://localhost:8080/woot',\n *   tag: 'latest'\n * }\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'\n * @return {Object} input parsed into the repo and tag.\n */\nmodule.exports.parseRepositoryTag = function(input) {\n  var separatorPos;\n  var digestPos = input.indexOf('@');\n  var colonPos = input.lastIndexOf(':');\n  // @ symbol is more important\n  if (digestPos >= 0) {\n    separatorPos = digestPos;\n  } else if (colonPos >= 0) {\n    separatorPos = colonPos;\n  } else {\n    // no colon nor @\n    return {\n      repository: input\n    };\n  }\n\n  // last colon is either the tag (or part of a port designation)\n  var tag = input.slice(separatorPos + 1);\n\n  // if it contains a / its not a tag and is part of the url\n  if (tag.indexOf('/') === -1) {\n    return {\n      repository: input.slice(0, separatorPos),\n      tag: tag\n    };\n  }\n\n  return {\n    repository: input\n  };\n};\n","var util = require('./util');\n\n/**\n * Represents a volume\n * @param {Object} modem docker-modem\n * @param {String} name  Volume's name\n */\nvar Volume = function(modem, name) {\n  this.modem = modem;\n  this.name = name;\n};\n\nVolume.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nVolume.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/volumes/' + this.name,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such volume',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the volume\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nVolume.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes/' + this.name,\n    method: 'DELETE',\n    statusCodes: {\n      204: true,\n      404: 'no such volume',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Volume;\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","module.exports = require('fs').constants || require('constants')\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","var once = require('once')\nvar eos = require('end-of-stream')\nvar fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n","'use strict';\n\nconst codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n\n  function getMessage (arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message\n    } else {\n      return message(arg1, arg2, arg3)\n    }\n  }\n\n  class NodeError extends Base {\n    constructor (arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n\treturn str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n\tif (this_len === undefined || this_len > str.length) {\n\t\tthis_len = str.length;\n\t}\n\treturn str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"'\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented'\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","'use strict';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;\n\nfunction from(Readable, iterable, opts) {\n  var iterator;\n\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts)); // Reading boolean to protect against _read\n  // being called before last iteration completion.\n\n  var reading = false;\n\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _ref = yield iterator.next(),\n            value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          readable.push(null);\n        } else if (readable.push((yield value))) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n\n  return readable;\n}\n\nmodule.exports = from;","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","module.exports = require('stream');\n","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n  exports.finished = require('./lib/internal/streams/end-of-stream.js');\n  exports.pipeline = require('./lib/internal/streams/pipeline.js');\n}\n","/* eslint-disable node/no-deprecated-api */\n\n'use strict'\n\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\nvar safer = {}\n\nvar key\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue\n  if (key === 'SlowBuffer' || key === 'Buffer') continue\n  safer[key] = buffer[key]\n}\n\nvar Safer = safer.Buffer = {}\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue\n  Safer[key] = Buffer[key]\n}\n\nsafer.Buffer.prototype = Buffer.prototype\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value)\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)\n    }\n    return Buffer(value, encodingOrOffset, length)\n  }\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size)\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n    var buf = Buffer(size)\n    if (!fill || fill.length === 0) {\n      buf.fill(0)\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n    return buf\n  }\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  }\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength\n  }\n}\n\nmodule.exports = safer\n","exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar t = exports.tokens = {}\nvar R = 0\n\nfunction tok (n) {\n  t[n] = R++\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ntok('NUMERICIDENTIFIER')\nsrc[t.NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\ntok('NUMERICIDENTIFIERLOOSE')\nsrc[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ntok('NONNUMERICIDENTIFIER')\nsrc[t.NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ntok('MAINVERSION')\nsrc[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[t.NUMERICIDENTIFIER] + ')'\n\ntok('MAINVERSIONLOOSE')\nsrc[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ntok('PRERELEASEIDENTIFIER')\nsrc[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +\n                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'\n\ntok('PRERELEASEIDENTIFIERLOOSE')\nsrc[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ntok('PRERELEASE')\nsrc[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'\n\ntok('PRERELEASELOOSE')\nsrc[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ntok('BUILDIDENTIFIER')\nsrc[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ntok('BUILD')\nsrc[t.BUILD] = '(?:\\\\+(' + src[t.BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[t.BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ntok('FULL')\ntok('FULLPLAIN')\nsrc[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +\n                  src[t.PRERELEASE] + '?' +\n                  src[t.BUILD] + '?'\n\nsrc[t.FULL] = '^' + src[t.FULLPLAIN] + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ntok('LOOSEPLAIN')\nsrc[t.LOOSEPLAIN] = '[v=\\\\s]*' + src[t.MAINVERSIONLOOSE] +\n                  src[t.PRERELEASELOOSE] + '?' +\n                  src[t.BUILD] + '?'\n\ntok('LOOSE')\nsrc[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'\n\ntok('GTLT')\nsrc[t.GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ntok('XRANGEIDENTIFIERLOOSE')\nsrc[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\ntok('XRANGEIDENTIFIER')\nsrc[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\ntok('XRANGEPLAIN')\nsrc[t.XRANGEPLAIN] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[t.PRERELEASE] + ')?' +\n                   src[t.BUILD] + '?' +\n                   ')?)?'\n\ntok('XRANGEPLAINLOOSE')\nsrc[t.XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +\n                        src[t.BUILD] + '?' +\n                        ')?)?'\n\ntok('XRANGE')\nsrc[t.XRANGE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAIN] + '$'\ntok('XRANGELOOSE')\nsrc[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ntok('COERCE')\nsrc[t.COERCE] = '(^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\ntok('COERCERTL')\nre[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ntok('LONETILDE')\nsrc[t.LONETILDE] = '(?:~>?)'\n\ntok('TILDETRIM')\nsrc[t.TILDETRIM] = '(\\\\s*)' + src[t.LONETILDE] + '\\\\s+'\nre[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\ntok('TILDE')\nsrc[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'\ntok('TILDELOOSE')\nsrc[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ntok('LONECARET')\nsrc[t.LONECARET] = '(?:\\\\^)'\n\ntok('CARETTRIM')\nsrc[t.CARETTRIM] = '(\\\\s*)' + src[t.LONECARET] + '\\\\s+'\nre[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\ntok('CARET')\nsrc[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'\ntok('CARETLOOSE')\nsrc[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ntok('COMPARATORLOOSE')\nsrc[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'\ntok('COMPARATOR')\nsrc[t.COMPARATOR] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.FULLPLAIN] + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ntok('COMPARATORTRIM')\nsrc[t.COMPARATORTRIM] = '(\\\\s*)' + src[t.GTLT] +\n                      '\\\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ntok('HYPHENRANGE')\nsrc[t.HYPHENRANGE] = '^\\\\s*(' + src[t.XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[t.XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\ntok('HYPHENRANGELOOSE')\nsrc[t.HYPHENRANGELOOSE] = '^\\\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\ntok('STAR')\nsrc[t.STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\nSemVer.prototype.compareBuild = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  var i = 0\n  do {\n    var a = this.build[i]\n    var b = other.build[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.compareBuild = compareBuild\nfunction compareBuild (a, b, loose) {\n  var versionA = new SemVer(a, loose)\n  var versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compareBuild(b, a, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1] !== undefined ? m[1] : ''\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY || version === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options)\n    } catch (er) {\n      return false\n    }\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    if (this.value === '') {\n      return true\n    }\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    if (comp.value === '') {\n      return true\n    }\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return (\n      isSatisfiable(thisComparators, options) &&\n      range.set.some(function (rangeComparators) {\n        return (\n          isSatisfiable(rangeComparators, options) &&\n          thisComparators.every(function (thisComparator) {\n            return rangeComparators.every(function (rangeComparator) {\n              return thisComparator.intersects(rangeComparator, options)\n            })\n          })\n        )\n      })\n    )\n  })\n}\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nfunction isSatisfiable (comparators, options) {\n  var result = true\n  var remainingComparators = comparators.slice()\n  var testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(function (otherComparator) {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p + pr\n    } else if (xm) {\n      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0' + pr +\n        ' <' + M + '.' + (+m + 1) + '.0' + pr\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    try {\n      version = new SemVer(version, this.options)\n    } catch (er) {\n      return false\n    }\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version, options) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  var match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    var next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n      (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n          next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  return parse(match[2] +\n    '.' + (match[3] || '0') +\n    '.' + (match[4] || '0'), options)\n}\n","var fs = require('fs');\n\nmodule.exports = function (filepath, split, encoding) {\n  split = typeof split !== 'undefined' ? split : \"\\n\";\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";\n\n  var ca = [];\n  var chain = fs.readFileSync(filepath, encoding);\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");\n  }\n  chain = chain.split(split);\n  var cert = [];\n  var _i, _len;\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {\n    var line = chain[_i];\n    if (!(line.length !== 0)) {\n      continue;\n    }\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      ca.push(cert.join(split));\n      cert = [];\n    }\n  }\n  return ca;\n}\n","module.exports = {\n  SFTPStream: require('./lib/sftp'),\n  SSH2Stream: require('./lib/ssh'),\n  utils: require('./lib/utils'),\n  constants: require('./lib/constants')\n};","module.exports = {\n  readUInt32BE: function readUInt32BE(buf, offset) {\n    return buf[offset++] * 16777216\n           + buf[offset++] * 65536\n           + buf[offset++] * 256\n           + buf[offset];\n  },\n  writeUInt32BE: function writeUInt32BE(buf, value, offset) {\n    buf[offset++] = (value >>> 24);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = value;\n    return offset;\n  },\n  writeUInt32LE: function writeUInt32LE(buf, value, offset) {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  }\n};\n","var i;\nvar keys;\nvar len;\n\nvar crypto = require('crypto');\nvar eddsaSupported = (function() {\n  if (typeof crypto.sign === 'function'\n      && typeof crypto.verify === 'function') {\n    var key = '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD'\n              + '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';\n    var data = Buffer.from('a');\n    var sig;\n    var verified;\n    try {\n      sig = crypto.sign(null, data, key);\n      verified = crypto.verify(null, data, key, sig);\n    } catch (ex) {}\n    return (Buffer.isBuffer(sig) && sig.length === 64 && verified === true);\n  }\n\n  return false;\n})();\n\nvar curve25519Supported = (typeof crypto.diffieHellman === 'function'\n                           && typeof crypto.generateKeyPairSync === 'function'\n                           && typeof crypto.createPublicKey === 'function');\n\nvar MESSAGE = exports.MESSAGE = {\n  // Transport layer protocol -- generic (1-19)\n  DISCONNECT: 1,\n  IGNORE: 2,\n  UNIMPLEMENTED: 3,\n  DEBUG: 4,\n  SERVICE_REQUEST: 5,\n  SERVICE_ACCEPT: 6,\n\n  // Transport layer protocol -- algorithm negotiation (20-29)\n  KEXINIT: 20,\n  NEWKEYS: 21,\n\n  // Transport layer protocol -- key exchange method-specific (30-49)\n\n  // User auth protocol -- generic (50-59)\n  USERAUTH_REQUEST: 50,\n  USERAUTH_FAILURE: 51,\n  USERAUTH_SUCCESS: 52,\n  USERAUTH_BANNER: 53,\n\n  // User auth protocol -- user auth method-specific (60-79)\n\n  // Connection protocol -- generic (80-89)\n  GLOBAL_REQUEST: 80,\n  REQUEST_SUCCESS: 81,\n  REQUEST_FAILURE: 82,\n\n  // Connection protocol -- channel-related (90-127)\n  CHANNEL_OPEN: 90,\n  CHANNEL_OPEN_CONFIRMATION: 91,\n  CHANNEL_OPEN_FAILURE: 92,\n  CHANNEL_WINDOW_ADJUST: 93,\n  CHANNEL_DATA: 94,\n  CHANNEL_EXTENDED_DATA: 95,\n  CHANNEL_EOF: 96,\n  CHANNEL_CLOSE: 97,\n  CHANNEL_REQUEST: 98,\n  CHANNEL_SUCCESS: 99,\n  CHANNEL_FAILURE: 100\n\n  // Reserved for client protocols (128-191)\n\n  // Local extensions (192-155)\n};\nfor (i = 0, keys = Object.keys(MESSAGE), len = keys.length; i < len; ++i)\n  MESSAGE[MESSAGE[keys[i]]] = keys[i];\n// context-specific message codes:\nMESSAGE.KEXDH_INIT = 30;\nMESSAGE.KEXDH_REPLY = 31;\nMESSAGE.KEXDH_GEX_REQUEST = 34;\nMESSAGE.KEXDH_GEX_GROUP = 31;\nMESSAGE.KEXDH_GEX_INIT = 32;\nMESSAGE.KEXDH_GEX_REPLY = 33;\nMESSAGE.KEXECDH_INIT = 30; // included here for completeness\nMESSAGE.KEXECDH_REPLY = 31; // included here for completeness\nMESSAGE.USERAUTH_PASSWD_CHANGEREQ = 60;\nMESSAGE.USERAUTH_PK_OK = 60;\nMESSAGE.USERAUTH_INFO_REQUEST = 60;\nMESSAGE.USERAUTH_INFO_RESPONSE = 61;\n\nvar DYNAMIC_KEXDH_MESSAGE = exports.DYNAMIC_KEXDH_MESSAGE = {};\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_GROUP] = 'KEXDH_GEX_GROUP';\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_REPLY] = 'KEXDH_GEX_REPLY';\n\nvar KEXDH_MESSAGE = exports.KEXDH_MESSAGE = {};\nKEXDH_MESSAGE[MESSAGE.KEXDH_INIT] = 'KEXDH_INIT';\nKEXDH_MESSAGE[MESSAGE.KEXDH_REPLY] = 'KEXDH_REPLY';\n\nvar DISCONNECT_REASON = exports.DISCONNECT_REASON = {\n  HOST_NOT_ALLOWED_TO_CONNECT: 1,\n  PROTOCOL_ERROR: 2,\n  KEY_EXCHANGE_FAILED: 3,\n  RESERVED: 4,\n  MAC_ERROR: 5,\n  COMPRESSION_ERROR: 6,\n  SERVICE_NOT_AVAILABLE: 7,\n  PROTOCOL_VERSION_NOT_SUPPORTED: 8,\n  HOST_KEY_NOT_VERIFIABLE: 9,\n  CONNECTION_LOST: 10,\n  BY_APPLICATION: 11,\n  TOO_MANY_CONNECTIONS: 12,\n  AUTH_CANCELED_BY_USER: 13,\n  NO_MORE_AUTH_METHODS_AVAILABLE: 14,\n  ILLEGAL_USER_NAME: 15\n};\nfor (i = 0, keys = Object.keys(DISCONNECT_REASON), len = keys.length;\n     i < len;\n     ++i) {\n  DISCONNECT_REASON[DISCONNECT_REASON[keys[i]]] = keys[i];\n}\n\nvar CHANNEL_OPEN_FAILURE = exports.CHANNEL_OPEN_FAILURE = {\n  ADMINISTRATIVELY_PROHIBITED: 1,\n  CONNECT_FAILED: 2,\n  UNKNOWN_CHANNEL_TYPE: 3,\n  RESOURCE_SHORTAGE: 4\n};\nfor (i = 0, keys = Object.keys(CHANNEL_OPEN_FAILURE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_OPEN_FAILURE[CHANNEL_OPEN_FAILURE[keys[i]]] = keys[i];\n}\n\nvar TERMINAL_MODE = exports.TERMINAL_MODE = {\n  TTY_OP_END: 0,        // Indicates end of options.\n  VINTR: 1,             // Interrupt character; 255 if none. Similarly for the\n                        //  other characters.  Not all of these characters are\n                        //  supported on all systems.\n  VQUIT: 2,             // The quit character (sends SIGQUIT signal on POSIX\n                        //  systems).\n  VERASE: 3,            // Erase the character to left of the cursor.\n  VKILL: 4,             // Kill the current input line.\n  VEOF: 5,              // End-of-file character (sends EOF from the terminal).\n  VEOL: 6,              // End-of-line character in addition to carriage return\n                        //  and/or linefeed.\n  VEOL2: 7,             // Additional end-of-line character.\n  VSTART: 8,            // Continues paused output (normally control-Q).\n  VSTOP: 9,             // Pauses output (normally control-S).\n  VSUSP: 10,            // Suspends the current program.\n  VDSUSP: 11,           // Another suspend character.\n  VREPRINT: 12,         // Reprints the current input line.\n  VWERASE: 13,          // Erases a word left of cursor.\n  VLNEXT: 14,           // Enter the next character typed literally, even if it\n                        //  is a special character\n  VFLUSH: 15,           // Character to flush output.\n  VSWTCH: 16,           // Switch to a different shell layer.\n  VSTATUS: 17,          // Prints system status line (load, command, pid, etc).\n  VDISCARD: 18,         // Toggles the flushing of terminal output.\n  IGNPAR: 30,           // The ignore parity flag.  The parameter SHOULD be 0\n                        //  if this flag is FALSE, and 1 if it is TRUE.\n  PARMRK: 31,           // Mark parity and framing errors.\n  INPCK: 32,            // Enable checking of parity errors.\n  ISTRIP: 33,           // Strip 8th bit off characters.\n  INLCR: 34,            // Map NL into CR on input.\n  IGNCR: 35,            // Ignore CR on input.\n  ICRNL: 36,            // Map CR to NL on input.\n  IUCLC: 37,            // Translate uppercase characters to lowercase.\n  IXON: 38,             // Enable output flow control.\n  IXANY: 39,            // Any char will restart after stop.\n  IXOFF: 40,            // Enable input flow control.\n  IMAXBEL: 41,          // Ring bell on input queue full.\n  ISIG: 50,             // Enable signals INTR, QUIT, [D]SUSP.\n  ICANON: 51,           // Canonicalize input lines.\n  XCASE: 52,            // Enable input and output of uppercase characters by\n                        //  preceding their lowercase equivalents with \"\\\".\n  ECHO: 53,             // Enable echoing.\n  ECHOE: 54,            // Visually erase chars.\n  ECHOK: 55,            // Kill character discards current line.\n  ECHONL: 56,           // Echo NL even if ECHO is off.\n  NOFLSH: 57,           // Don't flush after interrupt.\n  TOSTOP: 58,           // Stop background jobs from output.\n  IEXTEN: 59,           // Enable extensions.\n  ECHOCTL: 60,          // Echo control characters as ^(Char).\n  ECHOKE: 61,           // Visual erase for line kill.\n  PENDIN: 62,           // Retype pending input.\n  OPOST: 70,            // Enable output processing.\n  OLCUC: 71,            // Convert lowercase to uppercase.\n  ONLCR: 72,            // Map NL to CR-NL.\n  OCRNL: 73,            // Translate carriage return to newline (output).\n  ONOCR: 74,            // Translate newline to carriage return-newline\n                        // (output).\n  ONLRET: 75,           // Newline performs a carriage return (output).\n  CS7: 90,              // 7 bit mode.\n  CS8: 91,              // 8 bit mode.\n  PARENB: 92,           // Parity enable.\n  PARODD: 93,           // Odd parity, else even.\n  TTY_OP_ISPEED: 128,   // Specifies the input baud rate in bits per second.\n  TTY_OP_OSPEED: 129    // Specifies the output baud rate in bits per second.\n};\nfor (i = 0, keys = Object.keys(TERMINAL_MODE), len = keys.length; i < len; ++i)\n  TERMINAL_MODE[TERMINAL_MODE[keys[i]]] = keys[i];\n\nvar CHANNEL_EXTENDED_DATATYPE = exports.CHANNEL_EXTENDED_DATATYPE = {\n  STDERR: 1\n};\nfor (i = 0, keys = Object.keys(CHANNEL_EXTENDED_DATATYPE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_EXTENDED_DATATYPE[CHANNEL_EXTENDED_DATATYPE[keys[i]]] = keys[i];\n}\n\nexports.SIGNALS = ['ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT',\n                   'QUIT', 'SEGV', 'TERM', 'USR1', 'USR2', 'KILL',\n                   'PIPE'];\n\nvar DEFAULT_KEX = [\n  // https://tools.ietf.org/html/rfc5656#section-10.1\n  'ecdh-sha2-nistp256',\n  'ecdh-sha2-nistp384',\n  'ecdh-sha2-nistp521',\n\n  // https://tools.ietf.org/html/rfc4419#section-4\n  'diffie-hellman-group-exchange-sha256',\n\n  'diffie-hellman-group14-sha256',\n  'diffie-hellman-group16-sha512',\n  'diffie-hellman-group18-sha512',\n\n  'diffie-hellman-group14-sha1', // REQUIRED\n];\nif (curve25519Supported) {\n  DEFAULT_KEX.unshift('curve25519-sha256');\n  DEFAULT_KEX.unshift('curve25519-sha256@libssh.org');\n}\nvar SUPPORTED_KEX = [\n  // https://tools.ietf.org/html/rfc4419#section-4\n  'diffie-hellman-group-exchange-sha1',\n\n  'diffie-hellman-group1-sha1'  // REQUIRED\n];\nvar KEX_BUF = Buffer.from(DEFAULT_KEX.join(','), 'ascii');\nSUPPORTED_KEX = DEFAULT_KEX.concat(SUPPORTED_KEX);\n\nvar DEFAULT_SERVER_HOST_KEY = [\n  'ecdsa-sha2-nistp256',\n  'ecdsa-sha2-nistp384',\n  'ecdsa-sha2-nistp521',\n  'ssh-rsa',\n];\nif (eddsaSupported)\n  DEFAULT_SERVER_HOST_KEY.unshift('ssh-ed25519');\nvar SUPPORTED_SERVER_HOST_KEY = [\n  'ssh-dss'\n];\nvar SERVER_HOST_KEY_BUF = Buffer.from(DEFAULT_SERVER_HOST_KEY.join(','),\n                                      'ascii');\nSUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat(\n  SUPPORTED_SERVER_HOST_KEY\n);\n\nvar DEFAULT_CIPHER = [\n  // http://tools.ietf.org/html/rfc4344#section-4\n  'aes128-ctr',\n  'aes192-ctr',\n  'aes256-ctr',\n\n  // http://tools.ietf.org/html/rfc5647\n  'aes128-gcm',\n  'aes128-gcm@openssh.com',\n  'aes256-gcm',\n  'aes256-gcm@openssh.com'\n];\nvar SUPPORTED_CIPHER = [\n  'aes256-cbc',\n  'aes192-cbc',\n  'aes128-cbc',\n  'blowfish-cbc',\n  '3des-cbc',\n\n  // http://tools.ietf.org/html/rfc4345#section-4:\n  'arcfour256',\n  'arcfour128',\n\n  'cast128-cbc',\n  'arcfour'\n];\nvar CIPHER_BUF = Buffer.from(DEFAULT_CIPHER.join(','), 'ascii');\nSUPPORTED_CIPHER = DEFAULT_CIPHER.concat(SUPPORTED_CIPHER);\n\nvar DEFAULT_HMAC = [\n  'hmac-sha2-256',\n  'hmac-sha2-512',\n  'hmac-sha1',\n];\nvar SUPPORTED_HMAC = [\n  'hmac-md5',\n  'hmac-sha2-256-96', // first 96 bits of HMAC-SHA256\n  'hmac-sha2-512-96', // first 96 bits of HMAC-SHA512\n  'hmac-ripemd160',\n  'hmac-sha1-96',     // first 96 bits of HMAC-SHA1\n  'hmac-md5-96'       // first 96 bits of HMAC-MD5\n];\nvar HMAC_BUF = Buffer.from(DEFAULT_HMAC.join(','), 'ascii');\nSUPPORTED_HMAC = DEFAULT_HMAC.concat(SUPPORTED_HMAC);\n\nvar DEFAULT_COMPRESS = [\n  'none',\n  'zlib@openssh.com', // ZLIB (LZ77) compression, except\n                      // compression/decompression does not start until after\n                      // successful user authentication\n  'zlib'              // ZLIB (LZ77) compression\n];\nvar SUPPORTED_COMPRESS = [];\nvar COMPRESS_BUF = Buffer.from(DEFAULT_COMPRESS.join(','), 'ascii');\nSUPPORTED_COMPRESS = DEFAULT_COMPRESS.concat(SUPPORTED_COMPRESS);\n\nfunction makeCipherInfo(blockLen, keyLen, ivLen, authLen, discardLen, stream) {\n  return {\n    blockLen: blockLen,\n    keyLen: keyLen,\n    ivLen: ivLen === 0 ? blockLen : ivLen,\n    authLen: authLen,\n    discardLen: discardLen,\n    stream: stream,\n  };\n}\nexports.CIPHER_INFO = {\n  'aes128-gcm': makeCipherInfo(16, 16, 12, 16, 0, false),\n  'aes256-gcm': makeCipherInfo(16, 32, 12, 16, 0, false),\n  'aes128-gcm@openssh.com': makeCipherInfo(16, 16, 12, 16, 0, false),\n  'aes256-gcm@openssh.com': makeCipherInfo(16, 32, 12, 16, 0, false),\n\n  'aes128-cbc': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'aes192-cbc': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'aes256-cbc': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'rijndael-cbc@lysator.liu.se': makeCipherInfo(16, 32, 0, 0, 0, false),\n  '3des-cbc': makeCipherInfo(8, 24, 0, 0, 0, false),\n  'blowfish-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'idea-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'cast128-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'camellia128-cbc': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-cbc': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-cbc': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'camellia128-cbc@openssh.com': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-cbc@openssh.com': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-cbc@openssh.com': makeCipherInfo(16, 32, 0, 0, 0, false),\n\n  'aes128-ctr': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'aes192-ctr': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'aes256-ctr': makeCipherInfo(16, 32, 0, 0, 0, false),\n  '3des-ctr': makeCipherInfo(8, 24, 0, 0, 0, false),\n  'blowfish-ctr': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'cast128-ctr': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'camellia128-ctr': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-ctr': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-ctr': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'camellia128-ctr@openssh.com': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-ctr@openssh.com': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-ctr@openssh.com': makeCipherInfo(16, 32, 0, 0, 0, false),\n\n  /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n     [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n     generated by the cipher MUST be discarded, and the first byte of the\n     first encrypted packet MUST be encrypted using the 1537th byte of\n     keystream.\n\n     -- http://tools.ietf.org/html/rfc4345#section-4 */\n  'arcfour': makeCipherInfo(8, 16, 0, 0, 1536, true),\n  'arcfour128': makeCipherInfo(8, 16, 0, 0, 1536, true),\n  'arcfour256': makeCipherInfo(8, 32, 0, 0, 1536, true),\n  'arcfour512': makeCipherInfo(8, 64, 0, 0, 1536, true),\n};\n\nfunction makeHMACInfo(len, actualLen) {\n  return { len: len, actualLen: actualLen };\n}\nexports.HMAC_INFO = {\n  'hmac-md5': makeHMACInfo(16, 16),\n  'hmac-md5-96': makeHMACInfo(16, 12),\n  'hmac-ripemd160': makeHMACInfo(20, 20),\n  'hmac-sha1': makeHMACInfo(20, 20),\n  'hmac-sha1-96': makeHMACInfo(20, 12),\n  'hmac-sha2-256': makeHMACInfo(32, 32),\n  'hmac-sha2-256-96': makeHMACInfo(32, 12),\n  'hmac-sha2-512': makeHMACInfo(64, 64),\n  'hmac-sha2-512-96': makeHMACInfo(64, 12),\n};\n\nexports.ALGORITHMS = {\n  KEX: DEFAULT_KEX,\n  KEX_BUF: KEX_BUF,\n  SUPPORTED_KEX: SUPPORTED_KEX,\n\n  SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY,\n  SERVER_HOST_KEY_BUF: SERVER_HOST_KEY_BUF,\n  SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY,\n\n  CIPHER: DEFAULT_CIPHER,\n  CIPHER_BUF: CIPHER_BUF,\n  SUPPORTED_CIPHER: SUPPORTED_CIPHER,\n\n  HMAC: DEFAULT_HMAC,\n  HMAC_BUF: HMAC_BUF,\n  SUPPORTED_HMAC: SUPPORTED_HMAC,\n\n  COMPRESS: DEFAULT_COMPRESS,\n  COMPRESS_BUF: COMPRESS_BUF,\n  SUPPORTED_COMPRESS: SUPPORTED_COMPRESS\n};\nexports.SSH_TO_OPENSSL = {\n  // ECDH key exchange\n  'ecdh-sha2-nistp256': 'prime256v1', // OpenSSL's name for 'secp256r1'\n  'ecdh-sha2-nistp384': 'secp384r1',\n  'ecdh-sha2-nistp521': 'secp521r1',\n  // Ciphers\n  'aes128-gcm': 'aes-128-gcm',\n  'aes256-gcm': 'aes-256-gcm',\n  'aes128-gcm@openssh.com': 'aes-128-gcm',\n  'aes256-gcm@openssh.com': 'aes-256-gcm',\n  '3des-cbc': 'des-ede3-cbc',\n  'blowfish-cbc': 'bf-cbc',\n  'aes256-cbc': 'aes-256-cbc',\n  'aes192-cbc': 'aes-192-cbc',\n  'aes128-cbc': 'aes-128-cbc',\n  'idea-cbc': 'idea-cbc',\n  'cast128-cbc': 'cast-cbc',\n  'rijndael-cbc@lysator.liu.se': 'aes-256-cbc',\n  'arcfour128': 'rc4',\n  'arcfour256': 'rc4',\n  'arcfour512': 'rc4',\n  'arcfour': 'rc4',\n  'camellia128-cbc': 'camellia-128-cbc',\n  'camellia192-cbc': 'camellia-192-cbc',\n  'camellia256-cbc': 'camellia-256-cbc',\n  'camellia128-cbc@openssh.com': 'camellia-128-cbc',\n  'camellia192-cbc@openssh.com': 'camellia-192-cbc',\n  'camellia256-cbc@openssh.com': 'camellia-256-cbc',\n  '3des-ctr': 'des-ede3',\n  'blowfish-ctr': 'bf-ecb',\n  'aes256-ctr': 'aes-256-ctr',\n  'aes192-ctr': 'aes-192-ctr',\n  'aes128-ctr': 'aes-128-ctr',\n  'cast128-ctr': 'cast5-ecb',\n  'camellia128-ctr': 'camellia-128-ecb',\n  'camellia192-ctr': 'camellia-192-ecb',\n  'camellia256-ctr': 'camellia-256-ecb',\n  'camellia128-ctr@openssh.com': 'camellia-128-ecb',\n  'camellia192-ctr@openssh.com': 'camellia-192-ecb',\n  'camellia256-ctr@openssh.com': 'camellia-256-ecb',\n  // HMAC\n  'hmac-sha1-96': 'sha1',\n  'hmac-sha1': 'sha1',\n  'hmac-sha2-256': 'sha256',\n  'hmac-sha2-256-96': 'sha256',\n  'hmac-sha2-512': 'sha512',\n  'hmac-sha2-512-96': 'sha512',\n  'hmac-md5-96': 'md5',\n  'hmac-md5': 'md5',\n  'hmac-ripemd160': 'ripemd160'\n};\n\nvar BUGS = exports.BUGS = {\n  BAD_DHGEX: 1,\n  OLD_EXIT: 2,\n  DYN_RPORT_BUG: 4\n};\n\nexports.BUGGY_IMPLS = [\n  [ 'Cisco-1.25', BUGS.BAD_DHGEX ],\n  [ /^[0-9.]+$/, BUGS.OLD_EXIT ], // old SSH.com implementations\n  [ /^OpenSSH_5\\.\\d+/, BUGS.DYN_RPORT_BUG ]\n];\n\nexports.EDDSA_SUPPORTED = eddsaSupported;\nexports.CURVE25519_SUPPORTED = curve25519Supported;\n","// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// Set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nBigInteger.prototype.am = am3;\ndbits = 28;\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;       // y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if(\"number\" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))  // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {  // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// Expose the Barrett function\nBigInteger.prototype.Barrett = Barrett\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\nmodule.exports = BigInteger;\n\n","// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n\nvar crypto = require('crypto');\nvar cryptoSign = crypto.sign;\nvar cryptoVerify = crypto.verify;\nvar createSign = crypto.createSign;\nvar createVerify = crypto.createVerify;\nvar createDecipheriv = crypto.createDecipheriv;\nvar createHash = crypto.createHash;\nvar createHmac = crypto.createHmac;\nvar supportedOpenSSLCiphers = crypto.getCiphers();\n\nvar utils;\nvar Ber = require('asn1').Ber;\nvar bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\n\nvar bufferHelpers = require('./buffer-helpers');\nvar readUInt32BE = bufferHelpers.readUInt32BE;\nvar writeUInt32BE = bufferHelpers.writeUInt32BE;\nvar constants = require('./constants');\nvar SUPPORTED_CIPHER = constants.ALGORITHMS.SUPPORTED_CIPHER;\nvar CIPHER_INFO = constants.CIPHER_INFO;\nvar SSH_TO_OPENSSL = constants.SSH_TO_OPENSSL;\nvar EDDSA_SUPPORTED = constants.EDDSA_SUPPORTED;\n\nvar SYM_HASH_ALGO = Symbol('Hash Algorithm');\nvar SYM_PRIV_PEM = Symbol('Private key PEM');\nvar SYM_PUB_PEM = Symbol('Public key PEM');\nvar SYM_PUB_SSH = Symbol('Public key SSH');\nvar SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nvar CIPHER_INFO_OPENSSL = Object.create(null);\n(function() {\n  var keys = Object.keys(CIPHER_INFO);\n  for (var i = 0; i < keys.length; ++i) {\n    var cipherName = SSH_TO_OPENSSL[keys[i]];\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])\n      continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n})();\n\nvar trimStart = (function() {\n  if (typeof String.prototype.trimStart === 'function') {\n    return function trimStart(str) {\n      return str.trimStart();\n    };\n  }\n\n  return function trimStart(str) {\n    var start = 0;\n    for (var i = 0; i < str.length; ++i) {\n      switch (str.charCodeAt(i)) {\n        case 32: // ' '\n        case 9: // '\\t'\n        case 13: // '\\r'\n        case 10: // '\\n'\n        case 12: // '\\f'\n          ++start;\n          continue;\n      }\n      break;\n    }\n    if (start === 0)\n      return str;\n    return str.slice(start);\n  };\n})();\n\nfunction makePEM(type, data) {\n  data = data.toString('base64');\n  return '-----BEGIN ' + type + ' KEY-----\\n'\n         + data.replace(/.{64}/g, '$&\\n')\n         + (data.length % 64 ? '\\n' : '')\n         + '-----END ' + type + ' KEY-----';\n}\n\nfunction combineBuffers(buf1, buf2) {\n  var result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  buf1.copy(result, 0);\n  buf2.copy(result, buf1.length);\n  return result;\n}\n\nfunction skipFields(buf, nfields) {\n  var bufLen = buf.length;\n  var pos = (buf._pos || 0);\n  for (var i = 0; i < nfields; ++i) {\n    var left = (bufLen - pos);\n    if (pos >= bufLen || left < 4)\n      return false;\n    var len = readUInt32BE(buf, pos);\n    if (left < 4 + len)\n      return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\n\nfunction genOpenSSLRSAPub(n, e) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHRSAPub(n, e) {\n  var publicKey = Buffer.allocUnsafe(4 + 7 // \"ssh-rsa\"\n                                     + 4 + n.length\n                                     + 4 + e.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.write('ssh-rsa', 4, 7, 'ascii');\n\n  var i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  e.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  n.copy(publicKey, i + 4);\n\n  return publicKey;\n}\n\nvar genOpenSSLRSAPriv = (function() {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    var asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n\n  function bigIntFromBuffer(buf) {\n    return BigInt('0x' + buf.toString('hex'));\n  }\n\n  function bigIntToBuffer(bn) {\n    var hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = '0' + hex;\n    } else {\n      var sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56 || (sigbit >= 97 && sigbit <= 102))\n        hex = '00' + hex;\n    }\n    return Buffer.from(hex, 'hex');\n  }\n\n  // Feature detect native BigInt availability and use it when possible\n  try {\n    var code = [\n      'return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {',\n      '  var bn_d = bigIntFromBuffer(d);',\n      '  var dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));',\n      '  var dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));',\n      '  return makePEM(\\'RSA PRIVATE\\', '\n        + 'genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));',\n      '};'\n    ].join('\\n');\n    return new Function(\n      'bigIntFromBuffer, bigIntToBuffer, makePEM, genRSAASN1Buf',\n      code\n    )(bigIntFromBuffer, bigIntToBuffer, makePEM, genRSAASN1Buf);\n  } catch (ex) {\n    return (function() {\n      var BigInteger = require('./jsbn.js');\n      return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n        var pbi = new BigInteger(p, 256);\n        var qbi = new BigInteger(q, 256);\n        var dbi = new BigInteger(d, 256);\n        var dmp1bi = dbi.mod(pbi.subtract(BigInteger.ONE));\n        var dmq1bi = dbi.mod(qbi.subtract(BigInteger.ONE));\n        var dmp1 = Buffer.from(dmp1bi.toByteArray());\n        var dmq1 = Buffer.from(dmq1bi.toByteArray());\n        return makePEM('RSA PRIVATE',\n                       genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n      };\n    })();\n  }\n})();\n\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  var publicKey = Buffer.allocUnsafe(4 + 7 // ssh-dss\n                                     + 4 + p.length\n                                     + 4 + q.length\n                                     + 4 + g.length\n                                     + 4 + y.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.write('ssh-dss', 4, 7, 'ascii');\n\n  var i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  p.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  q.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  g.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  y.copy(publicKey, i + 4);\n\n  return publicKey;\n}\n\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(g, Ber.Integer);\n    asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLEdPub(pub) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(pub.length);\n      pub.copy(asnWriter._buf, asnWriter._offset, 0, pub.length);\n      asnWriter._offset += pub.length;\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHEdPub(pub) {\n  var publicKey = Buffer.allocUnsafe(4 + 11 // ssh-ed25519\n                                     + 4 + pub.length);\n\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.write('ssh-ed25519', 4, 11, 'ascii');\n\n  writeUInt32BE(publicKey, pub.length, 15);\n  pub.copy(publicKey, 19);\n\n  return publicKey;\n}\n\nfunction genOpenSSLEdPriv(priv) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x00, Ber.Integer);\n\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PrivateKey\n    asnWriter.startSequence(Ber.OctetString);\n      asnWriter.writeBuffer(priv, Ber.OctetString);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPub(oid, Q) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      Q.copy(asnWriter._buf, asnWriter._offset, 0, Q.length);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHECDSAPub(oid, Q) {\n  var curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n\n  var publicKey = Buffer.allocUnsafe(4 + 19 // ecdsa-sha2-<curve name>\n                                     + 4 + 8 // <curve name>\n                                     + 4 + Q.length);\n\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.write('ecdsa-sha2-' + curveName, 4, 19, 'ascii');\n\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.write(curveName, 27, 8, 'ascii');\n\n  writeUInt32BE(publicKey, Q.length, 35);\n  Q.copy(publicKey, 39);\n\n  return publicKey;\n}\n\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x01, Ber.Integer);\n    // privateKey\n    asnWriter.writeBuffer(priv, Ber.OctetString);\n    // parameters (optional)\n    asnWriter.startSequence(0xA0);\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n    // publicKey (optional)\n    asnWriter.startSequence(0xA1);\n      asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(pub.length);\n        pub.copy(asnWriter._buf, asnWriter._offset, 0, pub.length);\n        asnWriter._offset += pub.length;\n        // end hack\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  var tempECDH = crypto.createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\n\nvar baseKeySign = (function() {\n  if (typeof cryptoSign === 'function') {\n    return function sign(data) {\n      var pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      try {\n        return cryptoSign(this[SYM_HASH_ALGO], data, pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  } else {\n    function trySign(signature, privKey) {\n      try {\n        return signature.sign(privKey);\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    return function sign(data) {\n      var pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      var signature = createSign(this[SYM_HASH_ALGO]);\n      signature.update(data);\n      return trySign(signature, pem);\n    };\n  }\n})();\n\nvar baseKeyVerify = (function() {\n  if (typeof cryptoVerify === 'function') {\n    return function verify(data, signature) {\n      var pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      try {\n        return cryptoVerify(this[SYM_HASH_ALGO], data, pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  } else {\n    function tryVerify(verifier, pubKey, signature) {\n      try {\n        return verifier.verify(pubKey, signature);\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    return function verify(data, signature) {\n      var pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      var verifier = createVerify(this[SYM_HASH_ALGO]);\n      verifier.update(data);\n      return tryVerify(verifier, pem, signature);\n    };\n  }\n})();\n\nvar BaseKey = {\n  sign: baseKeySign,\n  verify: baseKeyVerify,\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n};\n\n\n\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n(function() {\n  var regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    var ret;\n    var data = Buffer.from(m[1], 'base64');\n    if (data.length < 31) // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    var magic = data.toString('ascii', 0, 15);\n    if (magic !== 'openssh-key-v1\\0')\n      return new Error('Unsupported OpenSSH key magic: ' + magic);\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var cipherName = utils.readString(data, 15, 'ascii');\n    if (cipherName === false)\n      return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1)\n      return new Error('Unsupported cipher for OpenSSH key: ' + cipherName);\n\n    var kdfName = utils.readString(data, data._pos, 'ascii');\n    if (kdfName === false)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none')\n        return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt')\n        return new Error('Unsupported kdf name for OpenSSH key: ' + kdfName);\n      if (!passphrase) {\n        return new Error(\n          'Encrypted private OpenSSH key detected, but no passphrase given'\n        );\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    var encInfo;\n    var cipherKey;\n    var cipherIV;\n    if (cipherName !== 'none')\n      encInfo = CIPHER_INFO[cipherName];\n    var kdfOptions = utils.readString(data, data._pos);\n    if (kdfOptions === false)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          var salt = utils.readString(kdfOptions, 0);\n          if (salt === false || kdfOptions._pos + 4 > kdfOptions.length)\n            return new Error('Malformed OpenSSH private key');\n          var rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          var gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          var r = bcrypt_pbkdf(passphrase,\n                               passphrase.length,\n                               salt,\n                               salt.length,\n                               gen,\n                               gen.length,\n                               rounds);\n          if (r !== 0)\n            return new Error('Failed to generate information to decrypt key');\n          cipherKey = gen.slice(0, encInfo.keyLen);\n          cipherIV = gen.slice(encInfo.keyLen);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    var keyCount = utils.readInt(data, data._pos);\n    if (keyCount === false)\n      return new Error('Malformed OpenSSH private key');\n    data._pos += 4;\n\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (var i = 0; i < keyCount; ++i) {\n        var pubData = utils.readString(data, data._pos);\n        if (pubData === false)\n          return new Error('Malformed OpenSSH private key');\n        var type = utils.readString(pubData, 0, 'ascii');\n        if (type === false)\n          return new Error('Malformed OpenSSH private key');\n      }\n\n      var privBlob = utils.readString(data, data._pos);\n      if (privBlob === false)\n        return new Error('Malformed OpenSSH private key');\n\n      if (cipherKey !== undefined) {\n        // encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen\n            || (privBlob.length % encInfo.blockLen) !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          var options = { authTagLength: encInfo.authLen };\n          var decipher = createDecipheriv(SSH_TO_OPENSSL[cipherName],\n                                          cipherKey,\n                                          cipherIV,\n                                          options);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen)\n              return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(\n              data.slice(data._pos, data._pos += encInfo.authLen)\n            );\n          }\n          privBlob = combineBuffers(decipher.update(privBlob),\n                                    decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length)\n        return new Error('Malformed OpenSSH private key');\n\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    return ret;\n  };\n\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    var keys = [];\n    /*\n      uint32\tcheckint\n      uint32\tcheckint\n      string\tprivatekey1\n      string\tcomment1\n      string\tprivatekey2\n      string\tcomment2\n      ...\n      string\tprivatekeyN\n      string\tcommentN\n      char\t1\n      char\t2\n      char\t3\n      ...\n      char\tpadlen % 255\n    */\n    if (data.length < 8)\n      return new Error('Malformed OpenSSH private key');\n    var check1 = readUInt32BE(data, 0);\n    var check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted)\n        return new Error('OpenSSH key integrity check failed -- bad passphrase?');\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    var i;\n    var oid;\n    for (i = 0; i < nkeys; ++i) {\n      var algo = undefined;\n      var privPEM = undefined;\n      var pubPEM = undefined;\n      var pubSSH = undefined;\n      // The OpenSSH documentation for the key format actually lies, the entirety\n      // of the private key content is not contained with a string field, it's\n      // actually the literal contents of the private key, so to be able to find\n      // the end of the key data you need to know the layout/format of each key\n      // type ...\n      var type = utils.readString(data, data._pos, 'ascii');\n      if (type === false)\n        return new Error('Malformed OpenSSH private key');\n\n      switch (type) {\n        case 'ssh-rsa':\n          /*\n            string  n -- public\n            string  e -- public\n            string  d -- private\n            string  iqmp -- private\n            string  p -- private\n            string  q -- private\n          */\n          var n = utils.readString(data, data._pos);\n          if (n === false)\n            return new Error('Malformed OpenSSH private key');\n          var e = utils.readString(data, data._pos);\n          if (e === false)\n            return new Error('Malformed OpenSSH private key');\n          var d = utils.readString(data, data._pos);\n          if (d === false)\n            return new Error('Malformed OpenSSH private key');\n          var iqmp = utils.readString(data, data._pos);\n          if (iqmp === false)\n            return new Error('Malformed OpenSSH private key');\n          var p = utils.readString(data, data._pos);\n          if (p === false)\n            return new Error('Malformed OpenSSH private key');\n          var q = utils.readString(data, data._pos);\n          if (q === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          algo = 'sha1';\n          break;\n        case 'ssh-dss':\n          /*\n            string  p -- public\n            string  q -- public\n            string  g -- public\n            string  y -- public\n            string  x -- private\n          */\n          var p = utils.readString(data, data._pos);\n          if (p === false)\n            return new Error('Malformed OpenSSH private key');\n          var q = utils.readString(data, data._pos);\n          if (q === false)\n            return new Error('Malformed OpenSSH private key');\n          var g = utils.readString(data, data._pos);\n          if (g === false)\n            return new Error('Malformed OpenSSH private key');\n          var y = utils.readString(data, data._pos);\n          if (y === false)\n            return new Error('Malformed OpenSSH private key');\n          var x = utils.readString(data, data._pos);\n          if (x === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          algo = 'sha1';\n          break;\n        case 'ssh-ed25519':\n          if (!EDDSA_SUPPORTED)\n            return new Error('Unsupported OpenSSH private key type: ' + type);\n          /*\n            * string  public key\n            * string  private key + public key\n          */\n          var edpub = utils.readString(data, data._pos);\n          if (edpub === false || edpub.length !== 32)\n            return new Error('Malformed OpenSSH private key');\n          var edpriv = utils.readString(data, data._pos);\n          if (edpriv === false || edpriv.length !== 64)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLEdPub(edpub);\n          pubSSH = genOpenSSHEdPub(edpub);\n          privPEM = genOpenSSLEdPriv(edpriv.slice(0, 32));\n          algo = null;\n          break;\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        case 'ecdsa-sha2-nistp521':\n          if (algo === undefined) {\n            algo = 'sha512';\n            oid = '1.3.132.0.35';\n          }\n          /*\n            string  curve name\n            string  Q -- public\n            string  d -- private\n          */\n          // TODO: validate curve name against type\n          if (!skipFields(data, 1)) // Skip curve name\n            return new Error('Malformed OpenSSH private key');\n          var ecpub = utils.readString(data, data._pos);\n          if (ecpub === false)\n            return new Error('Malformed OpenSSH private key');\n          var ecpriv = utils.readString(data, data._pos);\n          if (ecpriv === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n          pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n          privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n          break;\n        default:\n          return new Error('Unsupported OpenSSH private key type: ' + type);\n      }\n\n      var privComment = utils.readString(data, data._pos, 'utf8');\n      if (privComment === false)\n        return new Error('Malformed OpenSSH private key');\n\n      keys.push(\n        new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo,\n                            decrypted)\n      );\n    }\n    var cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== (++cnt % 255))\n        return new Error('Malformed OpenSSH private key');\n    }\n\n    return keys;\n  }\n})();\n\n\n\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n(function() {\n  var regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    var privBlob = Buffer.from(m[3], 'base64');\n    var headers = m[2];\n    var decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (var i = 0; i < headers.length; ++i) {\n        var header = headers[i];\n        var sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          var val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1)\n            continue;\n          var cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(\n              'Cipher ('\n              + cipherName\n              + ') not supported for encrypted OpenSSH private key'\n            );\n          }\n          var encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(\n              'Cipher ('\n              + cipherName\n              + ') not supported for encrypted OpenSSH private key'\n            );\n          }\n          var cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen)\n            return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error(\n              'Encrypted OpenSSH private key detected, but no passphrase given'\n            );\n          }\n          var cipherKey = createHash('md5')\n                            .update(passphrase)\n                            .update(cipherIV.slice(0, 8))\n                            .digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(\n              cipherKey,\n              (createHash('md5')\n                .update(cipherKey)\n                .update(passphrase)\n                .update(cipherIV)\n                .digest()).slice(0, 8)\n            );\n          }\n          if (cipherKey.length > encInfo.keyLen)\n            cipherKey = cipherKey.slice(0, encInfo.keyLen);\n          try {\n            var decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob),\n                                      decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n\n    var type;\n    var privPEM;\n    var pubPEM;\n    var pubSSH;\n    var algo;\n    var reader;\n    var errMsg = 'Malformed OpenSSH private key';\n    if (decrypted)\n      errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          var n = reader.readString(Ber.Integer, true);\n          if (n === null)\n            return new Error(errMsg);\n          var e = reader.readString(Ber.Integer, true);\n          if (e === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          var p = reader.readString(Ber.Integer, true);\n          if (p === null)\n            return new Error(errMsg);\n          var q = reader.readString(Ber.Integer, true);\n          if (q === null)\n            return new Error(errMsg);\n          var g = reader.readString(Ber.Integer, true);\n          if (g === null)\n            return new Error(errMsg);\n          var y = reader.readString(Ber.Integer, true);\n          if (y === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        var ecSSLName;\n        var ecPriv;\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n          var offset = reader.readLength(); // Skip context length\n          if (offset !== null) {\n            reader._offset = offset;\n            var oid = reader.readOID();\n            if (oid === null)\n              return new Error(errMsg);\n            switch (oid) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n              default:\n                return new Error('Unsupported private key EC OID: ' + oid);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        var pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(oid, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(oid, pubBlob);\n        break;\n    }\n\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo,\n                                   decrypted);\n  };\n})();\n\n\n\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n(function() {\n  var EMPTY_PASSPHRASE = Buffer.alloc(0);\n  var PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  var PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  var PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  var regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    var cipherName = m[2];\n    var encrypted = (cipherName !== 'none');\n    if (encrypted && !passphrase) {\n      return new Error(\n        'Encrypted PPK private key detected, but no passphrase given'\n      );\n    }\n\n    var privBlob = Buffer.from(m[5], 'base64');\n\n    if (encrypted) {\n      var encInfo = CIPHER_INFO[cipherName];\n      var cipherKey = combineBuffers(\n        createHash('sha1').update(PPK_PP1).update(passphrase).digest(),\n        createHash('sha1').update(PPK_PP2).update(passphrase).digest()\n      );\n      if (cipherKey.length > encInfo.keyLen)\n        cipherKey = cipherKey.slice(0, encInfo.keyLen);\n      try {\n        var decipher = createDecipheriv(SSH_TO_OPENSSL[cipherName],\n                                        cipherKey,\n                                        PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob),\n                                  decipher.final());\n        decrypted = true;\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    var type = m[1];\n    var comment = m[3];\n    var pubBlob = Buffer.from(m[4], 'base64');\n\n    var mac = m[6];\n    var typeLen = type.length;\n    var cipherNameLen = cipherName.length;\n    var commentLen = Buffer.byteLength(comment);\n    var pubLen = pubBlob.length;\n    var privLen = privBlob.length;\n    var macData = Buffer.allocUnsafe(4 + typeLen\n                                     + 4 + cipherNameLen\n                                     + 4 + commentLen\n                                     + 4 + pubLen\n                                     + 4 + privLen);\n    var p = 0;\n\n    writeUInt32BE(macData, typeLen, p);\n    macData.write(type, p += 4, typeLen, 'ascii');\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.write(cipherName, p += 4, cipherNameLen, 'ascii');\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.write(comment, p += 4, commentLen, 'utf8');\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    pubBlob.copy(macData, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    privBlob.copy(macData, p + 4);\n\n    if (!passphrase)\n      passphrase = EMPTY_PASSPHRASE;\n\n    var calcMAC = createHmac('sha1',\n                             createHash('sha1')\n                               .update('putty-private-key-file-mac-key')\n                               .update(passphrase)\n                               .digest())\n                    .update(macData)\n                    .digest('hex');\n\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error(\n          'PPK private key integrity check failed -- bad passphrase?'\n        );\n      } else {\n        return new Error('PPK private key integrity check failed');\n      }\n    }\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var pubPEM;\n    var pubSSH;\n    var privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa':\n        var e = utils.readString(pubBlob, pubBlob._pos);\n        if (e === false)\n          return new Error('Malformed PPK public key');\n        var n = utils.readString(pubBlob, pubBlob._pos);\n        if (n === false)\n          return new Error('Malformed PPK public key');\n        var d = utils.readString(privBlob, 0);\n        if (d === false)\n          return new Error('Malformed PPK private key');\n        var p = utils.readString(privBlob, privBlob._pos);\n        if (p === false)\n          return new Error('Malformed PPK private key');\n        var q = utils.readString(privBlob, privBlob._pos);\n        if (q === false)\n          return new Error('Malformed PPK private key');\n        var iqmp = utils.readString(privBlob, privBlob._pos);\n        if (iqmp === false)\n          return new Error('Malformed PPK private key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n        break;\n      case 'ssh-dss':\n        var p = utils.readString(pubBlob, pubBlob._pos);\n        if (p === false)\n          return new Error('Malformed PPK public key');\n        var q = utils.readString(pubBlob, pubBlob._pos);\n        if (q === false)\n          return new Error('Malformed PPK public key');\n        var g = utils.readString(pubBlob, pubBlob._pos);\n        if (g === false)\n          return new Error('Malformed PPK public key');\n        var y = utils.readString(pubBlob, pubBlob._pos);\n        if (y === false)\n          return new Error('Malformed PPK public key');\n        var x = utils.readString(privBlob, 0);\n        if (x === false)\n          return new Error('Malformed PPK private key');\n\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n        break;\n    }\n\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1',\n                           encrypted);\n  };\n})();\n\n\nfunction parseDER(data, baseType, comment, fullType) {\n  // avoid cyclic require by requiring on first use\n  if (!utils)\n    utils = require('./utils');\n\n  var algo;\n  var pubPEM = null;\n  var pubSSH = null;\n  switch (baseType) {\n    case 'ssh-rsa':\n      var e = utils.readString(data, data._pos);\n      if (e === false)\n        return new Error('Malformed OpenSSH public key');\n      var n = utils.readString(data, data._pos);\n      if (n === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLRSAPub(n, e);\n      pubSSH = genOpenSSHRSAPub(n, e);\n      algo = 'sha1';\n      break;\n    case 'ssh-dss':\n      var p = utils.readString(data, data._pos);\n      if (p === false)\n        return new Error('Malformed OpenSSH public key');\n      var q = utils.readString(data, data._pos);\n      if (q === false)\n        return new Error('Malformed OpenSSH public key');\n      var g = utils.readString(data, data._pos);\n      if (g === false)\n        return new Error('Malformed OpenSSH public key');\n      var y = utils.readString(data, data._pos);\n      if (y === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLDSAPub(p, q, g, y);\n      pubSSH = genOpenSSHDSAPub(p, q, g, y);\n      algo = 'sha1';\n      break;\n    case 'ssh-ed25519':\n      var edpub = utils.readString(data, data._pos);\n      if (edpub === false || edpub.length !== 32)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLEdPub(edpub);\n      pubSSH = genOpenSSHEdPub(edpub);\n      algo = null;\n      break;\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    case 'ecdsa-sha2-nistp521':\n      if (algo === undefined) {\n        algo = 'sha512';\n        oid = '1.3.132.0.35';\n      }\n      // TODO: validate curve name against type\n      if (!skipFields(data, 1)) // Skip curve name\n        return new Error('Malformed OpenSSH public key');\n      var ecpub = utils.readString(data, data._pos);\n      if (ecpub === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n      pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n      break;\n    default:\n      return new Error('Unsupported OpenSSH public key type: ' + baseType);\n  }\n\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n(function() {\n  var regexp;\n  if (EDDSA_SUPPORTED)\n    regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  else\n    regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = function(str) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var fullType = m[1];\n    var baseType = m[2];\n    var data = Buffer.from(m[3], 'base64');\n    var comment = (m[4] || '');\n\n    var type = utils.readString(data, data._pos, 'ascii');\n    if (type === false || type.indexOf(baseType) !== 0)\n      return new Error('Malformed OpenSSH public key');\n\n    return parseDER(data, baseType, comment, fullType);\n  };\n})();\n\n\n\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n(function() {\n  var regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r\\n|\\n)((?:(?:[\\x21-\\x7E]+?):(?:(?:.*?\\\\\\r?\\n)*.*)(?:\\r\\n|\\n))*)((?:[A-Z0-9a-z\\/+=]+(?:\\r\\n|\\n))+)---- END SSH2 PUBLIC KEY ----$/;\n  var RE_HEADER = /^([\\x21-\\x7E]+?):((?:.*?\\\\\\r?\\n)*.*)$/gm;\n  var RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = function(str) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = header(s)\n    // m[2] = base64-encoded public key\n\n    var headers = m[1];\n    var data = Buffer.from(m[2], 'base64');\n    var comment = '';\n\n    if (headers !== undefined) {\n      while (m = RE_HEADER.exec(headers)) {\n        if (m[1].toLowerCase() === 'comment') {\n          comment = trimStart(m[2].replace(RE_HEADER_ENDS, ''));\n          if (comment.length > 1\n              && comment.charCodeAt(0) === 34/*'\"'*/\n              && comment.charCodeAt(comment.length - 1) === 34/*'\"'*/) {\n            comment = comment.slice(1, -1);\n          }\n        }\n      }\n    }\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var type = utils.readString(data, 0, 'ascii');\n    if (type === false)\n      return new Error('Malformed RFC4716 public key');\n\n    var pubPEM = null;\n    var pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa':\n        var e = utils.readString(data, data._pos);\n        if (e === false)\n          return new Error('Malformed RFC4716 public key');\n        var n = utils.readString(data, data._pos);\n        if (n === false)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        break;\n      case 'ssh-dss':\n        var p = utils.readString(data, data._pos);\n        if (p === false)\n          return new Error('Malformed RFC4716 public key');\n        var q = utils.readString(data, data._pos);\n        if (q === false)\n          return new Error('Malformed RFC4716 public key');\n        var g = utils.readString(data, data._pos);\n        if (g === false)\n          return new Error('Malformed RFC4716 public key');\n        var y = utils.readString(data, data._pos);\n        if (y === false)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        break;\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n})();\n\n\n\nmodule.exports = {\n  parseDERKey: function parseDERKey(data, type) {\n    return parseDER(data, type, '', type);\n  },\n  parseKey: function parseKey(data, passphrase) {\n    if (Buffer.isBuffer(data))\n      data = data.toString('utf8').trim();\n    else if (typeof data !== 'string')\n      return new Error('Key data must be a Buffer or string');\n    else\n      data = data.trim();\n\n    // intentional !=\n    if (passphrase != undefined) {\n      if (typeof passphrase === 'string')\n        passphrase = Buffer.from(passphrase);\n      else if (!Buffer.isBuffer(passphrase))\n        return new Error('Passphrase must be a string or Buffer when supplied');\n    }\n\n    var ret;\n\n    // Private keys\n    if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)\n      return ret;\n    if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)\n      return ret;\n    if ((ret = PPK_Private.parse(data, passphrase)) !== null)\n      return ret;\n\n    // Public keys\n    if ((ret = OpenSSH_Public.parse(data)) !== null)\n      return ret;\n    if ((ret = RFC4716_Public.parse(data)) !== null)\n      return ret;\n\n    return new Error('Unsupported key format');\n  }\n}\n","'use strict';\n\nvar inspect = require('util').inspect;\n\nfunction assert(value, message) {\n  if (!value)\n    throw new ERR_INTERNAL_ASSERTION(message);\n}\nassert.fail = function fail(message) {\n  throw new ERR_INTERNAL_ASSERTION(message);\n};\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  var res = '';\n  var i = val.length;\n  var start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3)\n    res = `_${val.slice(i - 3, i)}${res}`;\n  return `${val.slice(0, i)}${res}`;\n}\n\nfunction oneOf(expected, thing) {\n  assert(typeof thing === 'string', '`thing` has to be of type string');\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    assert(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or `\n              + expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n\n\nexports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {\n  constructor(message) {\n    super();\n    Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);\n\n    var suffix = 'This is caused by either a bug in ssh2-streams '\n                 + 'or incorrect usage of ssh2-streams internals.\\n'\n                 + 'Please open an issue with this stack trace at '\n                 + 'https://github.com/mscdex/ssh2-streams/issues\\n';\n\n    this.message = (message === undefined ? suffix : `${message}\\n${suffix}`);\n  }\n};\n\nvar MAX_32BIT_INT = Math.pow(2, 32);\nvar MAX_32BIT_BIGINT = (function() {\n  try {\n    return new Function('return 2n ** 32n')();\n  } catch (ex) {}\n})();\nexports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {\n  constructor(str, range, input, replaceDefaultBoolean) {\n    super();\n    Error.captureStackTrace(this, ERR_OUT_OF_RANGE);\n\n    assert(range, 'Missing \"range\" argument');\n    var msg = (replaceDefaultBoolean\n               ? str\n               : `The value of \"${str}\" is out of range.`);\n    var received;\n    if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)\n        received = addNumericalSeparator(received);\n      received += 'n';\n    } else {\n      received = inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n\n    this.message = msg;\n  }\n};\n\nexports.ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super();\n    Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);\n\n    assert(typeof name === 'string', `'name' must be a string`);\n\n    // determiner: 'must be' or 'must not be'\n    var determiner;\n    if (typeof expected === 'string' && expected.startsWith('not ')) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    var msg;\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n    } else {\n      var type = (name.includes('.') ? 'property' : 'argument');\n      msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n    }\n\n    msg += `. Received type ${typeof actual}`;\n\n    this.message = msg;\n  }\n};\n\nexports.validateNumber = function validateNumber(value, name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n};\n\n\n// =============================================================================\n// Following code is only needed to support node v6.x ....\n\n// Undocumented cb() API, needed for core, not for public API\nexports.destroyImpl = function destroy(err, cb) {\n  const readableDestroyed = this._readableState &&\n    this._readableState.destroyed;\n  const writableDestroyed = this._writableState &&\n    this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // If this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, (err) => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n\n  return this;\n};\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose)\n    return;\n  if (self._readableState && !self._readableState.emitClose)\n    return;\n  self.emit('close');\n}\n// =============================================================================\n","// TODO: support EXTENDED request packets\n\nvar TransformStream = require('stream').Transform;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\nvar constants = require('fs').constants || process.binding('constants');\nvar util = require('util');\nvar inherits = util.inherits;\nvar isDate = util.isDate;\nvar listenerCount = require('events').EventEmitter.listenerCount;\nvar fs = require('fs');\n\nvar readString = require('./utils').readString;\nvar readInt = require('./utils').readInt;\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\nvar ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\nvar STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nObject.keys(STATUS_CODE).forEach(function(key) {\n  STATUS_CODE[STATUS_CODE[key]] = key;\n});\nvar STATUS_CODE_STR = {\n  0: 'No error',\n  1: 'End of file',\n  2: 'No such file or directory',\n  3: 'Permission denied',\n  4: 'Failure',\n  5: 'Bad message',\n  6: 'No connection',\n  7: 'Connection lost',\n  8: 'Operation unsupported'\n};\nSFTPStream.STATUS_CODE = STATUS_CODE;\n\nvar REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nObject.keys(REQUEST).forEach(function(key) {\n  REQUEST[REQUEST[key]] = key;\n});\n\nvar RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nObject.keys(RESPONSE).forEach(function(key) {\n  RESPONSE[RESPONSE[key]] = key;\n});\n\nvar OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nSFTPStream.OPEN_MODE = OPEN_MODE;\n\nvar MAX_PKT_LEN = 34000;\nvar MAX_REQID = Math.pow(2, 32) - 1;\nvar CLIENT_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */,\n                                         REQUEST.INIT,\n                                         0, 0, 0, 3 /* version */]);\nvar SERVER_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */,\n                                         RESPONSE.VERSION,\n                                         0, 0, 0, 3 /* version */]);\n/*\n  http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02:\n\n     The maximum size of a packet is in practice determined by the client\n     (the maximum size of read or write requests that it sends, plus a few\n     bytes of packet overhead).  All servers SHOULD support packets of at\n     least 34000 bytes (where the packet size refers to the full length,\n     including the header above).  This should allow for reads and writes\n     of at most 32768 bytes.\n\n  OpenSSH caps this to 256kb instead of the ~34kb as mentioned in the sftpv3\n  spec.\n*/\nvar RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nvar OPENSSH_MAX_DATA_LEN = (256 * 1024) - (2 * 1024)/*account for header data*/;\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SFTPStream(cfg, remoteIdentRaw) {\n  if (typeof cfg === 'string' && !remoteIdentRaw) {\n    remoteIdentRaw = cfg;\n    cfg = undefined;\n  }\n  if (typeof cfg !== 'object' || !cfg)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server ? true : false);\n  this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n  this._needContinue = false;\n  this._state = {\n    // common\n    status: 'packet_header',\n    writeReqid: -1,\n    pktLeft: undefined,\n    pktHdrBuf: Buffer.allocUnsafe(9), // room for pktLen + pktType + req id\n    pktBuf: undefined,\n    pktType: undefined,\n    version: undefined,\n    extensions: {},\n\n    // client\n    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),\n    requests: {}\n  };\n\n  var self = this;\n  this.on('end', function() {\n    self.readable = false;\n  }).on('finish', onFinish)\n    .on('prefinish', onFinish);\n  function onFinish() {\n    self.writable = false;\n    self._cleanup(false);\n  }\n\n  if (!this.server)\n    this.push(CLIENT_VERSION_BUFFER);\n}\ninherits(SFTPStream, TransformStream);\n\nSFTPStream.prototype.__read = TransformStream.prototype._read;\nSFTPStream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSFTPStream.prototype.__push = TransformStream.prototype.push;\nSFTPStream.prototype.push = function(chunk, encoding) {\n  if (!this.readable)\n    return false;\n  if (chunk === null)\n    this.readable = false;\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSFTPStream.prototype._cleanup = function(callback) {\n  var state = this._state;\n\n  state.pktBuf = undefined; // give GC something to do\n\n  var requests = state.requests;\n  var keys = Object.keys(requests);\n  var len = keys.length;\n  if (len) {\n    if (this.readable) {\n      var err = new Error('SFTP session ended early');\n      for (var i = 0, cb; i < len; ++i)\n        (cb = requests[keys[i]].cb) && cb(err);\n    }\n    state.requests = {};\n  }\n\n  if (this.readable)\n    this.push(null);\n  if (!this._readableState.endEmitted && !this._readableState.flowing) {\n    // Ugh!\n    this.resume();\n  }\n  if (callback !== false) {\n    this.debug('DEBUG[SFTP]: Parser: Malformed packet');\n    callback && callback(new Error('Malformed packet'));\n  }\n};\n\nSFTPStream.prototype._transform = function(chunk, encoding, callback) {\n  var state = this._state;\n  var server = this.server;\n  var status = state.status;\n  var pktType = state.pktType;\n  var pktBuf = state.pktBuf;\n  var pktLeft = state.pktLeft;\n  var version = state.version;\n  var pktHdrBuf = state.pktHdrBuf;\n  var requests = state.requests;\n  var debug = this.debug;\n  var chunkLen = chunk.length;\n  var chunkPos = 0;\n  var buffer;\n  var chunkLeft;\n  var id;\n\n  while (true) {\n    if (status === 'discard') {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        status = 'packet_header';\n        buffer = pktBuf = undefined;\n      } else {\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (pktBuf !== undefined) {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunk.copy(pktBuf,\n                   pktBuf.length - pktLeft,\n                   chunkPos,\n                   chunkPos + pktLeft);\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        buffer = pktBuf;\n        pktBuf = undefined;\n        continue;\n      } else {\n        chunk.copy(pktBuf, pktBuf.length - pktLeft, chunkPos);\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (status === 'packet_header') {\n      if (!buffer) {\n        pktLeft = 5;\n        pktBuf = pktHdrBuf;\n      } else {\n        // here we read the right-most 5 bytes from buffer (pktHdrBuf)\n        pktLeft = readUInt32BE(buffer, 4) - 1; // account for type byte\n        pktType = buffer[8];\n\n        if (server) {\n          if (version === undefined && pktType !== REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected packet before init');\n            this._cleanup(false);\n            return callback(new Error('Unexpected packet before init'));\n          } else if (version !== undefined && pktType === REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected duplicate init');\n            status = 'bad_pkt';\n          } else if (pktLeft > MAX_PKT_LEN) {\n            var msg = 'Packet length ('\n                      + pktLeft\n                      + ') exceeds max length ('\n                      + MAX_PKT_LEN\n                      + ')';\n            debug('DEBUG[SFTP]: Parser: ' + msg);\n            this._cleanup(false);\n            return callback(new Error(msg));\n          } else if (pktType === REQUEST.EXTENDED) {\n            status = 'bad_pkt';\n          } else if (REQUEST[pktType] === undefined) {\n            debug('DEBUG[SFTP]: Parser: Unsupported packet type: ' + pktType);\n            status = 'discard';\n          }\n        } else if (version === undefined && pktType !== RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected packet before version');\n          this._cleanup(false);\n          return callback(new Error('Unexpected packet before version'));\n        } else if (version !== undefined && pktType === RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected duplicate version');\n          status = 'bad_pkt';\n        } else if (RESPONSE[pktType] === undefined) {\n          status = 'discard';\n        }\n\n        if (status === 'bad_pkt') {\n          // Copy original packet info to left of pktHdrBuf\n          writeUInt32BE(pktHdrBuf, pktLeft + 1, 0);\n          pktHdrBuf[4] = pktType;\n\n          pktLeft = 4;\n          pktBuf = pktHdrBuf;\n        } else {\n          pktBuf = Buffer.allocUnsafe(pktLeft);\n          status = 'payload';\n        }\n      }\n    } else if (status === 'payload') {\n      if (pktType === RESPONSE.VERSION || pktType === REQUEST.INIT) {\n        /*\n          uint32 version\n          <extension data>\n        */\n        version = state.version = readInt(buffer, 0, this, callback);\n        if (version === false)\n          return;\n        if (version < 3) {\n          this._cleanup(false);\n          return callback(new Error('Incompatible SFTP version: ' + version));\n        } else if (server)\n          this.push(SERVER_VERSION_BUFFER);\n\n        var buflen = buffer.length;\n        var extname;\n        var extdata;\n        buffer._pos = 4;\n        while (buffer._pos < buflen) {\n          extname = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extname === false)\n            return;\n          extdata = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extdata === false)\n            return;\n          if (state.extensions[extname])\n            state.extensions[extname].push(extdata);\n          else\n            state.extensions[extname] = [ extdata ];\n        }\n\n        this.emit('ready');\n      } else {\n        /*\n          All other packets (client and server) begin with a (client) request\n          id:\n          uint32     id\n        */\n        id = readInt(buffer, 0, this, callback);\n        if (id === false)\n          return;\n\n        var filename;\n        var attrs;\n        var handle;\n        var data;\n\n        if (!server) {\n          var req = requests[id];\n          var cb = req && req.cb;\n          debug('DEBUG[SFTP]: Parser: Response: ' + RESPONSE[pktType]);\n          if (req && cb) {\n            if (pktType === RESPONSE.STATUS) {\n              /*\n                uint32     error/status code\n                string     error message (ISO-10646 UTF-8)\n                string     language tag\n              */\n              var code = readInt(buffer, 4, this, callback);\n              if (code === false)\n                return;\n              if (code === STATUS_CODE.OK) {\n                cb();\n              } else {\n                // We borrow OpenSSH behavior here, specifically we make the\n                // message and language fields optional, despite the\n                // specification requiring them (even if they are empty). This\n                // helps to avoid problems with buggy implementations that do\n                // not fully conform to the SFTP(v3) specification.\n                var msg;\n                var lang = '';\n                if (buffer.length >= 12) {\n                  msg = readString(buffer, 8, 'utf8', this, callback);\n                  if (msg === false)\n                    return;\n                  if ((buffer._pos + 4) < buffer.length) {\n                    lang = readString(buffer,\n                                      buffer._pos,\n                                      'ascii',\n                                      this,\n                                      callback);\n                    if (lang === false)\n                      return;\n                  }\n                }\n                var err = new Error(msg\n                                    || STATUS_CODE_STR[code]\n                                    || 'Unknown status');\n                err.code = code;\n                err.lang = lang;\n                cb(err);\n              }\n            } else if (pktType === RESPONSE.HANDLE) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              cb(undefined, handle);\n            } else if (pktType === RESPONSE.DATA) {\n              /*\n                string     data\n              */\n              if (req.buffer) {\n                // we have already pre-allocated space to store the data\n                var dataLen = readInt(buffer, 4, this, callback);\n                if (dataLen === false)\n                  return;\n                var reqBufLen = req.buffer.length;\n                if (dataLen > reqBufLen) {\n                  // truncate response data to fit expected size\n                  writeUInt32BE(buffer, reqBufLen, 4);\n                }\n                data = readString(buffer, 4, req.buffer, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data, dataLen);\n              } else {\n                data = readString(buffer, 4, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data);\n              }\n            } else if (pktType === RESPONSE.NAME) {\n              /*\n                uint32     count\n                repeats count times:\n                        string     filename\n                        string     longname\n                        ATTRS      attrs\n              */\n              var namesLen = readInt(buffer, 4, this, callback);\n              if (namesLen === false)\n                return;\n              var names = [],\n                  longname;\n              buffer._pos = 8;\n              for (var i = 0; i < namesLen; ++i) {\n                // we are going to assume UTF-8 for filenames despite the SFTPv3\n                // spec not specifying an encoding because the specs for newer\n                // versions of the protocol all explicitly specify UTF-8 for\n                // filenames\n                filename = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (filename === false)\n                  return;\n                // `longname` only exists in SFTPv3 and since it typically will\n                // contain the filename, we assume it is also UTF-8\n                longname = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (longname === false)\n                  return;\n                attrs = readAttrs(buffer, buffer._pos, this, callback);\n                if (attrs === false)\n                  return;\n                names.push({\n                  filename: filename,\n                  longname: longname,\n                  attrs: attrs\n                });\n              }\n              cb(undefined, names);\n            } else if (pktType === RESPONSE.ATTRS) {\n              /*\n                ATTRS      attrs\n              */\n              attrs = readAttrs(buffer, 4, this, callback);\n              if (attrs === false)\n                return;\n              cb(undefined, attrs);\n            } else if (pktType === RESPONSE.EXTENDED) {\n              if (req.extended) {\n                switch (req.extended) {\n                  case 'statvfs@openssh.com':\n                  case 'fstatvfs@openssh.com':\n                    /*\n                      uint64    f_bsize   // file system block size\n                      uint64    f_frsize  // fundamental fs block size\n                      uint64    f_blocks  // number of blocks (unit f_frsize)\n                      uint64    f_bfree   // free blocks in file system\n                      uint64    f_bavail  // free blocks for non-root\n                      uint64    f_files   // total file inodes\n                      uint64    f_ffree   // free file inodes\n                      uint64    f_favail  // free file inodes for to non-root\n                      uint64    f_fsid    // file system id\n                      uint64    f_flag    // bit mask of f_flag values\n                      uint64    f_namemax // maximum filename length\n                    */\n                    var stats = {\n                      f_bsize: undefined,\n                      f_frsize: undefined,\n                      f_blocks: undefined,\n                      f_bfree: undefined,\n                      f_bavail: undefined,\n                      f_files: undefined,\n                      f_ffree: undefined,\n                      f_favail: undefined,\n                      f_sid: undefined,\n                      f_flag: undefined,\n                      f_namemax: undefined\n                    };\n                    stats.f_bsize = readUInt64BE(buffer, 4, this, callback);\n                    if (stats.f_bsize === false)\n                      return;\n                    stats.f_frsize = readUInt64BE(buffer, 12, this, callback);\n                    if (stats.f_frsize === false)\n                      return;\n                    stats.f_blocks = readUInt64BE(buffer, 20, this, callback);\n                    if (stats.f_blocks === false)\n                      return;\n                    stats.f_bfree = readUInt64BE(buffer, 28, this, callback);\n                    if (stats.f_bfree === false)\n                      return;\n                    stats.f_bavail = readUInt64BE(buffer, 36, this, callback);\n                    if (stats.f_bavail === false)\n                      return;\n                    stats.f_files = readUInt64BE(buffer, 44, this, callback);\n                    if (stats.f_files === false)\n                      return;\n                    stats.f_ffree = readUInt64BE(buffer, 52, this, callback);\n                    if (stats.f_ffree === false)\n                      return;\n                    stats.f_favail = readUInt64BE(buffer, 60, this, callback);\n                    if (stats.f_favail === false)\n                      return;\n                    stats.f_sid = readUInt64BE(buffer, 68, this, callback);\n                    if (stats.f_sid === false)\n                      return;\n                    stats.f_flag = readUInt64BE(buffer, 76, this, callback);\n                    if (stats.f_flag === false)\n                      return;\n                    stats.f_namemax = readUInt64BE(buffer, 84, this, callback);\n                    if (stats.f_namemax === false)\n                      return;\n                    cb(undefined, stats);\n                  break;\n                }\n              }\n              // XXX: at least provide the raw buffer data to the callback in\n              // case of unexpected extended response?\n              cb();\n            }\n          }\n          if (req)\n            delete requests[id];\n        } else {\n          // server\n          var evName = REQUEST[pktType];\n          var offset;\n          var path;\n\n          debug('DEBUG[SFTP]: Parser: Request: ' + evName);\n          if (listenerCount(this, evName)) {\n            if (pktType === REQUEST.OPEN) {\n              /*\n                string        filename\n                uint32        pflags\n                ATTRS         attrs\n              */\n              filename = readString(buffer, 4, 'utf8', this, callback);\n              if (filename === false)\n                return;\n              var pflags = readInt(buffer, buffer._pos, this, callback);\n              if (pflags === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos + 4, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, filename, pflags, attrs);\n            } else if (pktType === REQUEST.CLOSE\n                       || pktType === REQUEST.FSTAT\n                       || pktType === REQUEST.READDIR) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              this.emit(evName, id, handle);\n            } else if (pktType === REQUEST.READ) {\n              /*\n                string     handle\n                uint64     offset\n                uint32     len\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              var len = readInt(buffer, buffer._pos, this, callback);\n              if (len === false)\n                return;\n              this.emit(evName, id, handle, offset, len);\n            } else if (pktType === REQUEST.WRITE) {\n              /*\n                string     handle\n                uint64     offset\n                string     data\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              data = readString(buffer, buffer._pos, this, callback);\n              if (data === false)\n                return;\n              this.emit(evName, id, handle, offset, data);\n            } else if (pktType === REQUEST.LSTAT\n                       || pktType === REQUEST.STAT\n                       || pktType === REQUEST.OPENDIR\n                       || pktType === REQUEST.REMOVE\n                       || pktType === REQUEST.RMDIR\n                       || pktType === REQUEST.REALPATH\n                       || pktType === REQUEST.READLINK) {\n              /*\n                string     path\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              this.emit(evName, id, path);\n            } else if (pktType === REQUEST.SETSTAT\n                       || pktType === REQUEST.MKDIR) {\n              /*\n                string     path\n                ATTRS      attrs\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, path, attrs);\n            } else if (pktType === REQUEST.FSETSTAT) {\n              /*\n                string     handle\n                ATTRS      attrs\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, handle, attrs);\n            } else if (pktType === REQUEST.RENAME\n                       || pktType === REQUEST.SYMLINK) {\n              /*\n                RENAME:\n                  string     oldpath\n                  string     newpath\n                SYMLINK:\n                  string     linkpath\n                  string     targetpath\n              */\n              var str1;\n              var str2;\n              str1 = readString(buffer, 4, 'utf8', this, callback);\n              if (str1 === false)\n                return;\n              str2 = readString(buffer, buffer._pos, 'utf8', this, callback);\n              if (str2 === false)\n                return;\n              if (pktType === REQUEST.SYMLINK && this._isOpenSSH) {\n                // OpenSSH has linkpath and targetpath positions switched\n                this.emit(evName, id, str2, str1);\n              } else\n                this.emit(evName, id, str1, str2);\n            }\n          } else {\n            // automatically reject request if no handler for request type\n            this.status(id, STATUS_CODE.OP_UNSUPPORTED);\n          }\n        }\n      }\n\n      // prepare for next packet\n      status = 'packet_header';\n      buffer = pktBuf = undefined;\n    } else if (status === 'bad_pkt') {\n      if (server && buffer[4] !== REQUEST.INIT) {\n        var errCode = (buffer[4] === REQUEST.EXTENDED\n                       ? STATUS_CODE.OP_UNSUPPORTED\n                       : STATUS_CODE.FAILURE);\n\n        // no request id for init/version packets, so we have no way to send a\n        // status response, so we just close up shop ...\n        if (buffer[4] === REQUEST.INIT || buffer[4] === RESPONSE.VERSION)\n          return this._cleanup(callback);\n\n        id = readInt(buffer, 5, this, callback);\n        if (id === false)\n          return;\n        this.status(id, errCode);\n      }\n\n      // by this point we have already read the type byte and the id bytes, so\n      // we subtract those from the number of bytes to skip\n      pktLeft = readUInt32BE(buffer, 0) - 5;\n\n      status = 'discard';\n    }\n\n    if (chunkPos >= chunkLen)\n      break;\n  }\n\n  state.status = status;\n  state.pktType = pktType;\n  state.pktBuf = pktBuf;\n  state.pktLeft = pktLeft;\n  state.version = version;\n\n  callback();\n};\n\n// client\nSFTPStream.prototype.createReadStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new ReadStream(this, path, options);\n};\nSFTPStream.prototype.createWriteStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new WriteStream(this, path, options);\n};\nSFTPStream.prototype.open = function(path, flags_, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n\n  var flags = (typeof flags_ === 'number' ? flags_ : stringToFlags(flags_));\n  if (flags === null)\n    throw new Error('Unknown flags string: ' + flags_);\n\n  var attrFlags = 0;\n  var attrBytes = 0;\n  if (typeof attrs === 'string' || typeof attrs === 'number') {\n    attrs = { mode: attrs };\n  }\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    attrFlags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32        id\n    string        filename\n    uint32        pflags\n    ATTRS         attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.OPEN;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  writeUInt32BE(buf, attrFlags, p += 4);\n  if (attrs && attrFlags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPEN');\n  return this.push(buf);\n};\nSFTPStream.prototype.close = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.CLOSE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing CLOSE');\n  return this.push(buf);\n};\nSFTPStream.prototype.readData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off >= buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var pos = position;\n  var out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 8 + 4);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handlelen, p);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n\n  state.requests[reqid] = {\n    cb: function(err, data, nb) {\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)\n          return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      }\n      cb(undefined, nb || 0, data, position);\n    },\n    buffer: buf.slice(off, off + len)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READ');\n  return this.push(out);\n};\nSFTPStream.prototype.writeData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off > buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var self = this;\n  var state = this._state;\n\n  if (!len) {\n    cb && process.nextTick(function() { cb(undefined, 0); });\n    return;\n  }\n\n  var overflow = (len > state.maxDataLen\n                  ? len - state.maxDataLen\n                  : 0);\n  var origPosition = position;\n\n  if (overflow)\n    len = state.maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    string     data\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 8 + 4 + len);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.WRITE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handlelen, p);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = position & 0xFF;\n    position /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n  buf.copy(out, p += 4, off, off + len);\n\n  state.requests[reqid] = {\n    cb: function(err) {\n      if (err)\n        cb && cb(err);\n      else if (overflow) {\n        self.writeData(handle,\n                       buf,\n                       off + len,\n                       overflow,\n                       origPosition + len,\n                       cb);\n      } else\n        cb && cb(undefined, off + len);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing WRITE');\n  return this.push(out);\n};\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  var concurrency = 64;\n  var chunkSize = 32768;\n  //var preserve = false;\n  var onstep;\n  var mode;\n  var fileSize;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency))\n      concurrency = opts.concurrency;\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize))\n      chunkSize = opts.chunkSize;\n    if (typeof opts.fileSize === 'number'\n        && opts.fileSize > 0\n        && !isNaN(opts.fileSize))\n      fileSize = opts.fileSize;\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n    //preserve = (opts.preserve ? true : false);\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // internal state variables\n  var fsize;\n  var pdst = 0;\n  var total = 0;\n  var hadError = false;\n  var srcHandle;\n  var dstHandle;\n  var readbuf;\n  var bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    var left = 0;\n    var cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = function() {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.writable))\n        ++left;\n      if (dstHandle && (dst === fs || dst.writable))\n        ++left;\n      if (srcHandle && (src === fs || src.writable))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.writable))\n        dst.close(dstHandle, cbfinal);\n    } else\n      cb(err);\n  }\n\n  src.open(srcPath, 'r', function(err, sourceHandle) {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    if (fileSize === undefined)\n      src.fstat(srcHandle, tryStat);\n    else\n      tryStat(null, { size: fileSize });\n\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, function(err_, attrs_) {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', function(err, destHandle) {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod() for\n              // whatever reason\n              dst.chmod(dstPath, mode, function(err_) {\n                tryAgain();\n              });\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err)\n            return onerror(err);\n\n          datapos = datapos || 0;\n\n          if (src === fs)\n            dst.writeData(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n          else\n            dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (nb < origChunkLen)\n              return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n\n            if (total === fsize) {\n              dst.close(dstHandle, function(err) {\n                dstHandle = undefined;\n                if (err)\n                  return onerror(err);\n                src.close(srcHandle, function(err) {\n                  srcHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n\n            if (pdst >= fsize)\n              return;\n\n            var chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n\n        function makeCb(psrc, pdst, chunk) {\n          return function(err, nb, data) {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n\n        function singleRead(psrc, pdst, chunk) {\n          if (src === fs) {\n            src.read(srcHandle,\n                     readbuf,\n                     psrc,\n                     chunk,\n                     pdst,\n                     makeCb(psrc, pdst, chunk));\n          } else {\n            src.readData(srcHandle,\n                         readbuf,\n                         psrc,\n                         chunk,\n                         pdst,\n                         makeCb(psrc, pdst, chunk));\n          }\n        }\n\n        function startReads() {\n          var reads = 0;\n          var psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            var chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\nSFTPStream.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(this, fs, remotePath, localPath, opts, cb);\n};\nSFTPStream.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(fs, this, localPath, remotePath, opts, cb);\n};\nSFTPStream.prototype.readFile = function(path, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, flag: 'r' };\n  else if (!options)\n    options = { encoding: null, flag: 'r' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  var encoding = options.encoding;\n  if (encoding && !Buffer.isEncoding(encoding))\n    throw new Error('Unknown encoding: ' + encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var handle;\n\n  // SFTPv3 does not support using -1 for read position, so we have to track\n  // read position manually\n  var bytesRead = 0;\n\n  var flag = options.flag || 'r';\n  this.open(path, flag, 438 /*=0666*/, function(er, handle_) {\n    if (er)\n      return callback && callback(er);\n    handle = handle_;\n\n    self.fstat(handle, function tryStat(er, st) {\n      if (er) {\n        // Try stat() for sftp servers that may not support fstat() for\n        // whatever reason\n        self.stat(path, function(er_, st_) {\n          if (er_) {\n            return self.close(handle, function() {\n              callback && callback(er);\n            });\n          }\n          tryStat(null, st_);\n        });\n        return;\n      }\n\n      size = st.size || 0;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      buffer = Buffer.allocUnsafe(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = Buffer.allocUnsafe(8192);\n      self.readData(handle, buffer, 0, 8192, bytesRead, afterRead);\n    } else {\n      self.readData(handle, buffer, pos, size - pos, bytesRead, afterRead);\n    }\n  }\n\n  function afterRead(er, nbytes) {\n    var eof;\n    if (er) {\n      eof = (er.code === STATUS_CODE.EOF);\n      if (!eof) {\n        return self.close(handle, function() {\n          return callback && callback(er);\n        });\n      }\n    } else {\n      eof = false;\n    }\n\n    if (eof || (size === 0 && nbytes === 0))\n      return close();\n\n    bytesRead += nbytes;\n    pos += nbytes;\n    if (size !== 0) {\n      if (pos === size)\n        close();\n      else\n        read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, nbytes));\n      read();\n    }\n  }\n  afterRead._wantEOFError = true;\n\n  function close() {\n    self.close(handle, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size) {\n        buffer = buffer.slice(0, pos);\n      }\n\n      if (encoding)\n        buffer = buffer.toString(encoding);\n      return callback && callback(er, buffer);\n    });\n  }\n};\nfunction writeAll(self, handle, buffer, offset, length, position, callback_) {\n  var callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  self.writeData(handle,\n                 buffer,\n                 offset,\n                 length,\n                 position,\n                 function(writeErr, written) {\n    if (writeErr) {\n      return self.close(handle, function() {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length)\n      self.close(handle, callback);\n    else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(self, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nSFTPStream.prototype.writeFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'w' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (options.encoding && !Buffer.isEncoding(options.encoding))\n    throw new Error('Unknown encoding: ' + options.encoding);\n\n  var flag = options.flag || 'w';\n  this.open(path, flag, options.mode, function(openErr, handle) {\n    if (openErr)\n      callback && callback(openErr);\n    else {\n      var buffer = (Buffer.isBuffer(data)\n                    ? data\n                    : Buffer.from('' + data, options.encoding || 'utf8'));\n      var position = (/a/.test(flag) ? null : 0);\n\n      // SFTPv3 does not support the notion of 'current position'\n      // (null position), so we just attempt to append to the end of the file\n      // instead\n      if (position === null) {\n        self.fstat(handle, function tryStat(er, st) {\n          if (er) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.stat(path, function(er_, st_) {\n              if (er_) {\n                return self.close(handle, function() {\n                  callback && callback(er);\n                });\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          writeAll(self, handle, buffer, 0, buffer.length, st.size, callback);\n        });\n        return;\n      }\n      writeAll(self, handle, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\nSFTPStream.prototype.appendFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'a' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  this.writeFile(path, data, options, callback);\n};\nSFTPStream.prototype.exists = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  this.stat(path, function(err) {\n    cb && cb(err ? false : true);\n  });\n};\nSFTPStream.prototype.unlink = function(filename, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     filename\n  */\n  var fnamelen = Buffer.byteLength(filename);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnamelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.REMOVE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, fnamelen, p);\n  buf.write(filename, p += 4, fnamelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REMOVE');\n  return this.push(buf);\n};\nSFTPStream.prototype.rename = function(oldPath, newPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     oldpath\n    string     newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.RENAME;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, oldlen, p);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RENAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.mkdir = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.MKDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing MKDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.rmdir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.RMDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RMDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.readdir = function(where, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n  var doFilter;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof opts !== 'object' || opts === null)\n    opts = {};\n\n  doFilter = (opts && opts.full ? false : true);\n\n  if (!Buffer.isBuffer(where) && typeof where !== 'string')\n    throw new Error('missing directory handle or path');\n\n  if (typeof where === 'string') {\n    var self = this;\n    var entries = [];\n    var e = 0;\n\n    return this.opendir(where, function reread(err, handle) {\n      if (err)\n        return cb(err);\n\n      self.readdir(handle, opts, function(err, list) {\n        var eof = (err && err.code === STATUS_CODE.EOF);\n\n        if (err && !eof) {\n          return self.close(handle, function() {\n            cb(err);\n          });\n        } else if (eof) {\n          return self.close(handle, function(err) {\n            if (err)\n              return cb(err);\n            cb(undefined, entries);\n          });\n        }\n\n        for (var i = 0, len = list.length; i < len; ++i, ++e)\n          entries[e] = list[i];\n\n        reread(undefined, handle);\n      });\n    });\n  }\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = where.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.READDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  where.copy(buf, p += 4);\n\n  state.requests[reqid] = {\n    cb: (doFilter\n         ? function(err, list) {\n             if (err)\n               return cb(err);\n\n             for (var i = list.length - 1; i >= 0; --i) {\n               if (list[i].filename === '.' || list[i].filename === '..')\n                 list.splice(i, 1);\n             }\n\n             cb(undefined, list);\n           }\n         : cb)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.fstat = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.FSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.stat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.STAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.lstat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.LSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing LSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.opendir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.OPENDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPENDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.setstat = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.SETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.fsetstat = function(handle, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     handle\n    ATTRS      attrs\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.FSETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n  writeUInt32BE(buf, flags, p += handlelen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this.fsetstat(handle, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.utimes = function(path, atime, mtime, cb) {\n  return this.setstat(path, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.fchown = function(handle, uid, gid, cb) {\n  return this.fsetstat(handle, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.chown = function(path, uid, gid, cb) {\n  return this.setstat(path, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.fchmod = function(handle, mode, cb) {\n  return this.fsetstat(handle, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.chmod = function(path, mode, cb) {\n  return this.setstat(path, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.readlink = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.READLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing link info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.symlink = function(targetPath, linkPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     linkpath\n    string     targetpath\n  */\n  var linklen = Buffer.byteLength(linkPath);\n  var targetlen = Buffer.byteLength(targetPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linklen + 4 + targetlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.SYMLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  if (this._isOpenSSH) {\n    // OpenSSH has linkpath and targetpath positions switched\n    writeUInt32BE(buf, targetlen, p);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n    writeUInt32BE(buf, linklen, p += targetlen);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n  } else {\n    writeUInt32BE(buf, linklen, p);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n    writeUInt32BE(buf, targetlen, p += linklen);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SYMLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.realpath = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.REALPATH;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing path info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REALPATH');\n  return this.push(buf);\n};\n// extended requests\nSFTPStream.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['posix-rename@openssh.com']\n           || state.extensions['posix-rename@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"posix-rename@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 24, p);\n  buf.write('posix-rename@openssh.com', p += 4, 24, 'ascii');\n\n  writeUInt32BE(buf, oldlen, p += 24);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing posix-rename@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_statvfs = function(path, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['statvfs@openssh.com']\n           || state.extensions['statvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"statvfs@openssh.com\"\n    string    path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 19, p);\n  buf.write('statvfs@openssh.com', p += 4, 19, 'ascii');\n\n  writeUInt32BE(buf, pathlen, p += 19);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'statvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing statvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fstatvfs@openssh.com']\n           || state.extensions['fstatvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fstatvfs@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 20, p);\n  buf.write('fstatvfs@openssh.com', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, handlelen, p += 20);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'fstatvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fstatvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['hardlink@openssh.com']\n           || state.extensions['hardlink@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"hardlink@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 20, p);\n  buf.write('hardlink@openssh.com', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, oldlen, p += 20);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing hardlink@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fsync = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fsync@openssh.com']\n           || state.extensions['fsync@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fsync@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 17, p);\n  buf.write('fsync@openssh.com', p += 4, 17, 'ascii');\n\n  writeUInt32BE(buf, handlelen, p += 17);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fsync@openssh.com');\n  return this.push(buf);\n};\n\n// server\nSFTPStream.prototype.status = function(id, code, message, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!STATUS_CODE[code] || typeof code !== 'number')\n    throw new Error('Bad status code: ' + code);\n\n  message || (message = '');\n  lang || (lang = '');\n\n  var msgLen = Buffer.byteLength(message);\n  var langLen = Buffer.byteLength(lang);\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4 + langLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.STATUS;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, code, 9);\n\n  writeUInt32BE(buf, msgLen, 13);\n  if (msgLen)\n    buf.write(message, 17, msgLen, 'utf8');\n\n  writeUInt32BE(buf, langLen, 17 + msgLen);\n  if (langLen)\n    buf.write(lang, 17 + msgLen + 4, langLen, 'ascii');\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STATUS');\n  return this.push(buf);\n};\nSFTPStream.prototype.handle = function(id, handle) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var handleLen = handle.length;\n\n  if (handleLen > 256)\n    throw new Error('handle too large (> 256 bytes)');\n\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.HANDLE;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, handleLen, 9);\n  if (handleLen)\n    handle.copy(buf, 13);\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing HANDLE');\n  return this.push(buf);\n};\nSFTPStream.prototype.data = function(id, data, encoding) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var isBuffer = Buffer.isBuffer(data);\n\n  if (!isBuffer && typeof data !== 'string')\n    throw new Error('data is not a Buffer or string');\n\n  if (!isBuffer)\n    encoding || (encoding = 'utf8');\n\n  var dataLen = (isBuffer ? data.length : Buffer.byteLength(data, encoding));\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.DATA;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, dataLen, 9);\n  if (dataLen) {\n    if (isBuffer)\n      data.copy(buf, 13);\n    else\n      buf.write(data, 13, dataLen, encoding);\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing DATA');\n  return this.push(buf);\n};\nSFTPStream.prototype.name = function(id, names) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Array.isArray(names)) {\n    if (typeof names !== 'object' || names === null)\n      throw new Error('names is not an object or array');\n    names = [ names ];\n  }\n\n  var count = names.length;\n  var namesLen = 0;\n  var nameAttrs;\n  var attrs = [];\n  var name;\n  var filename;\n  var longname;\n  var attr;\n  var len;\n  var len2;\n  var buf;\n  var p;\n  var i;\n  var j;\n  var k;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    namesLen += 4 + Buffer.byteLength(filename);\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    namesLen += 4 + Buffer.byteLength(longname);\n\n    if (typeof name.attrs === 'object' && name.attrs !== null) {\n      nameAttrs = attrsToBytes(name.attrs);\n      namesLen += 4 + nameAttrs.nbytes;\n      attrs.push(nameAttrs);\n    } else {\n      namesLen += 4;\n      attrs.push(null);\n    }\n  }\n\n  buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.NAME;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, count, 9);\n\n  p = 13;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    len = Buffer.byteLength(filename);\n    writeUInt32BE(buf, len, p);\n    p += 4;\n    if (len) {\n      buf.write(filename, p, len, 'utf8');\n      p += len;\n    }\n\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    len = Buffer.byteLength(longname);\n    writeUInt32BE(buf, len, p);\n    p += 4;\n    if (len) {\n      buf.write(longname, p, len, 'utf8');\n      p += len;\n    }\n\n    attr = attrs[i];\n    if (attr) {\n      writeUInt32BE(buf, attr.flags, p);\n      p += 4;\n      if (attr.flags && attr.bytes) {\n        var bytes = attr.bytes;\n        for (j = 0, len = bytes.length; j < len; ++j)\n          for (k = 0, len2 = bytes[j].length; k < len2; ++k)\n            buf[p++] = bytes[j][k];\n      }\n    } else {\n      writeUInt32BE(buf, 0, p);\n      p += 4;\n    }\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing NAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.attrs = function(id, attrs) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (typeof attrs !== 'object' || attrs === null)\n    throw new Error('attrs is not an object');\n\n  var info = attrsToBytes(attrs);\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + info.nbytes);\n  var p = 13;\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.ATTRS;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, info.flags, 9);\n\n  if (info.flags && info.bytes) {\n    var bytes = info.bytes;\n    for (var j = 0, len = bytes.length; j < len; ++j)\n      for (var k = 0, len2 = bytes[j].length; k < len2; ++k)\n        buf[p++] = bytes[j][k];\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing ATTRS');\n  return this.push(buf);\n};\n\nfunction readAttrs(buf, p, stream, callback) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  var flags = readUInt32BE(buf, p);\n  var attrs = new Stats();\n\n  p += 4;\n\n  if (flags & ATTR.SIZE) {\n    var size = readUInt64BE(buf, p, stream, callback);\n    if (size === false)\n      return false;\n    attrs.size = size;\n    p += 8;\n  }\n  if (flags & ATTR.UIDGID) {\n    var uid;\n    var gid;\n    uid = readInt(buf, p, this, callback);\n    if (uid === false)\n      return false;\n    attrs.uid = uid;\n    p += 4;\n    gid = readInt(buf, p, this, callback);\n    if (gid === false)\n      return false;\n    attrs.gid = gid;\n    p += 4;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    var mode = readInt(buf, p, this, callback);\n    if (mode === false)\n      return false;\n    attrs.mode = mode;\n    // backwards compatibility\n    attrs.permissions = mode;\n    p += 4;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    var atime;\n    var mtime;\n    atime = readInt(buf, p, this, callback);\n    if (atime === false)\n      return false;\n    attrs.atime = atime;\n    p += 4;\n    mtime = readInt(buf, p, this, callback);\n    if (mtime === false)\n      return false;\n    attrs.mtime = mtime;\n    p += 4;\n  }\n  if (flags & ATTR.EXTENDED) {\n    // TODO: read/parse extended data\n    var extcount = readInt(buf, p, this, callback);\n    if (extcount === false)\n      return false;\n    p += 4;\n    for (var i = 0, len; i < extcount; ++i) {\n      len = readInt(buf, p, this, callback);\n      if (len === false)\n        return false;\n      p += 4 + len;\n    }\n  }\n\n  buf._pos = p;\n\n  return attrs;\n}\n\nfunction readUInt64BE(buffer, p, stream, callback) {\n  if ((buffer.length - p) < 8) {\n    stream && stream._cleanup(callback);\n    return false;\n  }\n\n  var val = 0;\n\n  for (var len = p + 8; p < len; ++p) {\n    val *= 256;\n    val += buffer[p];\n  }\n\n  buffer._pos = p;\n\n  return val;\n}\n\nfunction attrsToBytes(attrs) {\n  var flags = 0;\n  var attrBytes = 0;\n  var ret = [];\n  var i = 0;\n\n  if (typeof attrs !== 'object' || attrs === null)\n    return { flags: flags, nbytes: attrBytes, bytes: ret };\n\n  if (typeof attrs.size === 'number') {\n    flags |= ATTR.SIZE;\n    attrBytes += 8;\n    var sizeBytes = new Array(8);\n    var val = attrs.size;\n    for (i = 7; i >= 0; --i) {\n      sizeBytes[i] = val & 0xFF;\n      val /= 256;\n    }\n    ret.push(sizeBytes);\n  }\n  if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n    flags |= ATTR.UIDGID;\n    attrBytes += 8;\n    ret.push([(attrs.uid >> 24) & 0xFF, (attrs.uid >> 16) & 0xFF,\n              (attrs.uid >> 8) & 0xFF, attrs.uid & 0xFF]);\n    ret.push([(attrs.gid >> 24) & 0xFF, (attrs.gid >> 16) & 0xFF,\n              (attrs.gid >> 8) & 0xFF, attrs.gid & 0xFF]);\n  }\n  if (typeof attrs.permissions === 'number'\n      || typeof attrs.permissions === 'string'\n      || typeof attrs.mode === 'number'\n      || typeof attrs.mode === 'string') {\n    var mode = modeNum(attrs.mode || attrs.permissions);\n    flags |= ATTR.PERMISSIONS;\n    attrBytes += 4;\n    ret.push([(mode >> 24) & 0xFF,\n              (mode >> 16) & 0xFF,\n              (mode >> 8) & 0xFF,\n              mode & 0xFF]);\n  }\n  if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n      && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n    var atime = toUnixTimestamp(attrs.atime);\n    var mtime = toUnixTimestamp(attrs.mtime);\n\n    flags |= ATTR.ACMODTIME;\n    attrBytes += 8;\n    ret.push([(atime >> 24) & 0xFF, (atime >> 16) & 0xFF,\n              (atime >> 8) & 0xFF, atime & 0xFF]);\n    ret.push([(mtime >> 24) & 0xFF, (mtime >> 16) & 0xFF,\n              (mtime >> 8) & 0xFF, mtime & 0xFF]);\n  }\n  // TODO: extended attributes\n\n  return { flags: flags, nbytes: attrBytes, bytes: ret };\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number' && !isNaN(time))\n    return time;\n  else if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error('Cannot parse time: ' + time);\n}\n\nfunction modeNum(mode) {\n  if (typeof mode === 'number' && !isNaN(mode))\n    return mode;\n  else if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error('Cannot parse mode: ' + mode);\n}\n\nvar stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\nvar stringFlagMapKeys = Object.keys(stringFlagMap);\n\nfunction stringToFlags(str) {\n  var flags = stringFlagMap[str];\n  if (flags !== undefined)\n    return flags;\n  return null;\n}\nSFTPStream.stringToFlags = stringToFlags;\n\nfunction flagsToString(flags) {\n  for (var i = 0; i < stringFlagMapKeys.length; ++i) {\n    var key = stringFlagMapKeys[i];\n    if (stringFlagMap[key] === flags)\n      return key;\n  }\n  return null;\n}\nSFTPStream.flagsToString = flagsToString;\n\nfunction Stats(initial) {\n  this.mode = (initial && initial.mode);\n  this.permissions = this.mode; // backwards compatiblity\n  this.uid = (initial && initial.uid);\n  this.gid = (initial && initial.gid);\n  this.size = (initial && initial.size);\n  this.atime = (initial && initial.atime);\n  this.mtime = (initial && initial.mtime);\n}\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\nSFTPStream.Stats = Stats;\n\n// =============================================================================\n// ReadStream/WriteStream-related\nvar fsCompat = require('./node-fs-compat');\nvar validateNumber = fsCompat.validateNumber;\nvar destroyImpl = fsCompat.destroyImpl;\nvar ERR_OUT_OF_RANGE = fsCompat.ERR_OUT_OF_RANGE;\nvar ERR_INVALID_ARG_TYPE = fsCompat.ERR_INVALID_ARG_TYPE;\n\nvar kMinPoolSpace = 128;\n\nvar pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nvar poolFragments = [];\n\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0)\n    pool = poolFragments.pop();\n  else\n    pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0)\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\n\nfunction roundUpToMultipleOf8(n) {\n  return (n + 7) & ~7;  // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.closed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\n        'start',\n        `<= \"end\" (here: ${this.end})`,\n        this.start\n      );\n    }\n  }\n\n  this.on('end', function() {\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // start the flow of data.\n    this.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._read(n);\n    });\n  }\n\n  // XXX: safe to remove this?\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    allocNewPool(this.readableHighWaterMark\n                 || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  this.sftp.readData(this.handle,\n                     pool,\n                     pool.used,\n                     toRead,\n                     this.pos,\n                     (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n    var b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      var newUsed = thisPool.used + bytesRead - toRead;\n      thisPool.used = roundUpToMultipleOf8(newUsed);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      var alignedEnd = (start + toRead) & ~7;\n      var alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace)\n        poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n\n    this.push(b);\n  });\n\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\n\nif (typeof ReadableStream.prototype.destroy !== 'function')\n  ReadStream.prototype.destroy = destroyImpl;\n\nReadStream.prototype._destroy = function(err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\n\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle)\n    return onclose();\n\n  stream.sftp.close(stream.handle, onclose);\n\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.closed = true;\n    if (!er)\n      stream.emit('close');\n  }\n}\n\nReadStream.prototype.close = function(cb) {\n  this.destroy(null, cb);\n};\n\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() { return this.handle === null; },\n  configurable: true\n});\n\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.closed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function() {\n    if (this._writableState.finalCalled)\n      return;\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype._final = function(cb) {\n  if (this.autoClose)\n    this.destroy();\n  cb();\n};\n\nWriteStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n\n    var tryAgain = (err) => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, (err_) => {\n          tryAgain();\n        });\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        var tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  this.sftp.writeData(this.handle,\n                      data,\n                      0,\n                      data.length,\n                      this.pos,\n                      (er, bytes) => {\n    if (er) {\n      if (this.autoClose)\n        this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  var sftp = this.sftp;\n  var handle = this.handle;\n  var writesLeft = data.length;\n\n  var onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server\n  for (var i = 0; i < data.length; ++i) {\n    var chunk = data[i].chunk;\n\n    sftp.writeData(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\n\nif (typeof WritableStream.prototype.destroy !== 'function')\n  WriteStream.prototype.destroy = ReadStream.prototype.destroy;\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.closed) {\n      process.nextTick(cb);\n      return;\n    } else {\n      this.on('close', cb);\n    }\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose)\n    this.on('finish', this.destroy.bind(this));\n\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() { return this.handle === null; },\n  configurable: true\n});\n\nmodule.exports = SFTPStream;\n\n","// TODO: * Automatic re-key every (configurable) n bytes or length of time\n//         - RFC suggests every 1GB of transmitted data or 1 hour, whichever\n//           comes sooner\n//       * Filter control codes from strings\n//         (as per http://tools.ietf.org/html/rfc4251#section-9.2)\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\nvar TransformStream = require('stream').Transform;\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\n\nvar StreamSearch = require('streamsearch');\nvar Ber = require('asn1').Ber;\n\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\nvar consts = require('./constants');\nvar utils = require('./utils');\nvar iv_inc = utils.iv_inc;\nvar readString = utils.readString;\nvar readInt = utils.readInt;\nvar DSASigBERToBare = utils.DSASigBERToBare;\nvar ECDSASigASN1ToSSH = utils.ECDSASigASN1ToSSH;\nvar sigSSHToASN1 = utils.sigSSHToASN1;\nvar parseDERKey = require('./keyParser').parseDERKey;\n\nvar CIPHER_INFO = consts.CIPHER_INFO;\nvar HMAC_INFO = consts.HMAC_INFO;\nvar MESSAGE = consts.MESSAGE;\nvar DYNAMIC_KEXDH_MESSAGE = consts.DYNAMIC_KEXDH_MESSAGE;\nvar KEXDH_MESSAGE = consts.KEXDH_MESSAGE;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar SSH_TO_OPENSSL = consts.SSH_TO_OPENSSL;\nvar TERMINAL_MODE = consts.TERMINAL_MODE;\nvar SIGNALS = consts.SIGNALS;\nvar EDDSA_SUPPORTED = consts.EDDSA_SUPPORTED;\nvar CURVE25519_SUPPORTED = consts.CURVE25519_SUPPORTED;\nvar BUGS = consts.BUGS;\nvar BUGGY_IMPLS = consts.BUGGY_IMPLS;\nvar BUGGY_IMPLS_LEN = BUGGY_IMPLS.length;\nvar MODULE_VER = require('../package.json').version;\nvar I = 0;\nvar IN_INIT = I++;\nvar IN_GREETING = I++;\nvar IN_HEADER = I++;\nvar IN_PACKETBEFORE = I++;\nvar IN_PACKET = I++;\nvar IN_PACKETDATA = I++;\nvar IN_PACKETDATAVERIFY = I++;\nvar IN_PACKETDATAAFTER = I++;\nvar OUT_INIT = I++;\nvar OUT_READY = I++;\nvar OUT_REKEYING = I++;\nvar MAX_SEQNO = 4294967295;\nvar MAX_PACKET_SIZE = 35000;\nvar MAX_PACKETS_REKEYING = 50;\nvar EXP_TYPE_HEADER = 0;\nvar EXP_TYPE_LF = 1;\nvar EXP_TYPE_BYTES = 2; // Waits until n bytes have been seen\nvar Z_PARTIAL_FLUSH = zlib.Z_PARTIAL_FLUSH;\nvar ZLIB_OPTS = { flush: Z_PARTIAL_FLUSH };\n\nvar RE_NULL = /\\x00/g;\n\nvar IDENT_PREFIX_BUFFER = Buffer.from('SSH-');\nvar EMPTY_BUFFER = Buffer.allocUnsafe(0);\nvar HMAC_COMPUTE = Buffer.allocUnsafe(9);\nvar PING_PACKET = Buffer.from([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1\n]);\nvar NEWKEYS_PACKET = Buffer.from([MESSAGE.NEWKEYS]);\nvar USERAUTH_SUCCESS_PACKET = Buffer.from([MESSAGE.USERAUTH_SUCCESS]);\nvar REQUEST_SUCCESS_PACKET = Buffer.from([MESSAGE.REQUEST_SUCCESS]);\nvar REQUEST_FAILURE_PACKET = Buffer.from([MESSAGE.REQUEST_FAILURE]);\nvar NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\nvar KEXDH_GEX_REQ_PACKET = Buffer.from([\n  MESSAGE.KEXDH_GEX_REQUEST,\n  // Minimal size in bits of an acceptable group\n  0, 0, 4, 0, // 1024, modp2\n  // Preferred size in bits of the group the server will send\n  0, 0, 16, 0, // 4096, modp16\n  // Maximal size in bits of an acceptable group\n  0, 0, 32, 0 // 8192, modp18\n]);\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SSH2Stream(cfg) {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this._needContinue = false;\n  this.bytesSent = this.bytesReceived = 0;\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server === true);\n  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'\n                        ? cfg.maxPacketSize\n                        : MAX_PACKET_SIZE);\n  // Bitmap that indicates any bugs the remote side has. This is determined\n  // by the reported software version.\n  this.remoteBugs = 0;\n\n  if (this.server) {\n    // TODO: Remove when we support group exchange for server implementation\n    this.remoteBugs = BUGS.BAD_DHGEX;\n  }\n\n  this.readable = true;\n\n  var self = this;\n\n  var hostKeys = cfg.hostKeys;\n  if (this.server && (typeof hostKeys !== 'object' || hostKeys === null))\n    throw new Error('hostKeys must be an object keyed on host key type');\n\n  this.config = {\n    // Server\n    hostKeys: hostKeys, // All keys supported by server\n\n    // Client/Server\n    ident: 'SSH-2.0-'\n           + (cfg.ident\n              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),\n    algorithms: {\n      kex: ALGORITHMS.KEX,\n      kexBuf: ALGORITHMS.KEX_BUF,\n      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,\n      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,\n      cipher: ALGORITHMS.CIPHER,\n      cipherBuf: ALGORITHMS.CIPHER_BUF,\n      hmac: ALGORITHMS.HMAC,\n      hmacBuf: ALGORITHMS.HMAC_BUF,\n      compress: ALGORITHMS.COMPRESS,\n      compressBuf: ALGORITHMS.COMPRESS_BUF\n    }\n  };\n  // RFC 4253 states the identification string must not contain NULL\n  this.config.ident.replace(RE_NULL, '');\n\n  if (this.config.ident.length + 2 /* Account for \"\\r\\n\" */ > 255)\n    throw new Error('ident too long');\n\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algos = cfg.algorithms;\n    if (Array.isArray(algos.kex) && algos.kex.length > 0) {\n      this.config.algorithms.kex = algos.kex;\n      if (!Buffer.isBuffer(algos.kexBuf))\n        algos.kexBuf = Buffer.from(algos.kex.join(','), 'ascii');\n      this.config.algorithms.kexBuf = algos.kexBuf;\n    }\n    if (Array.isArray(algos.serverHostKey) && algos.serverHostKey.length > 0) {\n      this.config.algorithms.serverHostKey = algos.serverHostKey;\n      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {\n        algos.serverHostKeyBuf = Buffer.from(algos.serverHostKey.join(','),\n                                             'ascii');\n      }\n      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;\n    }\n    if (Array.isArray(algos.cipher) && algos.cipher.length > 0) {\n      this.config.algorithms.cipher = algos.cipher;\n      if (!Buffer.isBuffer(algos.cipherBuf))\n        algos.cipherBuf = Buffer.from(algos.cipher.join(','), 'ascii');\n      this.config.algorithms.cipherBuf = algos.cipherBuf;\n    }\n    if (Array.isArray(algos.hmac) && algos.hmac.length > 0) {\n      this.config.algorithms.hmac = algos.hmac;\n      if (!Buffer.isBuffer(algos.hmacBuf))\n        algos.hmacBuf = Buffer.from(algos.hmac.join(','), 'ascii');\n      this.config.algorithms.hmacBuf = algos.hmacBuf;\n    }\n    if (Array.isArray(algos.compress) && algos.compress.length > 0) {\n      this.config.algorithms.compress = algos.compress;\n      if (!Buffer.isBuffer(algos.compressBuf))\n        algos.compressBuf = Buffer.from(algos.compress.join(','), 'ascii');\n      this.config.algorithms.compressBuf = algos.compressBuf;\n    }\n  }\n\n  this.reset(true);\n\n  // Common events\n  this.on('end', function() {\n    // Let GC collect any Buffers we were previously storing\n    self.readable = false;\n    self._state = undefined;\n    self.reset();\n    self._state.outgoing.bufSeqno = undefined;\n  });\n  this.on('DISCONNECT', function(reason, code, desc, lang) {\n    onDISCONNECT(self, reason, code, desc, lang);\n  });\n  this.on('KEXINIT', function(init, firstFollows) {\n    onKEXINIT(self, init, firstFollows);\n  });\n  this.on('NEWKEYS', function() { onNEWKEYS(self); });\n\n  if (this.server) {\n    // Server-specific events\n    this.on('KEXDH_INIT', function(e) { onKEXDH_INIT(self, e); });\n  } else {\n    // Client-specific events\n    this.on('KEXDH_REPLY', function(info) { onKEXDH_REPLY(self, info); })\n        .on('KEXDH_GEX_GROUP',\n            function(prime, gen) { onKEXDH_GEX_GROUP(self, prime, gen); });\n  }\n\n  if (this.server) {\n    // Greeting displayed before the ssh identification string is sent, this is\n    // usually ignored by most clients\n    if (typeof cfg.greeting === 'string' && cfg.greeting.length) {\n      if (cfg.greeting.slice(-2) === '\\r\\n')\n        this.push(cfg.greeting);\n      else\n        this.push(cfg.greeting + '\\r\\n');\n    }\n    // Banner shown after the handshake completes, but before user\n    // authentication begins\n    if (typeof cfg.banner === 'string' && cfg.banner.length) {\n      if (cfg.banner.slice(-2) === '\\r\\n')\n        this.banner = cfg.banner;\n      else\n        this.banner = cfg.banner + '\\r\\n';\n    }\n  }\n  this.debug('DEBUG: Local ident: ' + inspect(this.config.ident));\n  this.push(this.config.ident + '\\r\\n');\n\n  this._state.incoming.expectedPacket = 'KEXINIT';\n}\ninherits(SSH2Stream, TransformStream);\n\nSSH2Stream.prototype.__read = TransformStream.prototype._read;\nSSH2Stream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSSH2Stream.prototype.__push = TransformStream.prototype.push;\nSSH2Stream.prototype.push = function(chunk, encoding) {\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSSH2Stream.prototype._cleanup = function(callback) {\n  this.reset();\n  this.debug('DEBUG: Parser: Malformed packet');\n  callback && callback(new Error('Malformed packet'));\n};\n\nSSH2Stream.prototype._transform = function(chunk, encoding, callback, decomp) {\n  var skipDecrypt = false;\n  var decryptAuthMode = false;\n  var state = this._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var expect = instate.expect;\n  var decrypt = instate.decrypt;\n  var decompress = instate.decompress;\n  var chlen = chunk.length;\n  var chleft = 0;\n  var debug = this.debug;\n  var self = this;\n  var i = 0;\n  var p = i;\n  var blockLen;\n  var buffer;\n  var buf;\n  var r;\n\n  this.bytesReceived += chlen;\n\n  while (true) {\n    if (expect.type !== undefined) {\n      if (i >= chlen)\n        break;\n      if (expect.type === EXP_TYPE_BYTES) {\n        chleft = (chlen - i);\n        var pktLeft = (expect.buf.length - expect.ptr);\n        if (pktLeft <= chleft) {\n          chunk.copy(expect.buf, expect.ptr, i, i + pktLeft);\n          i += pktLeft;\n          buffer = expect.buf;\n          expect.buf = undefined;\n          expect.ptr = 0;\n          expect.type = undefined;\n        } else {\n          chunk.copy(expect.buf, expect.ptr, i);\n          expect.ptr += chleft;\n          i += chleft;\n        }\n        continue;\n      } else if (expect.type === EXP_TYPE_HEADER) {\n        i += instate.search.push(chunk);\n        if (expect.type !== undefined)\n          continue;\n      } else if (expect.type === EXP_TYPE_LF) {\n        if (++expect.ptr + 4 /* Account for \"SSH-\" */ > 255) {\n          this.reset();\n          debug('DEBUG: Parser: Identification string exceeded 255 characters');\n          return callback(new Error('Max identification string size exceeded'));\n        }\n        if (chunk[i] === 0x0A) {\n          expect.type = undefined;\n          if (p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          buffer = expect.buf;\n          expect.buf = undefined;\n          ++i;\n        } else {\n          if (++i === chlen && p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          continue;\n        }\n      }\n    }\n\n    if (instate.status === IN_INIT) {\n      if (!this.readable)\n        return callback();\n      if (this.server) {\n        // Retrieve what should be the start of the protocol version exchange\n        if (!buffer) {\n          debug('DEBUG: Parser: IN_INIT (waiting for identification begin)');\n          expectData(this, EXP_TYPE_BYTES, 4);\n        } else {\n          if (buffer[0] === 0x53       // S\n              && buffer[1] === 0x53    // S\n              && buffer[2] === 0x48    // H\n              && buffer[3] === 0x2D) { // -\n            instate.status = IN_GREETING;\n            debug('DEBUG: Parser: IN_INIT (waiting for rest of identification)');\n          } else {\n            this.reset();\n            debug('DEBUG: Parser: Bad identification start');\n            return callback(new Error('Bad identification start'));\n          }\n        }\n      } else {\n        debug('DEBUG: Parser: IN_INIT');\n        // Retrieve any bytes that may come before the protocol version exchange\n        var ss = instate.search = new StreamSearch(IDENT_PREFIX_BUFFER);\n        ss.on('info', function onInfo(matched, data, start, end) {\n          if (data) {\n            if (instate.greeting === undefined)\n              instate.greeting = data.toString('binary', start, end);\n            else\n              instate.greeting += data.toString('binary', start, end);\n          }\n          if (matched) {\n            expect.type = undefined;\n            instate.search.removeListener('info', onInfo);\n          }\n        });\n        ss.maxMatches = 1;\n        expectData(this, EXP_TYPE_HEADER);\n        instate.status = IN_GREETING;\n      }\n    } else if (instate.status === IN_GREETING) {\n      debug('DEBUG: Parser: IN_GREETING');\n      instate.search = undefined;\n      // Retrieve the identification bytes after the \"SSH-\" header\n      p = i;\n      expectData(this, EXP_TYPE_LF);\n      instate.status = IN_HEADER;\n    } else if (instate.status === IN_HEADER) {\n      debug('DEBUG: Parser: IN_HEADER');\n      if (buffer.charCodeAt(buffer.length - 1) === 13)\n        buffer = buffer.slice(0, -1);\n      var idxDash = buffer.indexOf('-');\n      var idxSpace = buffer.indexOf(' ');\n      var header = {\n        // RFC says greeting SHOULD be utf8\n        greeting: instate.greeting,\n        identRaw: 'SSH-' + buffer,\n        versions: {\n          protocol: buffer.substr(0, idxDash),\n          software: (idxSpace === -1\n                     ? buffer.substring(idxDash + 1)\n                     : buffer.substring(idxDash + 1, idxSpace))\n        },\n        comments: (idxSpace > -1 ? buffer.substring(idxSpace + 1) : undefined)\n      };\n      instate.greeting = undefined;\n\n      if (header.versions.protocol !== '1.99'\n          && header.versions.protocol !== '2.0') {\n        this.reset();\n        debug('DEBUG: Parser: protocol version not supported: '\n              + header.versions.protocol);\n        return callback(new Error('Protocol version not supported'));\n      } else\n        this.emit('header', header);\n\n      if (instate.status === IN_INIT) {\n        // We reset from an event handler, possibly due to an unsupported SSH\n        // protocol version?\n        return;\n      }\n\n      var identRaw = header.identRaw;\n      var software = header.versions.software;\n      this.debug('DEBUG: Remote ident: ' + inspect(identRaw));\n      for (var j = 0, rule; j < BUGGY_IMPLS_LEN; ++j) {\n        rule = BUGGY_IMPLS[j];\n        if (typeof rule[0] === 'string') {\n          if (software === rule[0])\n            this.remoteBugs |= rule[1];\n        } else if (rule[0].test(software))\n          this.remoteBugs |= rule[1];\n      }\n      instate.identRaw = identRaw;\n      // Adjust bytesReceived first otherwise it will have an incorrectly larger\n      // total when we call back into this function after completing KEXINIT\n      this.bytesReceived -= (chlen - i);\n      KEXINIT(this, function() {\n        if (i === chlen)\n          callback();\n        else\n          self._transform(chunk.slice(i), encoding, callback);\n      });\n      instate.status = IN_PACKETBEFORE;\n      return;\n    } else if (instate.status === IN_PACKETBEFORE) {\n      blockLen = (decrypt.instance ? decrypt.info.blockLen : 8);\n      debug('DEBUG: Parser: IN_PACKETBEFORE (expecting ' + blockLen + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(this, EXP_TYPE_BYTES, blockLen, decrypt.buf);\n      instate.status = IN_PACKET;\n    } else if (instate.status === IN_PACKET) {\n      debug('DEBUG: Parser: IN_PACKET');\n      if (decrypt.instance) {\n        decryptAuthMode = (decrypt.info.authLen > 0);\n        if (!decryptAuthMode)\n          buffer = decryptData(this, buffer);\n        blockLen = decrypt.info.blockLen;\n      } else {\n        decryptAuthMode = false;\n        blockLen = 8;\n      }\n\n      r = readInt(buffer, 0, this, callback);\n      if (r === false)\n        return;\n      var hmacInfo = instate.hmac.info;\n      var macSize;\n      if (hmacInfo)\n        macSize = hmacInfo.actualLen;\n      else\n        macSize = 0;\n      var fullPacketLen = r + 4 + macSize;\n      var maxPayloadLen = this.maxPacketSize;\n      if (decompress.instance) {\n        // Account for compressed payloads\n        // This formula is taken from dropbear which derives it from zlib's\n        // documentation. Explanation from dropbear:\n        /* For exact details see http://www.zlib.net/zlib_tech.html\n         * 5 bytes per 16kB block, plus 6 bytes for the stream.\n         * We might allocate 5 unnecessary bytes here if it's an\n         * exact multiple. */\n        maxPayloadLen += (((this.maxPacketSize / 16384) + 1) * 5 + 6);\n      }\n      if (r > maxPayloadLen\n          // TODO: Change 16 to \"MAX(16, decrypt.info.blockLen)\" when/if SSH2\n          // adopts 512-bit ciphers\n          || fullPacketLen < (16 + macSize)\n          || ((r + (decryptAuthMode ? 0 : 4)) % blockLen) !== 0) {\n        this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n        debug('DEBUG: Parser: Bad packet length (' + fullPacketLen + ')');\n        return callback(new Error('Bad packet length'));\n      }\n\n      instate.pktLen = r;\n      var remainLen = instate.pktLen + 4 - blockLen;\n      if (decryptAuthMode) {\n        decrypt.instance.setAAD(buffer.slice(0, 4));\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',remainLen:'\n              + remainLen);\n      } else {\n        instate.padLen = buffer[4];\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',padLen:'\n              + instate.padLen\n              + ',remainLen:'\n              + remainLen);\n      }\n      if (remainLen > 0) {\n        if (decryptAuthMode)\n          instate.pktExtra = buffer.slice(4);\n        else\n          instate.pktExtra = buffer.slice(5);\n        // Grab the rest of the packet\n        expectData(this, EXP_TYPE_BYTES, remainLen);\n        instate.status = IN_PACKETDATA;\n      } else if (remainLen < 0)\n        instate.status = IN_PACKETBEFORE;\n      else {\n        // Entire message fit into one block\n        skipDecrypt = true;\n        instate.status = IN_PACKETDATA;\n        continue;\n      }\n    } else if (instate.status === IN_PACKETDATA) {\n      debug('DEBUG: Parser: IN_PACKETDATA');\n      if (decrypt.instance) {\n        decryptAuthMode = (decrypt.info.authLen > 0);\n        if (!skipDecrypt) {\n          if (!decryptAuthMode)\n            buffer = decryptData(this, buffer);\n        } else {\n          skipDecrypt = false;\n        }\n      } else {\n        decryptAuthMode = false;\n        skipDecrypt = false;\n      }\n      var padStart = instate.pktLen - instate.padLen - 1;\n      // TODO: Allocate a Buffer once that is slightly larger than maxPacketSize\n      // (to accommodate for packet length field and MAC) and re-use that\n      // instead\n      if (instate.pktExtra) {\n        buf = Buffer.allocUnsafe(instate.pktExtra.length + buffer.length);\n        instate.pktExtra.copy(buf);\n        buffer.copy(buf, instate.pktExtra.length);\n        instate.payload = buf.slice(0, padStart);\n      } else {\n        // Entire message fit into one block\n        if (decryptAuthMode)\n          buf = buffer.slice(4);\n        else\n          buf = buffer.slice(5);\n        instate.payload = buffer.slice(5, 5 + padStart);\n      }\n      if (instate.hmac.info !== undefined) {\n        // Wait for hmac hash\n        var inHMACSize = decrypt.info.authLen || instate.hmac.info.actualLen;\n        debug('DEBUG: Parser: HMAC size:' + inHMACSize);\n        expectData(this, EXP_TYPE_BYTES, inHMACSize, instate.hmac.buf);\n        instate.status = IN_PACKETDATAVERIFY;\n        instate.packet = buf;\n      } else\n        instate.status = IN_PACKETDATAAFTER;\n      instate.pktExtra = undefined;\n      buf = undefined;\n    } else if (instate.status === IN_PACKETDATAVERIFY) {\n      debug('DEBUG: Parser: IN_PACKETDATAVERIFY');\n      // Verify packet data integrity\n      if (hmacVerify(this, buffer)) {\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Valid HMAC)');\n        instate.status = IN_PACKETDATAAFTER;\n        instate.packet = undefined;\n      } else {\n        this.reset();\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Invalid HMAC)');\n        return callback(new Error('Invalid HMAC'));\n      }\n    } else if (instate.status === IN_PACKETDATAAFTER) {\n      if (decompress.instance) {\n        if (!decomp) {\n          debug('DEBUG: Parser: Decompressing');\n          decompress.instance.write(instate.payload);\n          var decompBuf = [];\n          var decompBufLen = 0;\n          decompress.instance.on('readable', function() {\n            var buf;\n            while (buf = this.read()) {\n              decompBuf.push(buf);\n              decompBufLen += buf.length;\n            }\n          }).flush(Z_PARTIAL_FLUSH, function() {\n            decompress.instance.removeAllListeners('readable');\n            if (decompBuf.length === 1)\n              instate.payload = decompBuf[0];\n            else\n              instate.payload = Buffer.concat(decompBuf, decompBufLen);\n            decompBuf = null;\n            var nextSlice;\n            if (i === chlen)\n              nextSlice = EMPTY_BUFFER; // Avoid slicing a zero-length buffer\n            else\n              nextSlice = chunk.slice(i);\n            self._transform(nextSlice, encoding, callback, true);\n          });\n          return;\n        } else {\n          // Make sure we reset this after this first time in the loop,\n          // otherwise we could end up trying to interpret as-is another\n          // compressed packet that is within the same chunk\n          decomp = false;\n        }\n      }\n\n      this.emit('packet');\n\n      var ptype = instate.payload[0];\n\n      if (debug !== DEBUG_NOOP) {\n        var msgPacket = 'DEBUG: Parser: IN_PACKETDATAAFTER, packet: ';\n        var authMethod = state.authsQueue[0];\n        var msgPktType = null;\n\n        if (outstate.status === OUT_REKEYING\n            && !(ptype <= 4 || (ptype >= 20 && ptype <= 49)))\n          msgPacket += '(enqueued) ';\n\n        if (ptype === MESSAGE.KEXDH_INIT) {\n          switch (state.kex.type) {\n            case 'group':\n              msgPktType = 'KEXDH_INIT';\n              break;\n            case 'groupex':\n              msgPktType = 'KEXDH_GEX_REQUEST';\n              break;\n            default:\n              msgPktType = 'KEXECDH_INIT';\n          }\n        } else if (ptype === MESSAGE.KEXDH_REPLY) {\n          switch (state.kex.type) {\n            case 'group':\n              msgPktType = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              msgPktType = 'KEXDH_GEX_GROUP';\n              break;\n            default:\n              msgPktType = 'KEXECDH_REPLY';\n          }\n        } else if (ptype === MESSAGE.KEXDH_GEX_GROUP) {\n          msgPktType = 'KEXDH_GEX_GROUP';\n        } else if (ptype === MESSAGE.KEXDH_GEX_REPLY) {\n          msgPktType = 'KEXDH_GEX_REPLY';\n        } else if (ptype === 60) {\n          if (authMethod === 'password')\n            msgPktType = 'USERAUTH_PASSWD_CHANGEREQ';\n          else if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_REQUEST';\n          else if (authMethod === 'publickey')\n            msgPktType = 'USERAUTH_PK_OK';\n          else\n            msgPktType = 'UNKNOWN PACKET 60';\n        } else if (ptype === 61) {\n          if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_RESPONSE';\n          else\n            msgPktType = 'UNKNOWN PACKET 61';\n        }\n\n        if (msgPktType === null)\n          msgPktType = MESSAGE[ptype];\n\n        // Don't write debug output for messages we custom make in parsePacket()\n        if (ptype !== MESSAGE.CHANNEL_OPEN\n            && ptype !== MESSAGE.CHANNEL_REQUEST\n            && ptype !== MESSAGE.CHANNEL_SUCCESS\n            && ptype !== MESSAGE.CHANNEL_FAILURE\n            && ptype !== MESSAGE.CHANNEL_EOF\n            && ptype !== MESSAGE.CHANNEL_CLOSE\n            && ptype !== MESSAGE.CHANNEL_DATA\n            && ptype !== MESSAGE.CHANNEL_EXTENDED_DATA\n            && ptype !== MESSAGE.CHANNEL_WINDOW_ADJUST\n            && ptype !== MESSAGE.DISCONNECT\n            && ptype !== MESSAGE.USERAUTH_REQUEST\n            && ptype !== MESSAGE.GLOBAL_REQUEST)\n          debug(msgPacket + msgPktType);\n      }\n\n      // Only parse packet if we are not re-keying or the packet is not a\n      // transport layer packet needed for re-keying\n      if (outstate.status === OUT_READY\n          || ptype <= 4\n          || (ptype >= 20 && ptype <= 49)) {\n        if (parsePacket(this, callback) === false)\n          return;\n\n        if (instate.status === IN_INIT) {\n          // We were reset due to some error/disagreement ?\n          return;\n        }\n      } else if (outstate.status === OUT_REKEYING) {\n        if (instate.rekeyQueue.length === MAX_PACKETS_REKEYING) {\n          debug('DEBUG: Parser: Max incoming re-key queue length reached');\n          this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n          return callback(\n            new Error('Incoming re-key queue length limit reached')\n          );\n        }\n\n        // Make sure to record the sequence number in case we need it later on\n        // when we drain the queue (e.g. unknown packet)\n        var seqno = instate.seqno;\n        if (++instate.seqno > MAX_SEQNO)\n          instate.seqno = 0;\n\n        instate.rekeyQueue.push([seqno, instate.payload]);\n      }\n\n      instate.status = IN_PACKETBEFORE;\n      instate.payload = undefined;\n    }\n    if (buffer !== undefined)\n      buffer = undefined;\n  }\n\n  callback();\n};\n\nSSH2Stream.prototype.reset = function(noend) {\n  if (this._state) {\n    var state = this._state;\n    state.incoming.status = IN_INIT;\n    state.outgoing.status = OUT_INIT;\n  } else {\n    this._state = {\n      authsQueue: [],\n      hostkeyFormat: undefined,\n      kex: undefined,\n\n      incoming: {\n        status: IN_INIT,\n        expectedPacket: undefined,\n        search: undefined,\n        greeting: undefined,\n        seqno: 0,\n        pktLen: undefined,\n        padLen: undefined,\n        pktExtra: undefined,\n        payload: undefined,\n        packet: undefined,\n        kexinit: undefined,\n        identRaw: undefined,\n        rekeyQueue: [],\n        ignoreNext: false,\n\n        expect: {\n          amount: undefined,\n          type: undefined,\n          ptr: 0,\n          buf: undefined\n        },\n\n        decrypt: {\n          instance: false,\n          info: undefined,\n          iv: undefined,\n          key: undefined,\n          buf: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          info: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        decompress: {\n          instance: false,\n          type: false\n        }\n      },\n\n      outgoing: {\n        status: OUT_INIT,\n        seqno: 0,\n        bufSeqno: Buffer.allocUnsafe(4),\n        rekeyQueue: [],\n        kexinit: undefined,\n        kexsecret: undefined,\n        pubkey: undefined,\n        exchangeHash: undefined,\n        sessionId: undefined,\n        sentNEWKEYS: false,\n\n        encrypt: {\n          instance: false,\n          info: undefined,\n          iv: undefined,\n          key: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          info: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        compress: {\n          instance: false,\n          type: false,\n          queue: null\n        }\n      }\n    };\n  }\n  if (!noend) {\n    if (this.readable)\n      this.push(null);\n  }\n};\n\n// Common methods\n// Global\nSSH2Stream.prototype.disconnect = function(reason) {\n  /*\n    byte      SSH_MSG_DISCONNECT\n    uint32    reason code\n    string    description in ISO-10646 UTF-8 encoding\n    string    language tag\n  */\n  var buf = Buffer.alloc(1 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.DISCONNECT;\n\n  if (DISCONNECT_REASON[reason] === undefined)\n    reason = DISCONNECT_REASON.BY_APPLICATION;\n  writeUInt32BE(buf, reason, 1);\n\n  this.debug('DEBUG: Outgoing: Writing DISCONNECT ('\n             + DISCONNECT_REASON[reason]\n             + ')');\n  send(this, buf);\n  this.reset();\n\n  return false;\n};\nSSH2Stream.prototype.ping = function() {\n  this.debug('DEBUG: Outgoing: Writing ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n  return send(this, PING_PACKET);\n};\nSSH2Stream.prototype.rekey = function() {\n  var status = this._state.outgoing.status;\n  if (status === OUT_REKEYING)\n    throw new Error('A re-key is already in progress');\n  else if (status !== OUT_READY)\n    throw new Error('Cannot re-key yet');\n\n  this.debug('DEBUG: Outgoing: Starting re-key');\n  return KEXINIT(this);\n};\n\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.requestSuccess = function(data) {\n  var buf;\n  if (Buffer.isBuffer(data)) {\n    buf = Buffer.allocUnsafe(1 + data.length);\n\n    buf[0] = MESSAGE.REQUEST_SUCCESS;\n\n    data.copy(buf, 1);\n  } else\n    buf = REQUEST_SUCCESS_PACKET;\n\n  this.debug('DEBUG: Outgoing: Writing REQUEST_SUCCESS');\n  return send(this, buf);\n};\nSSH2Stream.prototype.requestFailure = function() {\n  this.debug('DEBUG: Outgoing: Writing REQUEST_FAILURE');\n  return send(this, REQUEST_FAILURE_PACKET);\n};\nSSH2Stream.prototype.channelSuccess = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_SUCCESS;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_SUCCESS (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelFailure = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_FAILURE;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_FAILURE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelEOF = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_EOF;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EOF (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelClose = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_CLOSE;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_CLOSE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelWindowAdjust = function(chan, amount) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, amount, 5);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_WINDOW_ADJUST ('\n             + chan\n             + ', '\n             + amount\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelData = function(chan, data) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_DATA;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, dataLen, 5);\n  if (dataIsBuffer)\n    data.copy(buf, 9);\n  else\n    buf.write(data, 9, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelExtData = function(chan, data, type) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, type, 5);\n\n  writeUInt32BE(buf, dataLen, 9);\n  if (dataIsBuffer)\n    data.copy(buf, 13);\n  else\n    buf.write(data, 13, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EXTENDED_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenConfirm = function(remoteChan, localChan,\n                                                   initWindow, maxPacket) {\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n  writeUInt32BE(buf, remoteChan, 1);\n\n  writeUInt32BE(buf, localChan, 5);\n\n  writeUInt32BE(buf, initWindow, 9);\n\n  writeUInt32BE(buf, maxPacket, 13);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_CONFIRMATION (r:'\n             + remoteChan\n             + ', l:'\n             + localChan\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenFail = function(remoteChan, reason, desc,\n                                                lang) {\n  if (typeof desc !== 'string')\n    desc = '';\n  if (typeof lang !== 'string')\n    lang = '';\n\n  var descLen = Buffer.byteLength(desc);\n  var langLen = Buffer.byteLength(lang);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + descLen + 4 + langLen);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n  writeUInt32BE(buf, remoteChan, 1);\n\n  writeUInt32BE(buf, reason, 5);\n\n  writeUInt32BE(buf, descLen, p);\n  p += 4;\n  if (descLen) {\n    buf.write(desc, p, descLen, 'utf8');\n    p += descLen;\n  }\n\n  writeUInt32BE(buf, langLen, p);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_FAILURE ('\n             + remoteChan\n             + ')');\n  return send(this, buf);\n};\n\n// Client-specific methods\n// Global\nSSH2Stream.prototype.service = function(svcName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var svcNameLen = Buffer.byteLength(svcName);\n  var buf = Buffer.allocUnsafe(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_REQUEST;\n\n  writeUInt32BE(buf, svcNameLen, 1);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_REQUEST (' + svcName + ')');\n  return send(this, buf);\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.tcpipForward = function(bindAddr, bindPort, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = Buffer.allocUnsafe(1 + 4 + 13 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 13, 1);\n  buf.write('tcpip-forward', 5, 13, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, addrlen, 19);\n  buf.write(bindAddr, 23, addrlen, 'ascii');\n\n  writeUInt32BE(buf, bindPort, 23 + addrlen);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.cancelTcpipForward = function(bindAddr, bindPort,\n                                                   wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = Buffer.allocUnsafe(1 + 4 + 20 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 20, 1);\n  buf.write('cancel-tcpip-forward', 5, 20, 'ascii');\n\n  buf[25] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, addrlen, 26);\n  buf.write(bindAddr, 30, addrlen, 'ascii');\n\n  writeUInt32BE(buf, bindPort, 30 + addrlen);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_streamLocalForward = function(socketPath,\n                                                           wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 31 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 31, 1);\n  buf.write('streamlocal-forward@openssh.com', 5, 31, 'ascii');\n\n  buf[36] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, pathlen, 37);\n  buf.write(socketPath, 41, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_cancelStreamLocalForward = function(socketPath,\n                                                                 wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 38 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 38, 1);\n  buf.write('cancel-streamlocal-forward@openssh.com', 5, 38, 'ascii');\n\n  buf[43] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, pathlen, 44);\n  buf.write(socketPath, 48, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.directTcpip = function(chan, initWindow, maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var srclen = Buffer.byteLength(cfg.srcIP);\n  var dstlen = Buffer.byteLength(cfg.dstIP);\n  var p = 29;\n  var buf = Buffer.allocUnsafe(1 + 4 + 12 + 4 + 4 + 4 + 4 + srclen + 4 + 4\n                               + dstlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 12, 1);\n  buf.write('direct-tcpip', 5, 12, 'ascii');\n\n  writeUInt32BE(buf, chan, 17);\n\n  writeUInt32BE(buf, initWindow, 21);\n\n  writeUInt32BE(buf, maxPacket, 25);\n\n  writeUInt32BE(buf, dstlen, p);\n  buf.write(cfg.dstIP, p += 4, dstlen, 'ascii');\n\n  writeUInt32BE(buf, cfg.dstPort, p += dstlen);\n\n  writeUInt32BE(buf, srclen, p += 4);\n  buf.write(cfg.srcIP, p += 4, srclen, 'ascii');\n\n  writeUInt32BE(buf, cfg.srcPort, p += srclen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_directStreamLocal = function(chan, initWindow,\n                                                          maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var p = 47;\n  var buf = Buffer.allocUnsafe(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathlen + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 30, 1);\n  buf.write('direct-streamlocal@openssh.com', 5, 30, 'ascii');\n\n  writeUInt32BE(buf, chan, 35);\n\n  writeUInt32BE(buf, initWindow, 39);\n\n  writeUInt32BE(buf, maxPacket, 43);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(cfg.socketPath, p += 4, pathlen, 'utf8');\n\n  // reserved fields (string and uint32)\n  buf.fill(0, buf.length - 8);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_noMoreSessions = function(wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var buf = Buffer.allocUnsafe(1 + 4 + 28 + 1);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 28, 1);\n  buf.write('no-more-sessions@openssh.com', 5, 28, 'ascii');\n\n  buf[33] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.session = function(chan, initWindow, maxPacket) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 7 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 7, 1);\n  buf.write('session', 5, 7, 'ascii');\n\n  writeUInt32BE(buf, chan, 12);\n\n  writeUInt32BE(buf, initWindow, 16);\n\n  writeUInt32BE(buf, maxPacket, 20);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', session)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.windowChange = function(chan, rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 13, 5);\n  buf.write('window-change', 9, 13, 'ascii');\n\n  buf[22] = 0;\n\n  writeUInt32BE(buf, cols, 23);\n\n  writeUInt32BE(buf, rows, 27);\n\n  writeUInt32BE(buf, width, 31);\n\n  writeUInt32BE(buf, height, 35);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', window-change)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.pty = function(chan, rows, cols, height,\n                                    width, term, modes, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  if (!term || !term.length)\n    term = 'vt100';\n  if (modes\n      && !Buffer.isBuffer(modes)\n      && !Array.isArray(modes)\n      && typeof modes === 'object')\n    modes = modesToBytes(modes);\n  if (!modes || !modes.length)\n    modes = NO_TERMINAL_MODES_BUFFER;\n\n  var termLen = term.length;\n  var modesLen = modes.length;\n  var p = 21;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4\n                               + 4 + modesLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 7, 5);\n  buf.write('pty-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, termLen, 17);\n  buf.write(term, 21, termLen, 'utf8');\n\n  writeUInt32BE(buf, cols, p += termLen);\n\n  writeUInt32BE(buf, rows, p += 4);\n\n  writeUInt32BE(buf, width, p += 4);\n\n  writeUInt32BE(buf, height, p += 4);\n\n  writeUInt32BE(buf, modesLen, p += 4);\n  p += 4;\n  if (Array.isArray(modes)) {\n    for (var i = 0; i < modesLen; ++i)\n      buf[p++] = modes[i];\n  } else if (Buffer.isBuffer(modes)) {\n    modes.copy(buf, p);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', pty-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.shell = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 5 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 5, 5);\n  buf.write('shell', 9, 5, 'ascii');\n\n  buf[14] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', shell)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exec = function(chan, cmd, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var cmdlen = (Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + 1 + 4 + cmdlen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 4, 5);\n  buf.write('exec', 9, 4, 'ascii');\n\n  buf[13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, cmdlen, 14);\n  if (Buffer.isBuffer(cmd))\n    cmd.copy(buf, 18);\n  else\n    buf.write(cmd, 18, cmdlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exec)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.signal = function(chan, signal) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  signal = signal.toUpperCase();\n  if (signal.slice(0, 3) === 'SIG')\n    signal = signal.substring(3);\n\n  if (SIGNALS.indexOf(signal) === -1)\n    throw new Error('Invalid signal: ' + signal);\n\n  var signalLen = signal.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 6, 5);\n  buf.write('signal', 9, 6, 'ascii');\n\n  buf[15] = 0;\n\n  writeUInt32BE(buf, signalLen, 16);\n  buf.write(signal, 20, signalLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', signal)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.env = function(chan, key, val, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var keyLen = Buffer.byteLength(key);\n  var valLen = (Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 3, 5);\n  buf.write('env', 9, 3, 'ascii');\n\n  buf[12] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, keyLen, 13);\n  buf.write(key, 17, keyLen, 'ascii');\n\n  writeUInt32BE(buf, valLen, 17 + keyLen);\n  if (Buffer.isBuffer(val))\n    val.copy(buf, 17 + keyLen + 4);\n  else\n    buf.write(val, 17 + keyLen + 4, valLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', env)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11Forward = function(chan, cfg, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var protolen = Buffer.byteLength(cfg.protocol);\n  var cookielen = Buffer.byteLength(cfg.cookie);\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 7 + 1 + 1 + 4 + protolen + 4\n                               + cookielen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 7, 5);\n  buf.write('x11-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf[17] = (cfg.single ? 1 : 0);\n\n  writeUInt32BE(buf, protolen, 18);\n  var bp = 22;\n  if (Buffer.isBuffer(cfg.protocol))\n    cfg.protocol.copy(buf, bp);\n  else\n    buf.write(cfg.protocol, bp, protolen, 'utf8');\n  bp += protolen;\n\n  writeUInt32BE(buf, cookielen, bp);\n  bp += 4;\n  if (Buffer.isBuffer(cfg.cookie))\n    cfg.cookie.copy(buf, bp);\n  else\n    buf.write(cfg.cookie, bp, cookielen, 'binary');\n  bp += cookielen;\n\n  writeUInt32BE(buf, (cfg.screen || 0), bp);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', x11-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.subsystem = function(chan, name, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 9, 5);\n  buf.write('subsystem', 9, 9, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, nameLen, 19);\n  buf.write(name, 23, nameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', subsystem: '\n             + name\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_agentForward = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 26 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 26, 5);\n  buf.write('auth-agent-req@openssh.com', 9, 26, 'ascii');\n\n  buf[35] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', auth-agent-req@openssh.com)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authPassword = function(username, password) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var passLen = Buffer.byteLength(password);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 8 // \"password\"\n                               + 1\n                               + 4 + passLen);\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 8, p += 14);\n  buf.write('password', p += 4, 8, 'ascii');\n\n  buf[p += 8] = 0;\n\n  writeUInt32BE(buf, passLen, ++p);\n  buf.write(password, p += 4, passLen, 'utf8');\n\n  this._state.authsQueue.push('password');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (password)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPK = function(username, pubKey, cbSign) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var keyType;\n\n  if (typeof pubKey.getPublicSSH === 'function') {\n    keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n  } else {\n    keyType = pubKey.toString('ascii',\n                              4,\n                              4 + readUInt32BE(pubKey, 0));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(keyType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var p = 0;\n  var buf = Buffer.allocUnsafe((cbSign ? 4 + sesLen : 0)\n                               + 1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 9 // \"publickey\"\n                               + 1\n                               + 4 + algoLen\n                               + 4 + pubKeyLen\n                              );\n\n  if (cbSign) {\n    writeUInt32BE(buf, sesLen, p);\n    outstate.sessionId.copy(buf, p += 4);\n    buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n  } else {\n    buf[p] = MESSAGE.USERAUTH_REQUEST;\n  }\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 9, p += 14);\n  buf.write('publickey', p += 4, 9, 'ascii');\n\n  buf[p += 9] = (cbSign ? 1 : 0);\n\n  writeUInt32BE(buf, algoLen, ++p);\n  buf.write(keyType, p += 4, algoLen, 'ascii');\n\n  writeUInt32BE(buf, pubKeyLen, p += algoLen);\n  pubKey.copy(buf, p += 4);\n\n  if (!cbSign) {\n    this._state.authsQueue.push('publickey');\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey -- check)');\n    return send(this, buf);\n  }\n\n  cbSign(buf, function(signature) {\n    signature = convertSignature(signature, keyType);\n    if (signature === false)\n      throw new Error('Error while converting handshake signature');\n\n    var sigLen = signature.length;\n    var sigbuf = Buffer.allocUnsafe(1\n                                    + 4 + userLen\n                                    + 4 + 14 // \"ssh-connection\"\n                                    + 4 + 9 // \"publickey\"\n                                    + 1\n                                    + 4 + algoLen\n                                    + 4 + pubKeyLen\n                                    + 4 // 4 + algoLen + 4 + sigLen\n                                    + 4 + algoLen\n                                    + 4 + sigLen);\n\n    p = 0;\n\n    sigbuf[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(sigbuf, userLen, ++p);\n    sigbuf.write(username, p += 4, userLen, 'utf8');\n\n    writeUInt32BE(sigbuf, 14, p += userLen);\n    sigbuf.write('ssh-connection', p += 4, 14, 'ascii');\n\n    writeUInt32BE(sigbuf, 9, p += 14);\n    sigbuf.write('publickey', p += 4, 9, 'ascii');\n\n    sigbuf[p += 9] = 1;\n\n    writeUInt32BE(sigbuf, algoLen, ++p);\n    sigbuf.write(keyType, p += 4, algoLen, 'ascii');\n\n    writeUInt32BE(sigbuf, pubKeyLen, p += algoLen);\n    pubKey.copy(sigbuf, p += 4);\n    writeUInt32BE(sigbuf, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n    writeUInt32BE(sigbuf, algoLen, p += 4);\n    sigbuf.write(keyType, p += 4, algoLen, 'ascii');\n    writeUInt32BE(sigbuf, sigLen, p += algoLen);\n    signature.copy(sigbuf, p += 4);\n\n    // Servers shouldn't send packet type 60 in response to signed publickey\n    // attempts, but if they do, interpret as type 60.\n    self._state.authsQueue.push('publickey');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authHostbased = function(username, pubKey, hostname,\n                                              userlocal, cbSign) {\n  // TODO: Make DRY by sharing similar code with authPK()\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var keyType;\n\n  if (typeof pubKey.getPublicSSH === 'function') {\n    keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n  } else {\n    keyType = pubKey.toString('ascii',\n                              4,\n                              4 + readUInt32BE(pubKey, 0));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(keyType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var hostnameLen = Buffer.byteLength(hostname);\n  var userlocalLen = Buffer.byteLength(userlocal);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(4 + sesLen\n                               + 1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 9 // \"hostbased\"\n                               + 4 + algoLen\n                               + 4 + pubKeyLen\n                               + 4 + hostnameLen\n                               + 4 + userlocalLen\n                              );\n\n  writeUInt32BE(buf, sesLen, p);\n  outstate.sessionId.copy(buf, p += 4);\n\n  buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 9, p += 14);\n  buf.write('hostbased', p += 4, 9, 'ascii');\n\n  writeUInt32BE(buf, algoLen, p += 9);\n  buf.write(keyType, p += 4, algoLen, 'ascii');\n\n  writeUInt32BE(buf, pubKeyLen, p += algoLen);\n  pubKey.copy(buf, p += 4);\n\n  writeUInt32BE(buf, hostnameLen, p += pubKeyLen);\n  buf.write(hostname, p += 4, hostnameLen, 'ascii');\n\n  writeUInt32BE(buf, userlocalLen, p += hostnameLen);\n  buf.write(userlocal, p += 4, userlocalLen, 'utf8');\n\n  cbSign(buf, function(signature) {\n    signature = convertSignature(signature, keyType);\n    if (signature === false)\n      throw new Error('Error while converting handshake signature');\n\n    var sigLen = signature.length;\n    var sigbuf = Buffer.allocUnsafe((buf.length - sesLen) + sigLen);\n\n    buf.copy(sigbuf, 0, 4 + sesLen);\n    writeUInt32BE(sigbuf, sigLen, sigbuf.length - sigLen - 4);\n    signature.copy(sigbuf, sigbuf.length - sigLen);\n\n    self._state.authsQueue.push('hostbased');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (hostbased)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authKeyboard = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 20 // \"keyboard-interactive\"\n                               + 4 // no language set\n                               + 4 // no submethods\n                              );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 20, p += 14);\n  buf.write('keyboard-interactive', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, 0, p += 20);\n\n  writeUInt32BE(buf, 0, p += 4);\n\n  this._state.authsQueue.push('keyboard-interactive');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (keyboard-interactive)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authNone = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 4 // \"none\"\n                              );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 4, p += 14);\n  buf.write('none', p += 4, 4, 'ascii');\n\n  this._state.authsQueue.push('none');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (none)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoRes = function(responses) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var responsesLen = 0;\n  var p = 0;\n  var resLen;\n  var len;\n  var i;\n\n  if (responses) {\n    for (i = 0, len = responses.length; i < len; ++i)\n      responsesLen += 4 + Buffer.byteLength(responses[i]);\n  }\n  var buf = Buffer.allocUnsafe(1 + 4 + responsesLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n  writeUInt32BE(buf, responses ? responses.length : 0, p);\n  if (responses) {\n    p += 4;\n    for (i = 0, len = responses.length; i < len; ++i) {\n      resLen = Buffer.byteLength(responses[i]);\n      writeUInt32BE(buf, resLen, p);\n      p += 4;\n      if (resLen) {\n        buf.write(responses[i], p, resLen, 'utf8');\n        p += resLen;\n      }\n    }\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_RESPONSE');\n  return send(this, buf);\n};\n\n// Server-specific methods\n// Global\nSSH2Stream.prototype.serviceAccept = function(svcName) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var svcNameLen = svcName.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_ACCEPT;\n\n  writeUInt32BE(buf, svcNameLen, 1);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_ACCEPT (' + svcName + ')');\n  send(this, buf);\n\n  if (this.server && this.banner && svcName === 'ssh-userauth') {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var bannerLen = Buffer.byteLength(this.banner);\n    var packetLen = 1 + 4 + bannerLen + 4;\n    var packet = Buffer.allocUnsafe(packetLen);\n    packet[0] = MESSAGE.USERAUTH_BANNER;\n    writeUInt32BE(packet, bannerLen, 1);\n    packet.write(this.banner, 5, bannerLen, 'utf8');\n    packet.fill(0, packetLen - 4); // Empty language tag\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_BANNER');\n    send(this, packet);\n    this.banner = undefined; // Prevent banner from being displayed again\n  }\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.forwardedTcpip = function(chan, initWindow, maxPacket,\n                                               cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n  var remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n  var p = 36 + boundAddrLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4\n                               + remoteAddrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 15, 1);\n  buf.write('forwarded-tcpip', 5, 15, 'ascii');\n\n  writeUInt32BE(buf, chan, 20);\n\n  writeUInt32BE(buf, initWindow, 24);\n\n  writeUInt32BE(buf, maxPacket, 28);\n\n  writeUInt32BE(buf, boundAddrLen, 32);\n  buf.write(cfg.boundAddr, 36, boundAddrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.boundPort, p);\n\n  writeUInt32BE(buf, remoteAddrLen, p += 4);\n  buf.write(cfg.remoteAddr, p += 4, remoteAddrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.remotePort, p += remoteAddrLen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11 = function(chan, initWindow, maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var addrLen = Buffer.byteLength(cfg.originAddr);\n  var p = 24 + addrLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 3, 1);\n  buf.write('x11', 5, 3, 'ascii');\n\n  writeUInt32BE(buf, chan, 8);\n\n  writeUInt32BE(buf, initWindow, 12);\n\n  writeUInt32BE(buf, maxPacket, 16);\n\n  writeUInt32BE(buf, addrLen, 20);\n  buf.write(cfg.originAddr, 24, addrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.originPort, p);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', x11)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_authAgent = function(chan, initWindow, maxPacket) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var buf = Buffer.allocUnsafe(1 + 4 + 22 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 22, 1);\n  buf.write('auth-agent@openssh.com', 5, 22, 'ascii');\n\n  writeUInt32BE(buf, chan, 27);\n\n  writeUInt32BE(buf, initWindow, 31);\n\n  writeUInt32BE(buf, maxPacket, 35);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', auth-agent@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_forwardedStreamLocal = function(chan, initWindow,\n                                                             maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 33, 1);\n  buf.write('forwarded-streamlocal@openssh.com', 5, 33, 'ascii');\n\n  writeUInt32BE(buf, chan, 38);\n\n  writeUInt32BE(buf, initWindow, 42);\n\n  writeUInt32BE(buf, maxPacket, 46);\n\n  writeUInt32BE(buf, pathlen, 50);\n  buf.write(cfg.socketPath, 54, pathlen, 'utf8');\n\n  writeUInt32BE(buf, 0, 54 + pathlen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitStatus = function(chan, status) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 11 + 1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 11, 5);\n  buf.write('exit-status', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  writeUInt32BE(buf, status, 21);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-status)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitSignal = function(chan, name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var msgLen = (msg ? Buffer.byteLength(msg) : 0);\n  var p = 25 + nameLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen\n                               + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 11, 5);\n  buf.write('exit-signal', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  writeUInt32BE(buf, nameLen, 21);\n  buf.write(name, 25, nameLen, 'utf8');\n\n  buf[p++] = (coreDumped ? 1 : 0);\n\n  writeUInt32BE(buf, msgLen, p);\n  p += 4;\n  if (msgLen) {\n    buf.write(msg, p, msgLen, 'utf8');\n    p += msgLen;\n  }\n\n  writeUInt32BE(buf, 0, p);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-signal)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authFailure = function(authMethods, isPartial) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var methods;\n\n  if (typeof authMethods === 'boolean') {\n    isPartial = authMethods;\n    authMethods = undefined;\n  }\n\n  if (authMethods) {\n    methods = [];\n    for (var i = 0, len = authMethods.length; i < len; ++i) {\n      if (authMethods[i].toLowerCase() === 'none')\n        continue;\n      methods.push(authMethods[i]);\n    }\n    methods = methods.join(',');\n  } else\n    methods = '';\n\n  var methodsLen = methods.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + methodsLen + 1);\n\n  buf[0] = MESSAGE.USERAUTH_FAILURE;\n\n  writeUInt32BE(buf, methodsLen, 1);\n  buf.write(methods, 5, methodsLen, 'ascii');\n\n  buf[5 + methodsLen] = (isPartial === true ? 1 : 0);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_FAILURE');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authSuccess = function() {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var state = this._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  state.authsQueue.shift();\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_SUCCESS');\n  var ret = send(this, USERAUTH_SUCCESS_PACKET);\n\n  if (outstate.compress.type === 'zlib@openssh.com') {\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    outstate.compress.queue = [];\n  }\n  if (instate.decompress.type === 'zlib@openssh.com')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n\n  return ret;\n};\nSSH2Stream.prototype.authPKOK = function(keyAlgo, key) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length || authsQueue[0] !== 'publickey')\n    throw new Error('\"publickey\" auth not in progress');\n\n  var keyAlgoLen = keyAlgo.length;\n  var keyLen = key.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n  buf[0] = MESSAGE.USERAUTH_PK_OK;\n\n  writeUInt32BE(buf, keyAlgoLen, 1);\n  buf.write(keyAlgo, 5, keyAlgoLen, 'ascii');\n\n  writeUInt32BE(buf, keyLen, 5 + keyAlgoLen);\n  key.copy(buf, 5 + keyAlgoLen + 4);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PK_OK');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPasswdChg = function(prompt, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptLen = Buffer.byteLength(prompt);\n  var langLen = lang ? lang.length : 0;\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1 + 4 + promptLen + 4 + langLen);\n\n  buf[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n  writeUInt32BE(buf, promptLen, ++p);\n  buf.write(prompt, p += 4, promptLen, 'utf8');\n\n  writeUInt32BE(buf, langLen, p += promptLen);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PASSWD_CHANGEREQ');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoReq = function(name, instructions, prompts) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptsLen = 0;\n  var nameLen = name ? Buffer.byteLength(name) : 0;\n  var instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n  var p = 0;\n  var promptLen;\n  var prompt;\n  var len;\n  var i;\n\n  for (i = 0, len = prompts.length; i < len; ++i)\n    promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n  var buf = Buffer.allocUnsafe(1 + 4 + nameLen + 4 + instrLen + 4 + 4\n                               + promptsLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n  writeUInt32BE(buf, nameLen, p);\n  p += 4;\n  if (name) {\n    buf.write(name, p, nameLen, 'utf8');\n    p += nameLen;\n  }\n\n  writeUInt32BE(buf, instrLen, p);\n  p += 4;\n  if (instructions) {\n    buf.write(instructions, p, instrLen, 'utf8');\n    p += instrLen;\n  }\n\n  writeUInt32BE(buf, 0, p);\n  p += 4;\n\n  writeUInt32BE(buf, prompts.length, p);\n  p += 4;\n  for (i = 0, len = prompts.length; i < len; ++i) {\n    prompt = prompts[i];\n    promptLen = Buffer.byteLength(prompt.prompt);\n    writeUInt32BE(buf, promptLen, p);\n    p += 4;\n    if (promptLen) {\n      buf.write(prompt.prompt, p, promptLen, 'utf8');\n      p += promptLen;\n    }\n    buf[p++] = (prompt.echo ? 1 : 0);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_REQUEST');\n  return send(this, buf);\n};\n\n// Shared incoming/parser functions\nfunction onDISCONNECT(self, reason, code, desc, lang) { // Client/Server\n  if (code !== DISCONNECT_REASON.BY_APPLICATION) {\n    var err = new Error(desc || reason);\n    err.code = code;\n    self.emit('error', err);\n  }\n  self.reset();\n}\n\nfunction onKEXINIT(self, init, firstFollows) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  if (outstate.status === OUT_READY) {\n    self.debug('DEBUG: Received re-key request');\n    outstate.status = OUT_REKEYING;\n    outstate.kexinit = undefined;\n    KEXINIT(self, check);\n  } else {\n    check();\n  }\n\n  function check() {\n    if (check_KEXINIT(self, init, firstFollows) === true) {\n      if (!self.server) {\n        if (state.kex.type === 'groupex')\n          KEXDH_GEX_REQ(self);\n        else\n          KEXDH_INIT(self);\n      } else {\n        state.incoming.expectedPacket = state.kex.pktInit;\n      }\n    }\n  }\n}\n\nfunction check_KEXINIT(self, init, firstFollows) {\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var serverList;\n  var clientList;\n  var val;\n  var len;\n  var i;\n\n  debug('DEBUG: Comparing KEXINITs ...');\n\n  var algos = self.config.algorithms;\n\n  var kexList = algos.kex;\n  if (self.remoteBugs & BUGS.BAD_DHGEX) {\n    var copied = false;\n    for (var j = kexList.length - 1; j >= 0; --j) {\n      if (kexList[j].indexOf('group-exchange') !== -1) {\n        if (!copied) {\n          kexList = kexList.slice();\n          copied = true;\n        }\n        kexList.splice(j, 1);\n      }\n    }\n  }\n\n  debug('DEBUG: (local) KEX algorithms: ' + kexList);\n  debug('DEBUG: (remote) KEX algorithms: ' + init.algorithms.kex);\n  if (self.server) {\n    serverList = kexList;\n    clientList = init.algorithms.kex;\n  } else {\n    serverList = init.algorithms.kex;\n    clientList = kexList;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching key exchange algorithm');\n    var err = new Error('Handshake failed: no matching key exchange algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var kex_algorithm = clientList[i];\n  debug('DEBUG: KEX algorithm: ' + kex_algorithm);\n  if (firstFollows\n      && (!init.algorithms.kex.length\n          || kex_algorithm !== init.algorithms.kex[0])) {\n    // Ignore next incoming packet, it was a wrong first guess at KEX algorithm\n    instate.ignoreNext = true;\n  }\n\n  debug('DEBUG: (local) Host key formats: ' + algos.serverHostKey);\n  debug('DEBUG: (remote) Host key formats: ' + init.algorithms.srvHostKey);\n  if (self.server) {\n    serverList = algos.serverHostKey;\n    clientList = init.algorithms.srvHostKey;\n  } else {\n    serverList = init.algorithms.srvHostKey;\n    clientList = algos.serverHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching host key format');\n    var err = new Error('Handshake failed: no matching host key format');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  state.hostkeyFormat = clientList[i];\n  debug('DEBUG: Host key format: ' + state.hostkeyFormat);\n\n  debug('DEBUG: (local) Client->Server ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Client->Server ciphers: '\n        + init.algorithms.cs.encrypt);\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.cs.encrypt;\n  } else {\n    serverList = init.algorithms.cs.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server cipher');\n    var err = new Error('Handshake failed: no matching client->server cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decrypt.type = clientList[i];\n  else\n    val = outstate.encrypt.type = clientList[i];\n  debug('DEBUG: Client->Server Cipher: ' + val);\n\n  debug('DEBUG: (local) Server->Client ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Server->Client ciphers: '\n        + (init.algorithms.sc.encrypt));\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.sc.encrypt;\n  } else {\n    serverList = init.algorithms.sc.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client cipher');\n    var err = new Error('Handshake failed: no matching server->client cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.encrypt.type = clientList[i];\n  else\n    val = instate.decrypt.type = clientList[i];\n  debug('DEBUG: Server->Client Cipher: ' + val);\n\n  debug('DEBUG: (local) Client->Server HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Client->Server HMAC algorithms: '\n        + init.algorithms.cs.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.cs.mac;\n  } else {\n    serverList = init.algorithms.cs.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable client->server hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server HMAC algorithm');\n    var err = new Error('Handshake failed: no matching client->server HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.hmac.type = clientList[i];\n  else\n    val = outstate.hmac.type = clientList[i];\n  debug('DEBUG: Client->Server HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Server->Client HMAC algorithms: '\n        + init.algorithms.sc.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.sc.mac;\n  } else {\n    serverList = init.algorithms.sc.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable server->client hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client HMAC algorithm');\n    var err = new Error('Handshake failed: no matching server->client HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.hmac.type = clientList[i];\n  else\n    val = instate.hmac.type = clientList[i];\n  debug('DEBUG: Server->Client HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Client->Server compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Client->Server compression algorithms: '\n        + init.algorithms.cs.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.cs.compress;\n  } else {\n    serverList = init.algorithms.cs.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server compression algorithm');\n    var err = new Error('Handshake failed: no matching client->server '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decompress.type = clientList[i];\n  else\n    val = outstate.compress.type = clientList[i];\n  debug('DEBUG: Client->Server compression algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Server->Client compression algorithms: '\n        + init.algorithms.sc.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.sc.compress;\n  } else {\n    serverList = init.algorithms.sc.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client compression algorithm');\n    var err = new Error('Handshake failed: no matching server->client '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.compress.type = clientList[i];\n  else\n    val = instate.decompress.type = clientList[i];\n  debug('DEBUG: Server->Client compression algorithm: ' + val);\n\n  state.kex = new KeyExchange(kex_algorithm);\n  state.kex.generateKeys();\n  outstate.pubkey = state.kex.getPublicKey();\n\n  return true;\n}\n\nfunction onKEXDH_GEX_GROUP(self, prime, gen) {\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  state.kex.setDHParams(prime, gen);\n  state.kex.generateKeys();\n  outstate.pubkey = state.kex.getPublicKey();\n\n  KEXDH_INIT(self);\n}\n\nfunction onKEXDH_INIT(self, e) { // Server\n  KEXDH_REPLY(self, e);\n}\n\nfunction onKEXDH_REPLY(self, info, verifiedHost) { // Client\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var len;\n  var i;\n\n  if (verifiedHost === undefined) {\n    instate.expectedPacket = 'NEWKEYS';\n    outstate.sentNEWKEYS = false;\n\n    debug('DEBUG: Checking host key format');\n    // Ensure all host key formats agree\n    var hostkey_format = readString(info.hostkey, 0, 'ascii', self);\n    if (hostkey_format === false)\n      return false;\n    if (info.hostkey_format !== state.hostkeyFormat\n        || info.hostkey_format !== hostkey_format) {\n      // Expected and actual server host key format do not match!\n      debug('DEBUG: Host key format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: host key format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n\n    debug('DEBUG: Checking signature format');\n    // Ensure signature formats agree\n    var sig_format = readString(info.sig, 0, 'ascii', self);\n    if (sig_format === false)\n      return false;\n    if (info.sig_format !== sig_format) {\n      debug('DEBUG: Signature format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  // Verify the host fingerprint first if needed\n  if (outstate.status === OUT_INIT) {\n    if (verifiedHost === undefined) {\n      debug('DEBUG: Verifying host fingerprint');\n      var sync = true;\n      var emitted = self.emit('fingerprint', info.hostkey, function(permitted) {\n        // Prevent multiple calls to this callback\n        if (verifiedHost !== undefined)\n          return;\n        verifiedHost = !!permitted;\n        if (!sync) {\n          // Continue execution by re-entry\n          onKEXDH_REPLY(self, info, verifiedHost);\n        }\n      });\n      sync = false;\n      // Support async calling of verification callback\n      if (emitted && verifiedHost === undefined)\n        return;\n    }\n    if (verifiedHost === undefined)\n      debug('DEBUG: Host accepted by default (no verification)');\n    else if (verifiedHost === true)\n      debug('DEBUG: Host accepted (verified)');\n    else {\n      debug('DEBUG: Host denied via fingerprint verification');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: '\n                          + 'host fingerprint verification failed');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  info.pubkey = state.kex.convertPublicKey(info.pubkey);\n\n  info.secret = state.kex.computeSecret(info.pubkey);\n\n  if (info.secret instanceof Error) {\n    info.secret.message = 'Error while computing DH secret ('\n                          + state.kex.type + '): '\n                          + info.secret.message;\n    info.secret.level = 'handshake';\n    self.emit('error', info.secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hash = crypto.createHash(state.kex.hash);\n\n  var len_ident = Buffer.byteLength(self.config.ident);\n  var len_sident = Buffer.byteLength(instate.identRaw);\n  var len_init = outstate.kexinit.length;\n  var len_sinit = instate.kexinit.length;\n  var len_hostkey = info.hostkey.length;\n  var len_pubkey = outstate.pubkey.length;\n  var len_spubkey = info.pubkey.length;\n  var len_secret = info.secret.length;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var len_gex_prime;\n  var len_gex_gen;\n  var gex_prime;\n  var gex_gen;\n  var dhParams = state.kex.getDHParams();\n  if (dhParams) {\n    gex_prime = dhParams.prime;\n    gex_gen = dhParams.generator;\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = Buffer.allocUnsafe(exchangeBufLen);\n\n  writeUInt32BE(exchangeBuf, len_ident, bp);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  writeUInt32BE(exchangeBuf, len_sident, bp);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  writeUInt32BE(exchangeBuf, len_init, bp);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  outstate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_sinit, bp);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  instate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_hostkey, bp);\n  bp += 4;\n  info.hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (dhParams) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    writeUInt32BE(exchangeBuf, len_gex_prime, bp);\n    bp += 4;\n    gex_prime.copy(exchangeBuf, bp); // p\n    bp += len_gex_prime;\n\n    writeUInt32BE(exchangeBuf, len_gex_gen, bp);\n    bp += 4;\n    gex_gen.copy(exchangeBuf, bp); // g\n    bp += len_gex_gen;\n  }\n\n  writeUInt32BE(exchangeBuf, len_pubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(exchangeBuf, bp); // e\n  bp += len_pubkey;\n\n  writeUInt32BE(exchangeBuf, len_spubkey, bp);\n  bp += 4;\n  info.pubkey.copy(exchangeBuf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(exchangeBuf, len_secret, bp);\n  bp += 4;\n  info.secret.copy(exchangeBuf, bp); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  var rawsig = readString(info.sig, info.sig._pos, self); // s\n  if (rawsig === false\n      || !(rawsig = sigSSHToASN1(rawsig, info.sig_format, self))) {\n    return false;\n  }\n\n  var hostPubKey = parseDERKey(info.hostkey, info.sig_format);\n  if (hostPubKey instanceof Error)\n    return false;\n\n  debug('DEBUG: Verifying signature');\n\n  if (hostPubKey.verify(outstate.exchangeHash, rawsig) !== true) {\n    debug('DEBUG: Signature verification failed');\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    self.reset();\n    var err = new Error('Handshake failed: signature verification failed');\n    err.level = 'handshake';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = info.secret;\n\n  debug('DEBUG: Outgoing: Writing NEWKEYS');\n  if (outstate.status === OUT_REKEYING)\n    send(self, NEWKEYS_PACKET, undefined, true);\n  else\n    send(self, NEWKEYS_PACKET);\n  outstate.sentNEWKEYS = true;\n\n  if (verifiedHost !== undefined && instate.expectedPacket === undefined) {\n    // We received NEWKEYS while we were waiting for the fingerprint\n    // verification callback to be called. In this case we have to re-execute\n    // onNEWKEYS to finish the handshake.\n    onNEWKEYS(self);\n  }\n}\n\nfunction onNEWKEYS(self) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  instate.expectedPacket = undefined;\n\n  if (!outstate.sentNEWKEYS)\n    return;\n\n  var len = outstate.kexsecret.length;\n\n  var outCipherInfo = outstate.encrypt.info = CIPHER_INFO[outstate.encrypt.type];\n  var p = 0;\n\n  var dhHashAlgo = state.kex.hash;\n\n  var secret = Buffer.allocUnsafe(4 + len);\n  var iv;\n  var key;\n\n  // Whenever the client sends a new authentication request, it is enqueued\n  // here.  Once the request is resolved (success, fail, or PK_OK),\n  // dequeue.  Whatever is at the front of the queue determines how we\n  // interpret packet type 60.\n  state.authsQueue = [];\n\n  writeUInt32BE(secret, len, p);\n  p += 4;\n  outstate.kexsecret.copy(secret, p);\n  outstate.kexsecret = undefined;\n  if (!outCipherInfo.stream) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'A' : 'B', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    while (iv.length < outCipherInfo.ivLen) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    if (iv.length > outCipherInfo.ivLen)\n      iv = iv.slice(0, outCipherInfo.ivLen);\n  } else {\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'C' : 'D', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (key.length < outCipherInfo.keyLen) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  if (key.length > outCipherInfo.keyLen)\n    key = key.slice(0, outCipherInfo.keyLen);\n\n  if (outCipherInfo.authLen > 0) {\n    outstate.encrypt.iv = iv;\n    outstate.encrypt.key = key;\n    outstate.encrypt.instance = true;\n  } else {\n    var cipherAlgo = SSH_TO_OPENSSL[outstate.encrypt.type];\n    outstate.encrypt.instance = crypto.createCipheriv(cipherAlgo, key, iv);\n    outstate.encrypt.instance.setAutoPadding(false);\n  }\n\n  // And now for decrypting ...\n\n  var inCipherInfo = instate.decrypt.info = CIPHER_INFO[instate.decrypt.type];\n  if (!inCipherInfo.stream) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'B' : 'A', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    while (iv.length < inCipherInfo.ivLen) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    if (iv.length > inCipherInfo.ivLen)\n      iv = iv.slice(0, inCipherInfo.ivLen);\n  } else {\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  // Create a reusable buffer for decryption purposes\n  instate.decrypt.buf = Buffer.allocUnsafe(inCipherInfo.blockLen);\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'D' : 'C', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (key.length < inCipherInfo.keyLen) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  if (key.length > inCipherInfo.keyLen)\n    key = key.slice(0, inCipherInfo.keyLen);\n\n  var decipherAlgo = SSH_TO_OPENSSL[instate.decrypt.type];\n  instate.decrypt.instance = crypto.createDecipheriv(decipherAlgo, key, iv);\n  instate.decrypt.instance.setAutoPadding(false);\n  instate.decrypt.iv = iv;\n  instate.decrypt.key = key;\n\n  var emptyBuf;\n  if (outCipherInfo.discardLen > 0) {\n    emptyBuf = Buffer.alloc(outCipherInfo.discardLen);\n    outstate.encrypt.instance.update(emptyBuf);\n  }\n  if (inCipherInfo.discardLen > 0) {\n    if (!emptyBuf || emptyBuf.length !== inCipherInfo.discardLen)\n      emptyBuf = Buffer.alloc(outCipherInfo.discardLen);\n    instate.decrypt.instance.update(emptyBuf);\n  }\n\n  var outHMACInfo = outstate.hmac.info = HMAC_INFO[outstate.hmac.type];\n  var inHMACInfo = instate.hmac.info = HMAC_INFO[instate.hmac.type];\n\n  if (outCipherInfo.authLen === 0) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'E' : 'F', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (key.length < outHMACInfo.len) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    if (key.length > outHMACInfo.len)\n      key = key.slice(0, outHMACInfo.len);\n    outstate.hmac.key = key;\n  } else {\n    outstate.hmac.key = undefined;\n  }\n  if (inCipherInfo.authLen === 0) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'F' : 'E', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (key.length < inHMACInfo.len) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    if (key.length > inHMACInfo.len)\n      key = key.slice(0, inHMACInfo.len);\n    instate.hmac.key = key;\n  } else {\n    instate.hmac.key = undefined;\n  }\n\n  // Create a reusable buffer for message verification purposes\n  var inHMACSize = inCipherInfo.authLen || instate.hmac.info.actualLen;\n  if (!instate.hmac.buf\n      || instate.hmac.buf.length !== inHMACSize) {\n    instate.hmac.buf = Buffer.allocUnsafe(inHMACSize);\n  }\n\n  outstate.exchangeHash = undefined;\n\n  if (outstate.compress.type === 'zlib') {\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    outstate.compress.queue = [];\n  } else if (outstate.compress.type === 'none') {\n    outstate.compress.instance = false;\n    outstate.compress.queue = null;\n  }\n  if (instate.decompress.type === 'zlib')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n  else if (instate.decompress.type === 'none')\n    instate.decompress.instance = false;\n\n  self.bytesSent = self.bytesReceived = 0;\n\n  if (outstate.status === OUT_REKEYING) {\n    outstate.status = OUT_READY;\n\n    // Empty our outbound buffer of any data we tried to send during the\n    // re-keying process\n    var queue = outstate.rekeyQueue;\n    var qlen = queue.length;\n    var q = 0;\n\n    outstate.rekeyQueue = [];\n\n    for (; q < qlen; ++q) {\n      if (Buffer.isBuffer(queue[q]))\n        send(self, queue[q]);\n      else\n        send(self, queue[q][0], queue[q][1]);\n    }\n\n    // Now empty our inbound buffer of any non-transport layer packets we\n    // received during the re-keying process\n    queue = instate.rekeyQueue;\n    qlen = queue.length;\n    q = 0;\n\n    instate.rekeyQueue = [];\n\n    var curSeqno = instate.seqno;\n    for (; q < qlen; ++q) {\n      instate.seqno = queue[q][0];\n      instate.payload = queue[q][1];\n      if (parsePacket(self) === false)\n        return;\n\n      if (instate.status === IN_INIT) {\n        // We were reset due to some error/disagreement ?\n        return;\n      }\n    }\n    instate.seqno = curSeqno;\n  } else {\n    outstate.status = OUT_READY;\n    if (instate.status === IN_PACKET) {\n      // Explicitly update incoming packet parser status in order to get the\n      // correct decipher, hmac, etc. states.\n\n      // We only get here if the host fingerprint callback was called\n      // asynchronously and the incoming packet parser is still expecting an\n      // unencrypted packet, etc.\n\n      self.debug('DEBUG: Parser: IN_PACKETBEFORE (update) (expecting '\n                 + inCipherInfo.blockLen + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(self,\n                 EXP_TYPE_BYTES,\n                 inCipherInfo.blockLen,\n                 instate.decrypt.buf);\n    }\n    self.emit('ready');\n  }\n}\n\nfunction getPacketType(self, pktType) {\n  var kex = self._state.kex;\n  if (kex) {\n    // Disambiguate\n    switch (pktType) {\n      case 30:\n        return kex.pktInit;\n      case 31:\n        switch (kex.type) {\n          case 'group':\n            return 'KEXDH_REPLY';\n          case 'groupex':\n            return 'KEXDH_GEX_GROUP';\n          default:\n            return 'KEXECDH_REPLY';\n        }\n        break;\n      case 33:\n        if (kex.type === 'groupex')\n          return 'KEXDH_GEX_REPLY';\n    }\n  }\n  return MESSAGE[pktType];\n}\n\nfunction parsePacket(self, callback) {\n  var instate = self._state.incoming;\n  var outstate = self._state.outgoing;\n  var payload = instate.payload;\n  var seqno = instate.seqno;\n  var serviceName;\n  var lang;\n  var message;\n  var info;\n  var chan;\n  var data;\n  var srcIP;\n  var srcPort;\n  var sender;\n  var window;\n  var packetSize;\n  var recipient;\n  var description;\n  var socketPath;\n\n  if (++instate.seqno > MAX_SEQNO)\n    instate.seqno = 0;\n\n  if (instate.ignoreNext) {\n    self.debug('DEBUG: Parser: Packet ignored');\n    instate.ignoreNext = false;\n    return;\n  }\n\n  var type = payload[0];\n  if (type === undefined)\n    return false;\n\n  // If we receive a packet during handshake that is not the expected packet\n  // and it is not one of: DISCONNECT, IGNORE, UNIMPLEMENTED, or DEBUG, then we\n  // close the stream\n  if (outstate.status !== OUT_READY\n      && getPacketType(self, type) !== instate.expectedPacket\n      && type < 1\n      && type > 4) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + getPacketType(self, type));\n    // XXX: Potential issue where the module user decides to initiate a rekey\n    // via KEXINIT() (which sets `expectedPacket`) after receiving a packet\n    // and there is still another packet already waiting to be parsed at the\n    // time the KEXINIT is written. this will cause an unexpected disconnect...\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (type === MESSAGE.CHANNEL_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    // TODO: MAX_CHAN_DATA_LEN here should really be dependent upon the\n    //       channel's packet size. The ssh2 module uses 32KB, so we'll hard\n    //       code this for now ...\n    data = readString(payload, 5, self, callback, 32768);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_DATA:' + chan, data);\n  } else if (type === MESSAGE.CHANNEL_EXTENDED_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var dataType = readInt(payload, 5, self, callback);\n    if (dataType === false)\n      return false;\n    data = readString(payload, 9, self, callback);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_EXTENDED_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EXTENDED_DATA:' + chan, dataType, data);\n  } else if (type === MESSAGE.CHANNEL_WINDOW_ADJUST) {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var bytesToAdd = readInt(payload, 5, self, callback);\n    if (bytesToAdd === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_WINDOW_ADJUST ('\n               + chan\n               + ', '\n               + bytesToAdd\n               + ')');\n    self.emit('CHANNEL_WINDOW_ADJUST:' + chan, bytesToAdd);\n  } else if (type === MESSAGE.CHANNEL_SUCCESS) {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_SUCCESS ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_SUCCESS:' + chan);\n  } else if (type === MESSAGE.CHANNEL_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_FAILURE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_FAILURE:' + chan);\n  } else if (type === MESSAGE.CHANNEL_EOF) {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_EOF ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EOF:' + chan);\n  } else if (type === MESSAGE.CHANNEL_OPEN) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    var chanType = readString(payload, 1, 'ascii', self, callback);\n    if (chanType === false)\n      return false;\n    sender = readInt(payload, payload._pos, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, payload._pos += 4, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, payload._pos += 4, self, callback);\n    if (packetSize === false)\n      return false;\n    var channel;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_OPEN ('\n               + sender\n               + ', '\n               + chanType\n               + ')');\n\n    if (chanType === 'forwarded-tcpip' // Server->Client\n        || chanType === 'direct-tcpip') { // Client->Server\n      /*\n        string    address that was connected / host to connect\n        uint32    port that was connected / port to connect\n        string    originator IP address\n        uint32    originator port\n      */\n      var destIP = readString(payload,\n                              payload._pos += 4,\n                              'ascii',\n                              self,\n                              callback);\n      if (destIP === false)\n        return false;\n      var destPort = readInt(payload, payload._pos, self, callback);\n      if (destPort === false)\n        return false;\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          destIP: destIP,\n          destPort: destPort,\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else if (// Server->Client\n               chanType === 'forwarded-streamlocal@openssh.com'\n               // Client->Server\n               || chanType === 'direct-streamlocal@openssh.com') {\n      /*\n        string    socket path\n        string    reserved for future use\n      */\n      socketPath = readString(payload,\n                              payload._pos += 4,\n                              'utf8',\n                              self,\n                              callback);\n      if (socketPath === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          socketPath: socketPath,\n        }\n      };\n    } else if (chanType === 'x11') { // Server->Client\n      /*\n        string    originator address (e.g., \"192.168.7.38\")\n        uint32    originator port\n      */\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else {\n      // 'session' (Client->Server), 'auth-agent@openssh.com' (Server->Client)\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {}\n      };\n    }\n\n    self.emit('CHANNEL_OPEN', channel);\n  } else if (type === MESSAGE.CHANNEL_OPEN_CONFIRMATION) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    sender = readInt(payload, 5, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, 9, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, 13, self, callback);\n    if (packetSize === false)\n      return false;\n\n    info = {\n      recipient: recipient,\n      sender: sender,\n      window: window,\n      packetSize: packetSize\n    };\n\n    if (payload.length > 17)\n      info.data = payload.slice(17);\n\n    self.emit('CHANNEL_OPEN_CONFIRMATION:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_OPEN_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    var reasonCode = readInt(payload, 5, self, callback);\n    if (reasonCode === false)\n      return false;\n    description = readString(payload, 9, 'utf8', self, callback);\n    if (description === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    payload._pos = 9;\n    info = {\n      recipient: recipient,\n      reasonCode: reasonCode,\n      reason: CHANNEL_OPEN_FAILURE[reasonCode],\n      description: description,\n      lang: lang\n    };\n\n    self.emit('CHANNEL_OPEN_FAILURE:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_CLOSE) {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_CLOSE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_CLOSE:' + chan);\n  } else if (type === MESSAGE.IGNORE) {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n  } else if (type === MESSAGE.DISCONNECT) {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var reason = readInt(payload, 1, self, callback);\n    if (reason === false)\n      return false;\n    var reasonText = DISCONNECT_REASON[reason];\n    description = readString(payload, 5, 'utf8', self, callback);\n    if (description === false)\n      return false;\n\n    if (payload._pos < payload.length)\n      lang = readString(payload, payload._pos, 'ascii', self, callback);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: DISCONNECT ('\n               + reasonText\n               + ')');\n\n    self.emit('DISCONNECT', reasonText, reason, description, lang);\n  } else if (type === MESSAGE.DEBUG) {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 2, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'ascii', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('DEBUG', message, lang);\n  } else if (type === MESSAGE.NEWKEYS) {\n    /*\n      byte      SSH_MSG_NEW_KEYS\n    */\n    self.emit('NEWKEYS');\n  } else if (type === MESSAGE.SERVICE_REQUEST) {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_REQUEST', serviceName);\n  } else if (type === MESSAGE.SERVICE_ACCEPT) {\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_ACCEPT', serviceName);\n  } else if (type === MESSAGE.USERAUTH_REQUEST) {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    var username = readString(payload, 1, 'utf8', self, callback);\n    if (username === false)\n      return false;\n    var svcName = readString(payload, payload._pos, 'ascii', self, callback);\n    if (svcName === false)\n      return false;\n    var method = readString(payload, payload._pos, 'ascii', self, callback);\n    if (method === false)\n      return false;\n\n    var methodData;\n    var methodDesc;\n\n    if (method === 'password') {\n      methodData = readString(payload,\n                              payload._pos + 1,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method === 'publickey' || method === 'hostbased') {\n      var pkSigned;\n      var keyAlgo;\n      var key;\n      var signature;\n      var blob;\n      var hostname;\n      var userlocal;\n      if (method === 'publickey') {\n        pkSigned = payload[payload._pos++];\n        if (pkSigned === undefined)\n          return false;\n        pkSigned = (pkSigned !== 0);\n      }\n      keyAlgo = readString(payload, payload._pos, 'ascii', self, callback);\n      if (keyAlgo === false)\n        return false;\n      key = readString(payload, payload._pos, self, callback);\n      if (key === false)\n        return false;\n\n      if (pkSigned || method === 'hostbased') {\n        if (method === 'hostbased') {\n          hostname = readString(payload, payload._pos, 'ascii', self, callback);\n          if (hostname === false)\n            return false;\n          userlocal = readString(payload, payload._pos, 'utf8', self, callback);\n          if (userlocal === false)\n            return false;\n        }\n\n        var blobEnd = payload._pos;\n        signature = readString(payload, blobEnd, self, callback);\n        if (signature === false)\n          return false;\n\n        if (signature.length > (4 + keyAlgo.length + 4)\n            && signature.toString('ascii', 4, 4 + keyAlgo.length) === keyAlgo) {\n          // Skip algoLen + algo + sigLen\n          signature = signature.slice(4 + keyAlgo.length + 4);\n        }\n\n        signature = sigSSHToASN1(signature, keyAlgo, self, callback);\n        if (signature === false)\n          return false;\n\n        blob = Buffer.allocUnsafe(4 + outstate.sessionId.length + blobEnd);\n        writeUInt32BE(blob, outstate.sessionId.length, 0);\n        outstate.sessionId.copy(blob, 4);\n        payload.copy(blob, 4 + outstate.sessionId.length, 0, blobEnd);\n      } else {\n        methodDesc = 'publickey -- check';\n      }\n\n      methodData = {\n        keyAlgo: keyAlgo,\n        key: key,\n        signature: signature,\n        blob: blob,\n        localHostname: hostname,\n        localUsername: userlocal\n      };\n    } else if (method === 'keyboard-interactive') {\n      // Skip language, it's deprecated\n      var skipLen = readInt(payload, payload._pos, self, callback);\n      if (skipLen === false)\n        return false;\n      methodData = readString(payload,\n                              payload._pos + 4 + skipLen,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method !== 'none')\n      methodData = payload.slice(payload._pos);\n\n    if (methodDesc === undefined)\n      methodDesc = method;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: USERAUTH_REQUEST ('\n               + methodDesc\n               + ')');\n\n    self._state.authsQueue.push(method);\n    self.emit('USERAUTH_REQUEST', username, svcName, method, methodData);\n  } else if (type === MESSAGE.USERAUTH_SUCCESS) {\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    if (outstate.compress.type === 'zlib@openssh.com') {\n      outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n      outstate.compress.queue = [];\n    }\n    if (instate.decompress.type === 'zlib@openssh.com')\n      instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n\n    self._state.authsQueue.shift();\n\n    self.emit('USERAUTH_SUCCESS');\n  } else if (type === MESSAGE.USERAUTH_FAILURE) {\n    /*\n      byte      SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    var auths = readString(payload, 1, 'ascii', self, callback);\n    if (auths === false)\n      return false;\n    var partSuccess = payload[payload._pos];\n    if (partSuccess === undefined)\n      return false;\n\n    partSuccess = (partSuccess !== 0);\n    auths = auths.split(',');\n\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_FAILURE', auths, partSuccess);\n  } else if (type === MESSAGE.USERAUTH_BANNER) {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 1, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('USERAUTH_BANNER', message, lang);\n  } else if (type === MESSAGE.GLOBAL_REQUEST) {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    var request = readString(payload, 1, 'ascii', self, callback);\n    if (request === false) {\n      self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST');\n      return false;\n    }\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST ('\n               + request\n               + ')');\n\n    var wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n\n    var reqData;\n    if (request === 'tcpip-forward' || request === 'cancel-tcpip-forward') {\n      var bindAddr = readString(payload, payload._pos, 'ascii', self, callback);\n      if (bindAddr === false)\n        return false;\n      var bindPort = readInt(payload, payload._pos, self, callback);\n      if (bindPort === false)\n        return false;\n      reqData = {\n        bindAddr: bindAddr,\n        bindPort: bindPort\n      };\n    } else if (request === 'streamlocal-forward@openssh.com'\n               || request === 'cancel-streamlocal-forward@openssh.com') {\n      socketPath = readString(payload, payload._pos, 'utf8', self, callback);\n      if (socketPath === false)\n        return false;\n      reqData = {\n        socketPath: socketPath\n      };\n    } else if (request === 'no-more-sessions@openssh.com') {\n      // No data\n    } else {\n      reqData = payload.slice(payload._pos);\n    }\n\n    self.emit('GLOBAL_REQUEST', request, wantReply, reqData);\n  } else if (type === MESSAGE.REQUEST_SUCCESS) {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....      response specific data\n    */\n    if (payload.length > 1)\n      self.emit('REQUEST_SUCCESS', payload.slice(1));\n    else\n      self.emit('REQUEST_SUCCESS');\n  } else if (type === MESSAGE.REQUEST_FAILURE) {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self.emit('REQUEST_FAILURE');\n  } else if (type === MESSAGE.UNIMPLEMENTED) {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    // TODO\n  } else if (type === MESSAGE.KEXINIT)\n    return parse_KEXINIT(self, callback);\n  else if (type === MESSAGE.CHANNEL_REQUEST)\n    return parse_CHANNEL_REQUEST(self, callback);\n  else if (type >= 30 && type <= 49) // Key exchange method-specific messages\n    return parse_KEX(self, type, callback);\n  else if (type >= 60 && type <= 70) // User auth context-specific messages\n    return parse_USERAUTH(self, type, callback);\n  else {\n    // Unknown packet type\n    var unimpl = Buffer.allocUnsafe(1 + 4);\n    unimpl[0] = MESSAGE.UNIMPLEMENTED;\n    writeUInt32BE(unimpl, seqno, 1);\n    send(self, unimpl);\n  }\n}\n\nfunction parse_KEXINIT(self, callback) {\n  var instate = self._state.incoming;\n  var payload = instate.payload;\n\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  var init = {\n    algorithms: {\n      kex: undefined,\n      srvHostKey: undefined,\n      cs: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      },\n      sc: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      }\n    },\n    languages: {\n      cs: undefined,\n      sc: undefined\n    }\n  };\n  var val;\n\n  val = readList(payload, 17, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.kex = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.srvHostKey = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.cs = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.sc = val;\n\n  var firstFollows = (payload._pos < payload.length\n                      && payload[payload._pos] === 1);\n\n  instate.kexinit = payload;\n\n  self.emit('KEXINIT', init, firstFollows);\n}\n\nfunction parse_KEX(self, type, callback) {\n  var state = self._state;\n  var instate = state.incoming;\n  var payload = instate.payload;\n\n  if (state.outgoing.status === OUT_READY\n      || getPacketType(self, type) !== instate.expectedPacket) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + getPacketType(self, type));\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (state.kex.type === 'groupex') {\n    // Dynamic group exchange-related\n\n    if (self.server) {\n      // TODO: Support group exchange server-side\n      self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n      var err = new Error('DH group exchange not supported by server');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    } else {\n      if (type === MESSAGE.KEXDH_GEX_GROUP) {\n        /*\n          byte    SSH_MSG_KEX_DH_GEX_GROUP\n          mpint   p, safe prime\n          mpint   g, generator for subgroup in GF(p)\n        */\n        var prime = readString(payload, 1, self, callback);\n        if (prime === false)\n          return false;\n        var gen = readString(payload, payload._pos, self, callback);\n        if (gen === false)\n          return false;\n        self.emit('KEXDH_GEX_GROUP', prime, gen);\n      } else if (type === MESSAGE.KEXDH_GEX_REPLY)\n        return parse_KEXDH_REPLY(self, callback);\n    }\n  } else {\n    // Static group or ECDH-related\n\n    if (type === MESSAGE.KEXDH_INIT) {\n      /*\n        byte      SSH_MSG_KEXDH_INIT\n        mpint     e\n      */\n      var e = readString(payload, 1, self, callback);\n      if (e === false)\n        return false;\n\n      self.emit('KEXDH_INIT', e);\n    } else if (type === MESSAGE.KEXDH_REPLY)\n      return parse_KEXDH_REPLY(self, callback);\n  }\n}\n\nfunction parse_KEXDH_REPLY(self, callback) {\n  var payload = self._state.incoming.payload;\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n                / SSH_MSG_KEX_DH_GEX_REPLY\n                / SSH_MSG_KEX_ECDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n  var hostkey = readString(payload, 1, self, callback);\n  if (hostkey === false)\n    return false;\n  var pubkey = readString(payload, payload._pos, self, callback);\n  if (pubkey === false)\n    return false;\n  var sig = readString(payload, payload._pos, self, callback);\n  if (sig === false)\n    return false;\n  var info = {\n    hostkey: hostkey,\n    hostkey_format: undefined,\n    pubkey: pubkey,\n    sig: sig,\n    sig_format: undefined\n  };\n  var hostkey_format = readString(hostkey, 0, 'ascii', self, callback);\n  if (hostkey_format === false)\n    return false;\n  info.hostkey_format = hostkey_format;\n  var sig_format = readString(sig, 0, 'ascii', self, callback);\n  if (sig_format === false)\n    return false;\n  info.sig_format = sig_format;\n  self.emit('KEXDH_REPLY', info);\n}\n\nfunction parse_USERAUTH(self, type, callback) {\n  var state = self._state;\n  var authMethod = state.authsQueue[0];\n  var payload = state.incoming.payload;\n  var message;\n  var lang;\n  var text;\n\n  if (authMethod === 'password') {\n    if (type === MESSAGE.USERAUTH_PASSWD_CHANGEREQ) {\n      /*\n        byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n        string    prompt in ISO-10646 UTF-8 encoding\n        string    language tag\n      */\n      message = readString(payload, 1, 'utf8', self, callback);\n      if (message === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      self.emit('USERAUTH_PASSWD_CHANGEREQ', message, lang);\n    }\n  } else if (authMethod === 'keyboard-interactive') {\n    if (type === MESSAGE.USERAUTH_INFO_REQUEST) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_REQUEST\n        string    name (ISO-10646 UTF-8)\n        string    instruction (ISO-10646 UTF-8)\n        string    language tag -- MAY be empty\n        int       num-prompts\n        string    prompt[1] (ISO-10646 UTF-8)\n        boolean   echo[1]\n        ...\n        string    prompt[num-prompts] (ISO-10646 UTF-8)\n        boolean   echo[num-prompts]\n      */\n      var name;\n      var instr;\n      var nprompts;\n\n      name = readString(payload, 1, 'utf8', self, callback);\n      if (name === false)\n        return false;\n      instr = readString(payload, payload._pos, 'utf8', self, callback);\n      if (instr === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      nprompts = readInt(payload, payload._pos, self, callback);\n      if (nprompts === false)\n        return false;\n\n      payload._pos += 4;\n\n      var prompts = [];\n      for (var prompt = 0; prompt < nprompts; ++prompt) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        var echo = payload[payload._pos++];\n        if (echo === undefined)\n          return false;\n        echo = (echo !== 0);\n        prompts.push({\n          prompt: text,\n          echo: echo\n        });\n      }\n      self.emit('USERAUTH_INFO_REQUEST', name, instr, lang, prompts);\n    } else if (type === MESSAGE.USERAUTH_INFO_RESPONSE) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n        int       num-responses\n        string    response[1] (ISO-10646 UTF-8)\n        ...\n        string    response[num-responses] (ISO-10646 UTF-8)\n      */\n      var nresponses = readInt(payload, 1, self, callback);\n      if (nresponses === false)\n        return false;\n\n      payload._pos = 5;\n\n      var responses = [];\n      for (var response = 0; response < nresponses; ++response) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        responses.push(text);\n      }\n      self.emit('USERAUTH_INFO_RESPONSE', responses);\n    }\n  } else if (authMethod === 'publickey') {\n    if (type === MESSAGE.USERAUTH_PK_OK) {\n      /*\n        byte      SSH_MSG_USERAUTH_PK_OK\n        string    public key algorithm name from the request\n        string    public key blob from the request\n      */\n      var authsQueue = self._state.authsQueue;\n      if (!authsQueue.length || authsQueue[0] !== 'publickey')\n        return;\n      authsQueue.shift();\n      self.emit('USERAUTH_PK_OK');\n      // XXX: Parse public key info? client currently can ignore it because\n      // there is only one outstanding auth request at any given time, so it\n      // knows which key was OK'd\n    }\n  } else if (authMethod !== undefined) {\n    // Invalid packet for this auth type\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Invalid authentication method: ' + authMethod);\n    err.level = 'protocol';\n    self.emit('error', err);\n  }\n}\n\nfunction parse_CHANNEL_REQUEST(self, callback) {\n  var payload = self._state.incoming.payload;\n  var info;\n  var cols;\n  var rows;\n  var width;\n  var height;\n  var wantReply;\n  var signal;\n\n  var recipient = readInt(payload, 1, self, callback);\n  if (recipient === false)\n    return false;\n  var request = readString(payload, 5, 'ascii', self, callback);\n  if (request === false)\n    return false;\n\n  if (request === 'exit-status') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-status\"\n      boolean   FALSE\n      uint32    exit_status\n    */\n    var code = readInt(payload, ++payload._pos, self, callback);\n    if (code === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      code: code\n    };\n  } else if (request === 'exit-signal') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n      boolean   core dumped\n      string    error message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var coredump;\n    if (!(self.remoteBugs & BUGS.OLD_EXIT)) {\n      signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n      if (signal === false)\n        return false;\n      coredump = payload[payload._pos++];\n      if (coredump === undefined)\n        return false;\n      coredump = (coredump !== 0);\n    } else {\n      /*\n        Instead of `signal name` and `core dumped`, we have just:\n\n        uint32  signal number\n      */\n      signal = readInt(payload, ++payload._pos, self, callback);\n      if (signal === false)\n        return false;\n      switch (signal) {\n        case 1:\n          signal = 'HUP';\n          break;\n        case 2:\n          signal = 'INT';\n          break;\n        case 3:\n          signal = 'QUIT';\n          break;\n        case 6:\n          signal = 'ABRT';\n          break;\n        case 9:\n          signal = 'KILL';\n          break;\n        case 14:\n          signal = 'ALRM';\n          break;\n        case 15:\n          signal = 'TERM';\n          break;\n        default:\n          // Unknown or OS-specific\n          signal = 'UNKNOWN (' + signal + ')';\n      }\n      coredump = false;\n    }\n    var description = readString(payload, payload._pos, 'utf8', self,\n                                 callback);\n    if (description === false)\n      return false;\n    var lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: signal,\n      coredump: coredump,\n      description: description,\n      lang: lang\n    };\n  } else if (request === 'pty-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"pty-req\"\n      boolean   want_reply\n      string    TERM environment variable value (e.g., vt100)\n      uint32    terminal width, characters (e.g., 80)\n      uint32    terminal height, rows (e.g., 24)\n      uint32    terminal width, pixels (e.g., 640)\n      uint32    terminal height, pixels (e.g., 480)\n      string    encoded terminal modes\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var term = readString(payload, payload._pos, 'ascii', self, callback);\n    if (term === false)\n      return false;\n    cols = readInt(payload, payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    var modes = readString(payload, payload._pos += 4, self, callback);\n    if (modes === false)\n      return false;\n    modes = bytesToModes(modes);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      term: term,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height,\n      modes: modes\n    };\n  } else if (request === 'window-change') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"window-change\"\n      boolean   FALSE\n      uint32    terminal width, columns\n      uint32    terminal height, rows\n      uint32    terminal width, pixels\n      uint32    terminal height, pixels\n    */\n    cols = readInt(payload, ++payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height\n    };\n  } else if (request === 'x11-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"x11-req\"\n      boolean   want reply\n      boolean   single connection\n      string    x11 authentication protocol\n      string    x11 authentication cookie\n      uint32    x11 screen number\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var single = payload[payload._pos++];\n    if (single === undefined)\n      return false;\n    single = (single !== 0);\n    var protocol = readString(payload, payload._pos, 'ascii', self, callback);\n    if (protocol === false)\n      return false;\n    var cookie = readString(payload, payload._pos, 'binary', self, callback);\n    if (cookie === false)\n      return false;\n    var screen = readInt(payload, payload._pos, self, callback);\n    if (screen === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      single: single,\n      protocol: protocol,\n      cookie: cookie,\n      screen: screen\n    };\n  } else if (request === 'env') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"env\"\n      boolean   want reply\n      string    variable name\n      string    variable value\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var key = readString(payload, payload._pos, 'utf8', self, callback);\n    if (key === false)\n      return false;\n    var val = readString(payload, payload._pos, 'utf8', self, callback);\n    if (val === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      key: key,\n      val: val\n    };\n  } else if (request === 'shell') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"shell\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else if (request === 'exec') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exec\"\n      boolean   want reply\n      string    command\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var command = readString(payload, payload._pos, 'utf8', self, callback);\n    if (command === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      command: command\n    };\n  } else if (request === 'subsystem') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"subsystem\"\n      boolean   want reply\n      string    subsystem name\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var subsystem = readString(payload, payload._pos, 'utf8', self, callback);\n    if (subsystem === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      subsystem: subsystem\n    };\n  } else if (request === 'signal') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n    */\n    signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n    if (signal === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: 'SIG' + signal\n    };\n  } else if (request === 'xon-xoff') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"xon-xoff\"\n      boolean   FALSE\n      boolean   client can do\n    */\n    var clientControl = payload[++payload._pos];\n    if (clientControl === undefined)\n      return false;\n    clientControl = (clientControl !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      clientControl: clientControl\n    };\n  } else if (request === 'auth-agent-req@openssh.com') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"auth-agent-req@openssh.com\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else {\n    // Unknown request type\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  }\n  self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_REQUEST ('\n             + recipient\n             + ', '\n             + request\n             + ')');\n  self.emit('CHANNEL_REQUEST:' + recipient, info);\n}\n\nfunction hmacVerify(self, data) {\n  var instate = self._state.incoming;\n  var hmac = instate.hmac;\n\n  self.debug('DEBUG: Parser: Verifying MAC');\n\n  if (instate.decrypt.info.authLen > 0) {\n    var decrypt = instate.decrypt;\n    var instance = decrypt.instance;\n\n    instance.setAuthTag(data);\n\n    var payload = instance.update(instate.packet);\n    instate.payload = payload.slice(1, instate.packet.length - payload[0]);\n    iv_inc(decrypt.iv);\n\n    decrypt.instance = crypto.createDecipheriv(\n                         SSH_TO_OPENSSL[decrypt.type],\n                         decrypt.key,\n                         decrypt.iv\n                       );\n    decrypt.instance.setAutoPadding(false);\n    return true;\n  } else {\n    var calcHmac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n\n    writeUInt32BE(HMAC_COMPUTE, instate.seqno, 0);\n    writeUInt32BE(HMAC_COMPUTE, instate.pktLen, 4);\n    HMAC_COMPUTE[8] = instate.padLen;\n\n    calcHmac.update(HMAC_COMPUTE);\n    calcHmac.update(instate.packet);\n\n    var mac = calcHmac.digest();\n    if (mac.length > instate.hmac.info.actualLen)\n      mac = mac.slice(0, instate.hmac.info.actualLen);\n    return timingSafeEqual(mac, data);\n  }\n}\n\nfunction decryptData(self, data) {\n  var instance = self._state.incoming.decrypt.instance;\n  self.debug('DEBUG: Parser: Decrypting');\n  return instance.update(data);\n}\n\nfunction expectData(self, type, amount, buffer) {\n  var expect = self._state.incoming.expect;\n  expect.amount = amount;\n  expect.type = type;\n  expect.ptr = 0;\n  if (buffer)\n    expect.buf = buffer;\n  else if (amount)\n    expect.buf = Buffer.allocUnsafe(amount);\n}\n\nfunction readList(buffer, start, stream, callback) {\n  var list = readString(buffer, start, 'ascii', stream, callback);\n  return (list !== false ? (list.length ? list.split(',') : []) : false);\n}\n\nfunction bytesToModes(buffer) {\n  var modes = {};\n\n  for (var i = 0, len = buffer.length, opcode; i < len; i += 5) {\n    opcode = buffer[i];\n    if (opcode === TERMINAL_MODE.TTY_OP_END\n        || TERMINAL_MODE[opcode] === undefined\n        || i + 5 > len)\n      break;\n    modes[TERMINAL_MODE[opcode]] = readUInt32BE(buffer, i + 1);\n  }\n\n  return modes;\n}\n\nfunction modesToBytes(modes) {\n  var RE_IS_NUM = /^\\d+$/;\n  var keys = Object.keys(modes);\n  var b = 0;\n  var bytes = [];\n\n  for (var i = 0, len = keys.length, key, opcode, val; i < len; ++i) {\n    key = keys[i];\n    opcode = TERMINAL_MODE[key];\n    if (opcode\n        && !RE_IS_NUM.test(key)\n        && typeof modes[key] === 'number'\n        && key !== 'TTY_OP_END') {\n      val = modes[key];\n      bytes[b++] = opcode;\n      bytes[b++] = (val >>> 24) & 0xFF;\n      bytes[b++] = (val >>> 16) & 0xFF;\n      bytes[b++] = (val >>> 8) & 0xFF;\n      bytes[b++] = val & 0xFF;\n    }\n  }\n\n  bytes[b] = TERMINAL_MODE.TTY_OP_END;\n\n  return bytes;\n}\n\n// Shared outgoing functions\nfunction KEXINIT(self, cb) { // Client/Server\n  randBytes(16, function(myCookie) {\n    /*\n      byte         SSH_MSG_KEXINIT\n      byte[16]     cookie (random bytes)\n      name-list    kex_algorithms\n      name-list    server_host_key_algorithms\n      name-list    encryption_algorithms_client_to_server\n      name-list    encryption_algorithms_server_to_client\n      name-list    mac_algorithms_client_to_server\n      name-list    mac_algorithms_server_to_client\n      name-list    compression_algorithms_client_to_server\n      name-list    compression_algorithms_server_to_client\n      name-list    languages_client_to_server\n      name-list    languages_server_to_client\n      boolean      first_kex_packet_follows\n      uint32       0 (reserved for future extension)\n    */\n    var algos = self.config.algorithms;\n\n    var kexBuf = algos.kexBuf;\n    if (self.remoteBugs & BUGS.BAD_DHGEX) {\n      var copied = false;\n      var kexList = algos.kex;\n      for (var j = kexList.length - 1; j >= 0; --j) {\n        if (kexList[j].indexOf('group-exchange') !== -1) {\n          if (!copied) {\n            kexList = kexList.slice();\n            copied = true;\n          }\n          kexList.splice(j, 1);\n        }\n      }\n      if (copied)\n        kexBuf = Buffer.from(kexList.join(','));\n    }\n\n    var hostKeyBuf = algos.serverHostKeyBuf;\n\n    var kexInitSize = 1 + 16\n                      + 4 + kexBuf.length\n                      + 4 + hostKeyBuf.length\n                      + (2 * (4 + algos.cipherBuf.length))\n                      + (2 * (4 + algos.hmacBuf.length))\n                      + (2 * (4 + algos.compressBuf.length))\n                      + (2 * (4 /* languages skipped */))\n                      + 1 + 4;\n    var buf = Buffer.allocUnsafe(kexInitSize);\n    var p = 17;\n\n    buf[0] = MESSAGE.KEXINIT;\n\n    if (myCookie !== false)\n      myCookie.copy(buf, 1);\n\n    writeUInt32BE(buf, kexBuf.length, p);\n    p += 4;\n    kexBuf.copy(buf, p);\n    p += kexBuf.length;\n\n    writeUInt32BE(buf, hostKeyBuf.length, p);\n    p += 4;\n    hostKeyBuf.copy(buf, p);\n    p += hostKeyBuf.length;\n\n    writeUInt32BE(buf, algos.cipherBuf.length, p);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    writeUInt32BE(buf, algos.cipherBuf.length, p);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    writeUInt32BE(buf, algos.hmacBuf.length, p);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    writeUInt32BE(buf, algos.hmacBuf.length, p);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    writeUInt32BE(buf, algos.compressBuf.length, p);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    writeUInt32BE(buf, algos.compressBuf.length, p);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    // Skip language lists, first_kex_packet_follows, and reserved bytes\n    buf.fill(0, buf.length - 13);\n\n    self.debug('DEBUG: Outgoing: Writing KEXINIT');\n\n    self._state.incoming.expectedPacket = 'KEXINIT';\n\n    var outstate = self._state.outgoing;\n\n    outstate.kexinit = buf;\n\n    if (outstate.status === OUT_READY) {\n      // We are the one starting the rekeying process ...\n      outstate.status = OUT_REKEYING;\n    }\n\n    send(self, buf, cb, true);\n  });\n  return true;\n}\n\nfunction KEXDH_INIT(self) { // Client\n  var state = self._state;\n  var outstate = state.outgoing;\n  var buf = Buffer.allocUnsafe(1 + 4 + outstate.pubkey.length);\n\n  state.incoming.expectedPacket = state.kex.pktReply;\n  if (state.kex.type === 'groupex') {\n    buf[0] = MESSAGE.KEXDH_GEX_INIT;\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_INIT');\n  } else {\n    buf[0] = MESSAGE.KEXDH_INIT;\n    if (state.kex.type === 'group')\n      self.debug('DEBUG: Outgoing: Writing KEXDH_INIT');\n    else\n      self.debug('DEBUG: Outgoing: Writing KEXECDH_INIT');\n  }\n\n  writeUInt32BE(buf, outstate.pubkey.length, 1);\n  outstate.pubkey.copy(buf, 5);\n\n  return send(self, buf, undefined, true);\n}\n\nfunction KEXDH_REPLY(self, e) { // Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n  var curHostKey = self.config.hostKeys[state.hostkeyFormat];\n  if (Array.isArray(curHostKey))\n    curHostKey = curHostKey[0];\n  var hostkey = curHostKey.getPublicSSH();\n  var hostkeyAlgo = curHostKey.type;\n\n  // e === client DH public key\n\n  e = state.kex.convertPublicKey(e);\n\n  var secret = state.kex.computeSecret(e);\n\n  if (secret instanceof Error) {\n    secret.message = 'Error while computing DH secret ('\n                     + state.kex.type + '): '\n                     + secret.message;\n    secret.level = 'handshake';\n    self.emit('error', secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hash = crypto.createHash(state.kex.hash);\n\n  var len_ident = Buffer.byteLength(instate.identRaw);\n  var len_sident = Buffer.byteLength(self.config.ident);\n  var len_init = instate.kexinit.length;\n  var len_sinit = outstate.kexinit.length;\n  var len_hostkey = hostkey.length;\n  var len_pubkey = e.length;\n  var len_spubkey = outstate.pubkey.length;\n  var len_secret = secret.length;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var len_gex_prime;\n  var len_gex_gen;\n  var gex_prime;\n  var gex_gen;\n  var dhParams = state.kex.getDHParams();\n  if (dhParams) {\n    gex_prime = dhParams.prime;\n    gex_gen = dhParams.generator;\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = Buffer.allocUnsafe(exchangeBufLen);\n\n  writeUInt32BE(exchangeBuf, len_ident, bp);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  writeUInt32BE(exchangeBuf, len_sident, bp);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  writeUInt32BE(exchangeBuf, len_init, bp);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  instate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_sinit, bp);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  outstate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_hostkey, bp);\n  bp += 4;\n  hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (dhParams) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    writeUInt32BE(exchangeBuf, len_gex_prime, bp);\n    bp += 4;\n    gex_prime.copy(exchangeBuf, bp); // p\n    bp += len_gex_prime;\n\n    writeUInt32BE(exchangeBuf, len_gex_gen, bp);\n    bp += 4;\n    gex_gen.copy(exchangeBuf, bp); // g\n    bp += len_gex_gen;\n  }\n\n  writeUInt32BE(exchangeBuf, len_pubkey, bp);\n  bp += 4;\n  e.copy(exchangeBuf, bp); // e\n  bp += len_pubkey;\n\n  writeUInt32BE(exchangeBuf, len_spubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(exchangeBuf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(exchangeBuf, len_secret, bp);\n  bp += 4;\n  secret.copy(exchangeBuf, bp); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = secret;\n\n  var signature = curHostKey.sign(outstate.exchangeHash);\n  if (signature instanceof Error) {\n    signature.message = 'Error while signing data with host key ('\n                        + hostkeyAlgo + '): '\n                        + signature.message;\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  signature = convertSignature(signature, hostkeyAlgo);\n  if (signature === false) {\n    signature.message = 'Error while converting handshake signature';\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n\n  var siglen = 4 + hostkeyAlgo.length + 4 + signature.length;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + len_hostkey\n                               + 4 + len_spubkey\n                               + 4 + siglen);\n\n  bp = 0;\n  buf[bp] = MESSAGE[state.kex.pktReply];\n  ++bp;\n\n  writeUInt32BE(buf, len_hostkey, bp);\n  bp += 4;\n  hostkey.copy(buf, bp); // K_S\n  bp += len_hostkey;\n\n  writeUInt32BE(buf, len_spubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(buf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(buf, siglen, bp);\n  bp += 4;\n  writeUInt32BE(buf, hostkeyAlgo.length, bp);\n  bp += 4;\n  buf.write(hostkeyAlgo, bp, hostkeyAlgo.length, 'ascii');\n  bp += hostkeyAlgo.length;\n  writeUInt32BE(buf, signature.length, bp);\n  bp += 4;\n  signature.copy(buf, bp);\n\n  state.incoming.expectedPacket = 'NEWKEYS';\n\n  self.debug('DEBUG: Outgoing: Writing ' + state.kex.pktReply);\n  send(self, buf, undefined, true);\n\n  outstate.sentNEWKEYS = true;\n  self.debug('DEBUG: Outgoing: Writing NEWKEYS');\n  return send(self, NEWKEYS_PACKET, undefined, true);\n}\n\nfunction KEXDH_GEX_REQ(self) { // Client\n  self._state.incoming.expectedPacket = 'KEXDH_GEX_GROUP';\n\n  self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REQUEST');\n  return send(self, KEXDH_GEX_REQ_PACKET, undefined, true);\n}\n\nfunction compressPayload(self, payload, cb) {\n  var compress = self._state.outgoing.compress.instance;\n  compress.write(payload);\n  compress.flush(Z_PARTIAL_FLUSH, compressFlushCb.bind(self, cb));\n}\n\nfunction compressFlushCb(cb) {\n  if (this._readableState.ended || this._writableState.ended)\n    return;\n  send_(this, this._state.outgoing.compress.instance.read(), cb);\n\n  var queue = this._state.outgoing.compress.queue;\n  queue.shift();\n  if (queue.length > 0)\n    compressPayload(this, queue[0][0], queue[0][1]);\n}\n\nfunction send(self, payload, cb, bypass) {\n  var state = self._state;\n\n  if (!state)\n    return false;\n\n  var outstate = state.outgoing;\n  if (outstate.status === OUT_REKEYING && !bypass) {\n    if (typeof cb === 'function')\n      outstate.rekeyQueue.push([payload, cb]);\n    else\n      outstate.rekeyQueue.push(payload);\n    return false;\n  } else if (self._readableState.ended || self._writableState.ended) {\n    return false;\n  }\n\n  if (outstate.compress.instance) {\n    // This queue nonsense only exists because of a change made in node v10.12.0\n    // that changed flushing behavior, which now coalesces multiple writes to a\n    // single flush, which does not work for us.\n    var queue = outstate.compress.queue;\n    queue.push([payload, cb]);\n    if (queue.length === 1)\n      compressPayload(self, queue[0][0], queue[0][1]);\n    return true;\n  } else {\n    return send_(self, payload, cb);\n  }\n}\n\nfunction send_(self, payload, cb) {\n  // TODO: Implement length checks\n\n  var state = self._state;\n  var outstate = state.outgoing;\n  var encrypt = outstate.encrypt;\n  var hmac = outstate.hmac;\n  var pktLen;\n  var padLen;\n  var buf;\n  var mac;\n  var ret;\n\n  pktLen = payload.length + 9;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.info.authLen > 0) {\n      var ptlen = 1 + payload.length + 4/* Must have at least 4 bytes padding*/;\n      while ((ptlen % encrypt.info.blockLen) !== 0)\n        ++ptlen;\n      padLen = ptlen - 1 - payload.length;\n      pktLen = 4 + ptlen;\n    } else {\n      var blockLen = encrypt.info.blockLen;\n      pktLen += ((blockLen - 1) * pktLen) % blockLen;\n      padLen = pktLen - payload.length - 5;\n    }\n  } else {\n    pktLen += (7 * pktLen) % 8;\n    padLen = pktLen - payload.length - 5;\n  }\n\n  buf = Buffer.allocUnsafe(pktLen);\n\n  writeUInt32BE(buf, pktLen - 4, 0);\n  buf[4] = padLen;\n  payload.copy(buf, 5);\n\n  copyRandPadBytes(buf, 5 + payload.length, padLen);\n\n  if (hmac.type !== false && hmac.key) {\n    mac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n    writeUInt32BE(outstate.bufSeqno, outstate.seqno, 0);\n    mac.update(outstate.bufSeqno);\n    mac.update(buf);\n    mac = mac.digest();\n    if (mac.length > hmac.info.actualLen)\n      mac = mac.slice(0, hmac.info.actualLen);\n  }\n\n  var nb = 0;\n  var encData;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.info.authLen > 0) {\n      var encrypter = crypto.createCipheriv(SSH_TO_OPENSSL[encrypt.type],\n                                            encrypt.key,\n                                            encrypt.iv);\n      encrypter.setAutoPadding(false);\n\n      var lenbuf = buf.slice(0, 4);\n\n      encrypter.setAAD(lenbuf);\n      self.push(lenbuf);\n      nb += lenbuf;\n\n      encData = encrypter.update(buf.slice(4));\n      self.push(encData);\n      nb += encData.length;\n\n      var final = encrypter.final();\n      if (final.length) {\n        self.push(final);\n        nb += final.length;\n      }\n\n      var authTag = encrypter.getAuthTag();\n      ret = self.push(authTag);\n      nb += authTag.length;\n\n      iv_inc(encrypt.iv);\n    } else {\n      encData = encrypt.instance.update(buf);\n      self.push(encData);\n      nb += encData.length;\n\n      ret = self.push(mac);\n      nb += mac.length;\n    }\n  } else {\n    ret = self.push(buf);\n    nb = buf.length;\n  }\n\n  self.bytesSent += nb;\n\n  if (++outstate.seqno > MAX_SEQNO)\n    outstate.seqno = 0;\n\n  cb && cb();\n\n  return ret;\n}\n\nvar copyRandPadBytes = (function() {\n  if (typeof crypto.randomFillSync === 'function') {\n    return crypto.randomFillSync;\n  } else {\n    return function copyRandPadBytes(buf, offset, count) {\n      var padBytes = crypto.randomBytes(count);\n      padBytes.copy(buf, offset);\n    };\n  }\n})();\n\nfunction randBytes(n, cb) {\n  crypto.randomBytes(n, function retry(err, buf) {\n    if (err)\n      return crypto.randomBytes(n, retry);\n    cb && cb(buf);\n  });\n}\n\nfunction convertSignature(signature, keyType) {\n  switch (keyType) {\n    case 'ssh-dss':\n      return DSASigBERToBare(signature);\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return ECDSASigASN1ToSSH(signature);\n  }\n\n  return signature;\n}\n\nvar timingSafeEqual = (function() {\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return function timingSafeEquals(a, b) {\n      if (a.length !== b.length) {\n        crypto.timingSafeEqual(a, a);\n        return false;\n      } else {\n        return crypto.timingSafeEqual(a, b);\n      }\n    };\n  } else {\n    return function timingSafeEquals(a, b) {\n      var val;\n      if (a.length === b.length) {\n        val = 0;\n      } else {\n        val = 1;\n        b = a;\n      }\n\n      for (var i = 0, len = a.length; i < len; ++i)\n        val |= (a[i] ^ b[i]);\n\n      return (val === 0);\n    }\n  }\n})();\n\nfunction KeyExchange(algo, options) {\n  switch (algo) {\n    case 'curve25519-sha256':\n    case 'curve25519-sha256@libssh.org':\n      if (!CURVE25519_SUPPORTED)\n        break;\n      this.type = '25519';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp256':\n      this.type = 'ecdh';\n      this.name = 'prime256v1';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp384':\n      this.type = 'ecdh';\n      this.name = 'secp384r1';\n      this.hash = 'sha384';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp521':\n      this.type = 'ecdh';\n      this.name = 'secp521r1';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'diffie-hellman-group1-sha1':\n      this.type = 'group';\n      this.name = 'modp2';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group14-sha1':\n      this.type = 'group';\n      this.name = 'modp14';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group14-sha256':\n      this.type = 'group';\n      this.name = 'modp14';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group16-sha512':\n      this.type = 'group';\n      this.name = 'modp16';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group18-sha512':\n      this.type = 'group';\n      this.name = 'modp18';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group-exchange-sha1':\n      this.type = 'groupex';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_GEX_REQ';\n      this.pktReply = 'KEXDH_GEX_REPLY';\n      this._prime = null;\n      this._generator = null;\n      return;\n    case 'diffie-hellman-group-exchange-sha256':\n      this.type = 'groupex';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXDH_GEX_REQ';\n      this.pktReply = 'KEXDH_GEX_REPLY';\n      this._prime = null;\n      this._generator = null;\n      return;\n  }\n  throw new Error('Unsupported key exchange algorithm: ' + algo);\n}\nKeyExchange.prototype.setDHParams = function(prime, generator) {\n  if (this.type === 'groupex') {\n    if (!Buffer.isBuffer(prime))\n      throw new Error('Invalid prime value');\n    if (!Buffer.isBuffer(generator))\n      throw new Error('Invalid generator value');\n    this._prime = prime;\n    this._generator = generator;\n  }\n};\nKeyExchange.prototype.getDHParams = function() {\n  if (this.type === 'groupex' && this._kex) {\n    return {\n      prime: convertToMpint(this._kex.getPrime()),\n      generator: convertToMpint(this._kex.getGenerator()),\n    };\n  }\n};\nKeyExchange.prototype.generateKeys = function() {\n  switch (this.type) {\n    case '25519':\n      if (!this._keys)\n        this._keys = crypto.generateKeyPairSync('x25519');\n      break;\n    case 'ecdh':\n      if (!this._kex) {\n        this._kex = crypto.createECDH(this.name);\n        this._public = this._kex.generateKeys();\n      }\n      break;\n    case 'group':\n    case 'groupex':\n      if (!this._kex) {\n        if (this.name)\n          this._kex = crypto.createDiffieHellmanGroup(this.name);\n        else if (this._prime && this._generator)\n          this._kex = crypto.createDiffieHellman(this._prime, this._generator);\n        if (this._kex)\n          this._public = this._kex.generateKeys();\n      }\n      break;\n  }\n};\nKeyExchange.prototype.getPublicKey = function() {\n  this.generateKeys();\n\n  var key;\n  switch (this.type) {\n    case '25519':\n      key = this._keys.publicKey.export({ type: 'spki', format: 'der' });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    case 'ecdh':\n    case 'group':\n    case 'groupex':\n      key = this._public;\n      break;\n  }\n  if (key)\n    return this.convertPublicKey(key);\n};\nKeyExchange.prototype.convertPublicKey = function(key) {\n  var newKey;\n  var idx = 0;\n  var len = key.length;\n  while (key[idx] === 0x00) {\n    ++idx;\n    --len;\n  }\n  switch (this.type) {\n    case '25519':\n      if (key.length === 32)\n        return key;\n      break;\n    default:\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n  }\n  if (len !== key.length) {\n    newKey = Buffer.allocUnsafe(len);\n    key.copy(newKey, 0, idx);\n    key = newKey;\n  }\n  return key;\n};\nKeyExchange.prototype.computeSecret = function(otherPublicKey) {\n  this.generateKeys();\n\n  switch (this.type) {\n    case '25519':\n      try {\n        var asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n          // algorithm\n          asnWriter.startSequence();\n            asnWriter.writeOID('1.3.101.110'); // id-X25519\n          asnWriter.endSequence();\n\n          // PublicKey\n          asnWriter.startSequence(Ber.BitString);\n            asnWriter.writeByte(0x00);\n            // XXX: hack to write a raw buffer without a tag -- yuck\n            asnWriter._ensure(otherPublicKey.length);\n            otherPublicKey.copy(asnWriter._buf,\n                                asnWriter._offset,\n                                0,\n                                otherPublicKey.length);\n            asnWriter._offset += otherPublicKey.length;\n          asnWriter.endSequence();\n        asnWriter.endSequence();\n\n        return convertToMpint(crypto.diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: crypto.createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der',\n          }),\n        }));\n      } catch (ex) {\n        return ex;\n      }\n      break;\n    case 'ecdh':\n    case 'group':\n    case 'groupex':\n      try {\n        return convertToMpint(this._kex.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n  }\n};\n\nfunction convertToMpint(buf) {\n  var idx = 0;\n  var length = buf.length;\n  while (buf[idx] === 0x00) {\n    ++idx;\n    --length;\n  }\n  var newBuf;\n  if (buf[idx] & 0x80) {\n    newBuf = Buffer.allocUnsafe(1 + length);\n    newBuf[0] = 0;\n    buf.copy(newBuf, 1, idx);\n    buf = newBuf;\n  } else if (length !== buf.length) {\n    newBuf = Buffer.allocUnsafe(length);\n    buf.copy(newBuf, 0, idx);\n    buf = newBuf;\n  }\n  return buf;\n}\n\nmodule.exports = SSH2Stream;\nmodule.exports._send = send;\n","var Ber = require('asn1').Ber;\n\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\n// XXX the value of 2400 from dropbear is only for certain strings, not all\n// strings. for example the list strings used during handshakes\nvar MAX_STRING_LEN = Infinity;//2400; // taken from dropbear\n\nmodule.exports = {\n  iv_inc: iv_inc,\n  readInt: readInt,\n  readString: readString,\n  parseKey: require('./keyParser').parseKey,\n  sigSSHToASN1: sigSSHToASN1,\n  DSASigBERToBare: DSASigBERToBare,\n  ECDSASigASN1ToSSH: ECDSASigASN1ToSSH\n};\n\nfunction iv_inc(iv) {\n  var n = 12;\n  var c = 0;\n  do {\n    --n;\n    c = iv[n];\n    if (c === 255)\n      iv[n] = 0;\n    else {\n      iv[n] = ++c;\n      return;\n    }\n  } while (n > 4);\n}\n\nfunction readInt(buffer, start, stream, cb) {\n  var bufferLen = buffer.length;\n  if (start < 0 || start >= bufferLen || (bufferLen - start) < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  return readUInt32BE(buffer, start);\n}\n\nfunction DSASigBERToBare(signature) {\n  if (signature.length <= 40)\n    return signature;\n  // This is a quick and dirty way to get from BER encoded r and s that\n  // OpenSSL gives us, to just the bare values back to back (40 bytes\n  // total) like OpenSSH (and possibly others) are expecting\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  var rOffset = 0;\n  var sOffset = 0;\n  if (r.length < 20) {\n    var rNew = Buffer.allocUnsafe(20);\n    r.copy(rNew, 1);\n    r = rNew;\n    r[0] = 0;\n  }\n  if (s.length < 20) {\n    var sNew = Buffer.allocUnsafe(20);\n    s.copy(sNew, 1);\n    s = sNew;\n    s[0] = 0;\n  }\n  if (r.length > 20 && r[0] === 0x00)\n    rOffset = 1;\n  if (s.length > 20 && s[0] === 0x00)\n    sOffset = 1;\n  var newSig = Buffer.allocUnsafe((r.length - rOffset) + (s.length - sOffset));\n  r.copy(newSig, 0, rOffset);\n  s.copy(newSig, r.length - rOffset, sOffset);\n  return newSig;\n}\n\nfunction ECDSASigASN1ToSSH(signature) {\n  if (signature[0] === 0x00)\n    return signature;\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  if (r === null || s === null)\n    return false;\n  var newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n  writeUInt32BE(newSig, r.length, 0);\n  r.copy(newSig, 4);\n  writeUInt32BE(newSig, s.length, 4 + r.length);\n  s.copy(newSig, 4 + 4 + r.length);\n  return newSig;\n}\n\nfunction sigSSHToASN1(sig, type, self, callback) {\n  var asnWriter;\n  switch (type) {\n    case 'ssh-dss':\n      if (sig.length > 40)\n        return sig;\n      // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n      asnWriter = new Ber.Writer();\n      asnWriter.startSequence();\n      var r = sig.slice(0, 20);\n      var s = sig.slice(20);\n      if (r[0] & 0x80) {\n        var rNew = Buffer.allocUnsafe(21);\n        rNew[0] = 0x00;\n        r.copy(rNew, 1);\n        r = rNew;\n      } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n        r = r.slice(1);\n      }\n      if (s[0] & 0x80) {\n        var sNew = Buffer.allocUnsafe(21);\n        sNew[0] = 0x00;\n        s.copy(sNew, 1);\n        s = sNew;\n      } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n        s = s.slice(1);\n      }\n      asnWriter.writeBuffer(r, Ber.Integer);\n      asnWriter.writeBuffer(s, Ber.Integer);\n      asnWriter.endSequence();\n      return asnWriter.buffer;\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      var r = readString(sig, 0, self, callback);\n      if (r === false)\n        return false;\n      var s = readString(sig, sig._pos, self, callback);\n      if (s === false)\n        return false;\n\n      asnWriter = new Ber.Writer();\n      asnWriter.startSequence();\n      asnWriter.writeBuffer(r, Ber.Integer);\n      asnWriter.writeBuffer(s, Ber.Integer);\n      asnWriter.endSequence();\n      return asnWriter.buffer;\n    default:\n      return sig;\n  }\n}\n\nfunction readString(buffer, start, encoding, stream, cb, maxLen) {\n  if (encoding && !Buffer.isBuffer(encoding) && typeof encoding !== 'string') {\n    if (typeof cb === 'number')\n      maxLen = cb;\n    cb = stream;\n    stream = encoding;\n    encoding = undefined;\n  }\n\n  start || (start = 0);\n  var bufferLen = buffer.length;\n  var left = (bufferLen - start);\n  var len;\n  var end;\n  if (start < 0 || start >= bufferLen || left < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  len = readUInt32BE(buffer, start);\n  if (len > (maxLen || MAX_STRING_LEN) || left < (4 + len)) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  start += 4;\n  end = start + len;\n  buffer._pos = end;\n\n  if (encoding) {\n    if (Buffer.isBuffer(encoding)) {\n      buffer.copy(encoding, 0, start, end);\n      return encoding;\n    } else {\n      return buffer.toString(encoding, start, end);\n    }\n  } else {\n    return buffer.slice(start, end);\n  }\n}\n\n","var inherits = require('util').inherits;\nvar DuplexStream = require('stream').Duplex;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\n\nvar STDERR = require('ssh2-streams').constants.CHANNEL_EXTENDED_DATATYPE.STDERR;\n\nvar PACKET_SIZE = 32 * 1024;\nvar MAX_WINDOW = 2 * 1024 * 1024;\nvar WINDOW_THRESHOLD = MAX_WINDOW / 2;\nvar CUSTOM_EVENTS = [\n  'CHANNEL_EOF',\n  'CHANNEL_CLOSE',\n  'CHANNEL_DATA',\n  'CHANNEL_EXTENDED_DATA',\n  'CHANNEL_WINDOW_ADJUST',\n  'CHANNEL_SUCCESS',\n  'CHANNEL_FAILURE',\n  'CHANNEL_REQUEST'\n];\nvar CUSTOM_EVENTS_LEN = CUSTOM_EVENTS.length;\n\nfunction Channel(info, client, opts) {\n  var streamOpts = {\n    highWaterMark: MAX_WINDOW,\n    allowHalfOpen: (!opts || (opts && opts.allowHalfOpen !== false))\n  };\n\n  this.allowHalfOpen = streamOpts.allowHalfOpen;\n\n  DuplexStream.call(this, streamOpts);\n\n  var self = this;\n  var server = opts && opts.server;\n\n  this.server = server;\n  this.type = info.type;\n  this.subtype = undefined;\n  /*\n    incoming and outgoing contain these properties:\n    {\n      id: undefined,\n      window: undefined,\n      packetSize: undefined,\n      state: 'closed'\n    }\n  */\n  var incoming = this.incoming = info.incoming;\n  var incomingId = incoming.id;\n  var outgoing = this.outgoing = info.outgoing;\n  var callbacks = this._callbacks = [];\n  var exitCode;\n  var exitSignal;\n  var exitDump;\n  var exitDesc;\n  var exitLang;\n\n  this._client = client;\n  this._hasX11 = false;\n\n  var channels = client._channels;\n  var sshstream = client._sshstream;\n\n  function ondrain() {\n    if (self._waitClientDrain) {\n      self._waitClientDrain = false;\n      if (!self._waitWindow) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }\n  client._sock.on('drain', ondrain);\n\n  sshstream.once('CHANNEL_EOF:' + incomingId, function() {\n    if (incoming.state !== 'open')\n      return;\n    incoming.state = 'eof';\n\n    if (self.readable)\n      self.push(null);\n    if (!server && self.stderr.readable)\n      self.stderr.push(null);\n  }).once('CHANNEL_CLOSE:' + incomingId, function() {\n    if (incoming.state === 'closed')\n      return;\n    incoming.state = 'closed';\n\n    if (self.readable)\n      self.push(null);\n    if (server && self.stderr.writable)\n      self.stderr.end();\n    else if (!server && self.stderr.readable)\n      self.stderr.push(null);\n\n    if (outgoing.state === 'open' || outgoing.state === 'eof')\n      self.close();\n    if (outgoing.state === 'closing')\n      outgoing.state = 'closed';\n\n    delete channels[incomingId];\n\n    var state = self._writableState;\n    client._sock.removeListener('drain', ondrain);\n    if (!state.ending && !state.finished)\n      self.end();\n\n    // Take care of any outstanding channel requests\n    self._callbacks = [];\n    for (var i = 0; i < callbacks.length; ++i)\n      callbacks[i](true);\n    callbacks = self._callbacks;\n\n    if (!server) {\n      // align more with node child processes, where the close event gets the\n      // same arguments as the exit event\n      if (!self.readable) {\n        if (exitCode === null) {\n          self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                    exitLang);\n        } else\n          self.emit('close', exitCode);\n      } else {\n        self.once('end', function() {\n          if (exitCode === null) {\n            self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                      exitLang);\n          } else\n            self.emit('close', exitCode);\n        });\n      }\n\n      if (!self.stderr.readable)\n        self.stderr.emit('close');\n      else {\n        self.stderr.once('end', function() {\n          self.stderr.emit('close');\n        });\n      }\n    } else { // Server mode\n      if (!self.readable)\n        self.emit('close');\n      else {\n        self.once('end', function() {\n          self.emit('close');\n        });\n      }\n    }\n\n    for (var i = 0; i < CUSTOM_EVENTS_LEN; ++i)\n      sshstream.removeAllListeners(CUSTOM_EVENTS[i] + ':' + incomingId);\n  }).on('CHANNEL_DATA:' + incomingId, function(data) {\n    // the remote party should not be sending us data if there is no window\n    // space available ...\n    // TODO: raise error on data with not enough window\n    if (incoming.window === 0)\n      return;\n\n    incoming.window -= data.length;\n\n    if (!self.push(data)) {\n      self._waitChanDrain = true;\n      return;\n    }\n\n    if (incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(self);\n  }).on('CHANNEL_WINDOW_ADJUST:' + incomingId, function(amt) {\n    // the server is allowing us to send `amt` more bytes of data\n    outgoing.window += amt;\n\n    if (self._waitWindow) {\n      self._waitWindow = false;\n      if (!self._waitClientDrain) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }).on('CHANNEL_SUCCESS:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(false);\n  }).on('CHANNEL_FAILURE:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(true);\n  }).on('CHANNEL_REQUEST:' + incomingId, function(info) {\n    if (!server) {\n      if (info.request === 'exit-status') {\n        self.emit('exit', exitCode = info.code);\n        return;\n      } else if (info.request === 'exit-signal') {\n        self.emit('exit',\n                  exitCode = null,\n                  exitSignal = 'SIG' + info.signal,\n                  exitDump = info.coredump,\n                  exitDesc = info.description,\n                  exitLang = info.lang);\n        return;\n      }\n    }\n\n    // keepalive request? OpenSSH will send one as a channel request if there\n    // is a channel open\n\n    if (info.wantReply)\n      sshstream.channelFailure(outgoing.id);\n  });\n\n  this.stdin = this.stdout = this;\n\n  if (server)\n    this.stderr = new ServerStderr(this);\n  else {\n    this.stderr = new ReadableStream(streamOpts);\n    this.stderr._read = function(n) {\n      if (self._waitChanDrain) {\n        self._waitChanDrain = false;\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    };\n\n    sshstream.on('CHANNEL_EXTENDED_DATA:' + incomingId,\n      function(type, data) {\n        // the remote party should not be sending us data if there is no window\n        // space available ...\n        // TODO: raise error on data with not enough window\n        if (incoming.window === 0)\n          return;\n\n        incoming.window -= data.length;\n\n        if (!self.stderr.push(data)) {\n          self._waitChanDrain = true;\n          return;\n        }\n\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    );\n  }\n\n  // outgoing data\n  this._waitClientDrain = false; // Client stream-level backpressure\n  this._waitWindow = false; // SSH-level backpressure\n\n  // incoming data\n  this._waitChanDrain = false; // Channel Readable side backpressure\n\n  this._chunk = undefined;\n  this._chunkcb = undefined;\n  this._chunkErr = undefined;\n  this._chunkcbErr = undefined;\n\n  function onFinish() {\n    self.eof();\n    if (server || (!server && !self.allowHalfOpen))\n      self.close();\n    self.writable = false;\n  }\n  this.on('finish', onFinish)\n      .on('prefinish', onFinish); // for node v0.11+\n  function onEnd() {\n    self.readable = false;\n  }\n  this.on('end', onEnd)\n      .on('close', onEnd);\n}\ninherits(Channel, DuplexStream);\n\nChannel.prototype.eof = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open') {\n    outgoing.state = 'eof';\n    ret = this._client._sshstream.channelEOF(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype.close = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open' || outgoing.state === 'eof') {\n    outgoing.state = 'closing';\n    ret = this._client._sshstream.channelClose(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype._read = function(n) {\n  if (this._waitChanDrain) {\n    this._waitChanDrain = false;\n    if (this.incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(this);\n  }\n};\n\nChannel.prototype._write = function(data, encoding, cb) {\n  var sshstream = this._client._sshstream;\n  var outgoing = this.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelData(id, data.slice(p, p + sliceLen));\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      this._waitClientDrain = true;\n      this._chunk = undefined;\n      this._chunkcb = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      this._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = Buffer.allocUnsafe(len - p);\n      data.copy(buf, 0, p);\n      this._chunk = buf;\n    } else\n      this._chunk = data;\n    this._chunkcb = cb;\n    return;\n  }\n\n  if (!this._waitClientDrain)\n    cb();\n};\n\nChannel.prototype.destroy = function() {\n  this.end();\n};\n\n// session type-specific methods\nChannel.prototype.setWindow = function(rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && (this.subtype === 'shell' || this.subtype === 'exec')\n      && this.writable\n      && this.outgoing.state === 'open') {\n    return this._client._sshstream.windowChange(this.outgoing.id,\n                                                rows,\n                                                cols,\n                                                height,\n                                                width);\n  }\n\n  return true;\n};\nChannel.prototype.signal = function(signalName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open')\n    return this._client._sshstream.signal(this.outgoing.id, signalName);\n\n  return true;\n};\nChannel.prototype.exit = function(name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open') {\n    if (typeof name === 'number')\n      return this._client._sshstream.exitStatus(this.outgoing.id, name);\n    else {\n      return this._client._sshstream.exitSignal(this.outgoing.id,\n                                                name,\n                                                coreDumped,\n                                                msg);\n    }\n  }\n\n  return true;\n};\n\nChannel.MAX_WINDOW = MAX_WINDOW;\nChannel.PACKET_SIZE = PACKET_SIZE;\n\nfunction windowAdjust(self) {\n  if (self.outgoing.state === 'closed')\n    return true;\n  var amt = MAX_WINDOW - self.incoming.window;\n  if (amt <= 0)\n    return true;\n  self.incoming.window += amt;\n  return self._client._sshstream.channelWindowAdjust(self.outgoing.id, amt);\n}\n\nfunction ServerStderr(channel) {\n  WritableStream.call(this, { highWaterMark: MAX_WINDOW });\n  this._channel = channel;\n}\ninherits(ServerStderr, WritableStream);\n\nServerStderr.prototype._write = function(data, encoding, cb) {\n  var channel = this._channel;\n  var sshstream = channel._client._sshstream;\n  var outgoing = channel.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (channel.outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelExtData(id, data.slice(p, p + sliceLen), STDERR);\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      channel._waitClientDrain = true;\n      channel._chunkErr = undefined;\n      channel._chunkcbErr = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      channel._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = Buffer.allocUnsafe(len - p);\n      data.copy(buf, 0, p);\n      channel._chunkErr = buf;\n    } else\n      channel._chunkErr = data;\n    channel._chunkcbErr = cb;\n    return;\n  }\n\n  if (!channel._waitClientDrain)\n    cb();\n};\n\nmodule.exports = Channel;\n","// This wrapper class is used to retain backwards compatibility with\n// pre-v0.4 ssh2. If it weren't for `read()` and `write()` being used by the\n// streams2/3 API, we could just pass the SFTPStream directly to the end user...\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\nfunction SFTPWrapper(stream) {\n  var self = this;\n\n  EventEmitter.call(this);\n\n  this._stream = stream;\n\n  stream.on('error', function(err) {\n    self.emit('error', err);\n  }).on('end', function() {\n    self.emit('end');\n  }).on('close', function() {\n    self.emit('close');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n}\ninherits(SFTPWrapper, EventEmitter);\n\n// stream-related methods to pass on\nSFTPWrapper.prototype.end = function() {\n  return this._stream.end();\n};\n// SFTPStream client methods\nSFTPWrapper.prototype.createReadStream = function(path, options) {\n  return this._stream.createReadStream(path, options);\n};\nSFTPWrapper.prototype.createWriteStream = function(path, options) {\n  return this._stream.createWriteStream(path, options);\n};\nSFTPWrapper.prototype.open = function(path, flags, attrs, cb) {\n  return this._stream.open(path, flags, attrs, cb);\n};\nSFTPWrapper.prototype.close = function(handle, cb) {\n  return this._stream.close(handle, cb);\n};\nSFTPWrapper.prototype.read = function(handle, buf, off, len, position, cb) {\n  return this._stream.readData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.write = function(handle, buf, off, len, position, cb) {\n  return this._stream.writeData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  return this._stream.fastGet(remotePath, localPath, opts, cb);\n};\nSFTPWrapper.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  return this._stream.fastPut(localPath, remotePath, opts, cb);\n};\nSFTPWrapper.prototype.readFile = function(path, options, callback_) {\n  return this._stream.readFile(path, options, callback_);\n};\nSFTPWrapper.prototype.writeFile = function(path, data, options, callback_) {\n  return this._stream.writeFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.appendFile = function(path, data, options, callback_) {\n  return this._stream.appendFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.exists = function(path, cb) {\n  return this._stream.exists(path, cb);\n};\nSFTPWrapper.prototype.unlink = function(filename, cb) {\n  return this._stream.unlink(filename, cb);\n};\nSFTPWrapper.prototype.rename = function(oldPath, newPath, cb) {\n  return this._stream.rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.mkdir = function(path, attrs, cb) {\n  return this._stream.mkdir(path, attrs, cb);\n};\nSFTPWrapper.prototype.rmdir = function(path, cb) {\n  return this._stream.rmdir(path, cb);\n};\nSFTPWrapper.prototype.readdir = function(where, opts, cb) {\n  return this._stream.readdir(where, opts, cb);\n};\nSFTPWrapper.prototype.fstat = function(handle, cb) {\n  return this._stream.fstat(handle, cb);\n};\nSFTPWrapper.prototype.stat = function(path, cb) {\n  return this._stream.stat(path, cb);\n};\nSFTPWrapper.prototype.lstat = function(path, cb) {\n  return this._stream.lstat(path, cb);\n};\nSFTPWrapper.prototype.opendir = function(path, cb) {\n  return this._stream.opendir(path, cb);\n};\nSFTPWrapper.prototype.setstat = function(path, attrs, cb) {\n  return this._stream.setstat(path, attrs, cb);\n};\nSFTPWrapper.prototype.fsetstat = function(handle, attrs, cb) {\n  return this._stream.fsetstat(handle, attrs, cb);\n};\nSFTPWrapper.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this._stream.futimes(handle, atime, mtime, cb);\n};\nSFTPWrapper.prototype.utimes = function(path, atime, mtime, cb) {\n  return this._stream.utimes(path, atime, mtime, cb);\n};\nSFTPWrapper.prototype.fchown = function(handle, uid, gid, cb) {\n  return this._stream.fchown(handle, uid, gid, cb);\n};\nSFTPWrapper.prototype.chown = function(path, uid, gid, cb) {\n  return this._stream.chown(path, uid, gid, cb);\n};\nSFTPWrapper.prototype.fchmod = function(handle, mode, cb) {\n  return this._stream.fchmod(handle, mode, cb);\n};\nSFTPWrapper.prototype.chmod = function(path, mode, cb) {\n  return this._stream.chmod(path, mode, cb);\n};\nSFTPWrapper.prototype.readlink = function(path, cb) {\n  return this._stream.readlink(path, cb);\n};\nSFTPWrapper.prototype.symlink = function(targetPath, linkPath, cb) {\n  return this._stream.symlink(targetPath, linkPath, cb);\n};\nSFTPWrapper.prototype.realpath = function(path, cb) {\n  return this._stream.realpath(path, cb);\n};\n// extended requests\nSFTPWrapper.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_statvfs = function(path, cb) {\n  return this._stream.ext_openssh_statvfs(path, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  return this._stream.ext_openssh_fstatvfs(handle, cb);\n};\nSFTPWrapper.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_hardlink(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fsync = function(handle, cb) {\n  return this._stream.ext_openssh_fsync(handle, cb);\n};\n\nmodule.exports = SFTPWrapper;\n",null,"module.exports = {\n  readUInt32BE: function readUInt32BE(buf, offset) {\n    return buf[offset++] * 16777216\n           + buf[offset++] * 65536\n           + buf[offset++] * 256\n           + buf[offset];\n  },\n  writeUInt32BE: function writeUInt32BE(buf, value, offset) {\n    buf[offset++] = (value >>> 24);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = value;\n    return offset;\n  },\n  writeUInt32LE: function writeUInt32LE(buf, value, offset) {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  }\n};\n","var crypto = require('crypto');\nvar Socket = require('net').Socket;\nvar dnsLookup = require('dns').lookup;\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar HASHES = crypto.getHashes();\n\nvar ssh2_streams = require('ssh2-streams');\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar BUGS = consts.BUGS;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar EDDSA_SUPPORTED = consts.EDDSA_SUPPORTED;\nvar parseKey = ssh2_streams.utils.parseKey;\n\nvar HTTPAgents = require('./http-agents');\nvar Channel = require('./Channel');\nvar agentQuery = require('./agent');\nvar SFTPWrapper = require('./SFTPWrapper');\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nvar DEBUG_NOOP = function(msg) {};\n\nfunction Client() {\n  if (!(this instanceof Client))\n    return new Client();\n\n  EventEmitter.call(this);\n\n  this.config = {\n    host: undefined,\n    port: undefined,\n    localAddress: undefined,\n    localPort: undefined,\n    forceIPv4: undefined,\n    forceIPv6: undefined,\n    keepaliveCountMax: undefined,\n    keepaliveInterval: undefined,\n    readyTimeout: undefined,\n\n    username: undefined,\n    password: undefined,\n    privateKey: undefined,\n    tryKeyboard: undefined,\n    agent: undefined,\n    allowAgentFwd: undefined,\n    authHandler: undefined,\n\n    hostHashAlgo: undefined,\n    hostHashCb: undefined,\n    strictVendor: undefined,\n    debug: undefined\n  };\n\n  this._readyTimeout = undefined;\n  this._channels = undefined;\n  this._callbacks = undefined;\n  this._forwarding = undefined;\n  this._forwardingUnix = undefined;\n  this._acceptX11 = undefined;\n  this._agentFwdEnabled = undefined;\n  this._curChan = undefined;\n  this._remoteVer = undefined;\n\n  this._sshstream = undefined;\n  this._sock = undefined;\n  this._resetKA = undefined;\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.connect = function(cfg) {\n  var self = this;\n\n  if (this._sock && this._sock.writable) {\n    this.once('close', function() {\n      self.connect(cfg);\n    });\n    this.end();\n    return;\n  }\n\n  this.config.host = cfg.hostname || cfg.host || 'localhost';\n  this.config.port = cfg.port || 22;\n  this.config.localAddress = (typeof cfg.localAddress === 'string'\n                              ? cfg.localAddress\n                              : undefined);\n  this.config.localPort = (typeof cfg.localPort === 'string'\n                           || typeof cfg.localPort === 'number'\n                           ? cfg.localPort\n                           : undefined);\n  this.config.forceIPv4 = cfg.forceIPv4 || false;\n  this.config.forceIPv6 = cfg.forceIPv6 || false;\n  this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                   && cfg.keepaliveCountMax >= 0\n                                   ? cfg.keepaliveCountMax\n                                   : 3);\n  this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                   && cfg.keepaliveInterval > 0\n                                   ? cfg.keepaliveInterval\n                                   : 0);\n  this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                              && cfg.readyTimeout >= 0\n                              ? cfg.readyTimeout\n                              : 20000);\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  var i;\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n      }\n      algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n  if (algorithms.compress === undefined) {\n    if (cfg.compress) {\n      algorithms.compress = ['zlib@openssh.com', 'zlib'];\n      if (cfg.compress !== 'force')\n        algorithms.compress.push('none');\n    } else if (cfg.compress === false)\n      algorithms.compress = ['none'];\n  }\n\n  if (typeof cfg.username === 'string')\n    this.config.username = cfg.username;\n  else if (typeof cfg.user === 'string')\n    this.config.username = cfg.user;\n  else\n    throw new Error('Invalid username');\n\n  this.config.password = (typeof cfg.password === 'string'\n                          ? cfg.password\n                          : undefined);\n  this.config.privateKey = (typeof cfg.privateKey === 'string'\n                            || Buffer.isBuffer(cfg.privateKey)\n                            ? cfg.privateKey\n                            : undefined);\n  this.config.localHostname = (typeof cfg.localHostname === 'string'\n                               && cfg.localHostname.length\n                               ? cfg.localHostname\n                               : undefined);\n  this.config.localUsername = (typeof cfg.localUsername === 'string'\n                               && cfg.localUsername.length\n                               ? cfg.localUsername\n                               : undefined);\n  this.config.tryKeyboard = (cfg.tryKeyboard === true);\n  this.config.agent = (typeof cfg.agent === 'string' && cfg.agent.length\n                       ? cfg.agent\n                       : undefined);\n  this.config.allowAgentFwd = (cfg.agentForward === true\n                               && this.config.agent !== undefined);\n  var authHandler = this.config.authHandler = (\n    typeof cfg.authHandler === 'function' ? cfg.authHandler : undefined\n  );\n\n  this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                              ? cfg.strictVendor\n                              : true);\n\n  var debug = this.config.debug = (typeof cfg.debug === 'function'\n                                   ? cfg.debug\n                                   : DEBUG_NOOP);\n\n  if (cfg.agentForward === true && !this.config.allowAgentFwd)\n    throw new Error('You must set a valid agent path to allow agent forwarding');\n\n  var callbacks = this._callbacks = [];\n  this._channels = {};\n  this._forwarding = {};\n  this._forwardingUnix = {};\n  this._acceptX11 = 0;\n  this._agentFwdEnabled = false;\n  this._curChan = -1;\n  this._remoteVer = undefined;\n  var privateKey;\n\n  if (this.config.privateKey) {\n    privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n    if (privateKey instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privateKey.message);\n    if (Array.isArray(privateKey))\n      privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now\n    if (privateKey.getPrivatePEM() === null)\n      throw new Error('privateKey value does not contain a (valid) private key');\n  }\n\n  var stream = this._sshstream = new SSH2Stream({\n    algorithms: algorithms,\n    debug: (debug === DEBUG_NOOP ? undefined : debug)\n  });\n  var sock = this._sock = (cfg.sock || new Socket());\n\n  // drain stderr if we are connection hopping using an exec stream\n  if (this._sock.stderr && typeof this._sock.stderr.resume === 'function')\n    this._sock.stderr.resume();\n\n  // keepalive-related\n  var kainterval = this.config.keepaliveInterval;\n  var kacountmax = this.config.keepaliveCountMax;\n  var kacount = 0;\n  var katimer;\n  function sendKA() {\n    if (++kacount > kacountmax) {\n      clearInterval(katimer);\n      if (sock.readable) {\n        var err = new Error('Keepalive timeout');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }\n      return;\n    }\n    if (sock.writable) {\n      // append dummy callback to keep correct callback order\n      callbacks.push(resetKA);\n      stream.ping();\n    } else\n      clearInterval(katimer);\n  }\n  function resetKA() {\n    if (kainterval > 0) {\n      kacount = 0;\n      clearInterval(katimer);\n      if (sock.writable)\n        katimer = setInterval(sendKA, kainterval);\n    }\n  }\n  this._resetKA = resetKA;\n\n  stream.on('USERAUTH_BANNER', function(msg) {\n    self.emit('banner', msg);\n  });\n\n  sock.on('connect', function() {\n    debug('DEBUG: Client: Connected');\n    self.emit('connect');\n    if (!cfg.sock)\n      stream.pipe(sock).pipe(stream);\n  }).on('timeout', function() {\n    self.emit('timeout');\n  }).on('error', function(err) {\n    clearTimeout(self._readyTimeout);\n    err.level = 'client-socket';\n    self.emit('error', err);\n  }).on('end', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('end');\n  }).on('close', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('close');\n\n    // notify outstanding channel requests of disconnection ...\n    var callbacks_ = callbacks;\n    var err = new Error('No response from server');\n    callbacks = self._callbacks = [];\n    for (i = 0; i < callbacks_.length; ++i)\n      callbacks_[i](err);\n\n    // simulate error for any channels waiting to be opened. this is safe\n    // against successfully opened channels because the success and failure\n    // event handlers are automatically removed when a success/failure response\n    // is received\n    var channels = self._channels;\n    var chanNos = Object.keys(channels);\n    self._channels = {};\n    for (i = 0; i < chanNos.length; ++i) {\n      var ev1 = stream.emit('CHANNEL_OPEN_FAILURE:' + chanNos[i], err);\n      // emitting CHANNEL_CLOSE should be safe too and should help for any\n      // special channels which might otherwise keep the process alive, such\n      // as agent forwarding channels which have open unix sockets ...\n      var ev2 = stream.emit('CHANNEL_CLOSE:' + chanNos[i]);\n      var earlyCb;\n      if (!ev1 && !ev2 && (earlyCb = channels[chanNos[i]])\n          && typeof earlyCb === 'function') {\n        earlyCb(err);\n      }\n    }\n  });\n  stream.on('drain', function() {\n    self.emit('drain');\n  }).once('header', function(header) {\n    self._remoteVer = header.versions.software;\n    if (header.greeting)\n      self.emit('greeting', header.greeting);\n  }).on('continue', function() {\n    self.emit('continue');\n  }).on('error', function(err) {\n    if (err.level === undefined)\n      err.level = 'protocol';\n    else if (err.level === 'handshake')\n      clearTimeout(self._readyTimeout);\n    self.emit('error', err);\n  }).on('end', function() {\n    sock.resume();\n  });\n\n  if (typeof cfg.hostVerifier === 'function') {\n    if (HASHES.indexOf(cfg.hostHash) === -1)\n      throw new Error('Invalid host hash algorithm: ' + cfg.hostHash);\n    var hashCb = cfg.hostVerifier;\n    var hasher = crypto.createHash(cfg.hostHash);\n    stream.once('fingerprint', function(key, verify) {\n      hasher.update(key);\n      var ret = hashCb(hasher.digest('hex'), verify);\n      if (ret !== undefined)\n        verify(ret);\n    });\n  }\n\n  // begin authentication handling =============================================\n  var curAuth;\n  var curPartial = null;\n  var curAuthsLeft = null;\n  var agentKeys;\n  var agentKeyPos = 0;\n  var authsAllowed = ['none'];\n  if (this.config.password !== undefined)\n    authsAllowed.push('password');\n  if (privateKey !== undefined)\n    authsAllowed.push('publickey');\n  if (this.config.agent !== undefined)\n    authsAllowed.push('agent');\n  if (this.config.tryKeyboard)\n    authsAllowed.push('keyboard-interactive');\n  if (privateKey !== undefined\n      && this.config.localHostname !== undefined\n      && this.config.localUsername !== undefined) {\n    authsAllowed.push('hostbased');\n  }\n\n  if (authHandler === undefined) {\n    var authPos = 0;\n    authHandler = function authHandler(authsLeft, partial, cb) {\n      if (authPos === authsAllowed.length)\n        return false;\n      return authsAllowed[authPos++];\n    };\n  }\n\n  var hasSentAuth = false;\n  function doNextAuth(authName) {\n    hasSentAuth = true;\n    if (authName === false) {\n      stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n      stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      var err = new Error('All configured authentication methods failed');\n      err.level = 'client-authentication';\n      self.emit('error', err);\n      if (stream.writable)\n        self.end();\n      return;\n    }\n    if (authsAllowed.indexOf(authName) === -1)\n      throw new Error('Authentication method not allowed: ' + authName);\n    curAuth = authName;\n    switch (curAuth) {\n      case 'password':\n        stream.authPassword(self.config.username, self.config.password);\n      break;\n      case 'publickey':\n        stream.authPK(self.config.username, privateKey);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      break;\n      case 'hostbased':\n        function hostbasedCb(buf, cb) {\n          var signature = privateKey.sign(buf);\n          if (signature instanceof Error) {\n            signature.message = 'Error while signing data with privateKey: '\n                                + signature.message;\n            signature.level = 'client-authentication';\n            self.emit('error', signature);\n            return tryNextAuth();\n          }\n\n          cb(signature);\n        }\n        stream.authHostbased(self.config.username,\n                             privateKey,\n                             self.config.localHostname,\n                             self.config.localUsername,\n                             hostbasedCb);\n      break;\n      case 'agent':\n        agentQuery(self.config.agent, function(err, keys) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n            agentKeys = undefined;\n            return tryNextAuth();\n          } else if (keys.length === 0) {\n            debug('DEBUG: Agent: No keys stored in agent');\n            agentKeys = undefined;\n            return tryNextAuth();\n          }\n\n          agentKeys = keys;\n          agentKeyPos = 0;\n\n          stream.authPK(self.config.username, keys[0]);\n          stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n        });\n      break;\n      case 'keyboard-interactive':\n        stream.authKeyboard(self.config.username);\n        stream.on('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n      break;\n      case 'none':\n        stream.authNone(self.config.username);\n      break;\n    }\n  }\n  function tryNextAuth() {\n    hasSentAuth = false;\n    var auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n    if (hasSentAuth || auth === undefined)\n      return;\n    doNextAuth(auth);\n  }\n  function tryNextAgentKey() {\n    if (curAuth === 'agent') {\n      if (agentKeyPos >= agentKeys.length)\n        return;\n      if (++agentKeyPos >= agentKeys.length) {\n        debug('DEBUG: Agent: No more keys left to try');\n        debug('DEBUG: Client: agent auth failed');\n        agentKeys = undefined;\n        tryNextAuth();\n      } else {\n        debug('DEBUG: Agent: Trying key #' + (agentKeyPos + 1));\n        stream.authPK(self.config.username, agentKeys[agentKeyPos]);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      }\n    }\n  }\n  function onUSERAUTH_INFO_REQUEST(name, instructions, lang, prompts) {\n    var nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n    if (nprompts === 0) {\n      debug('DEBUG: Client: Sending automatic USERAUTH_INFO_RESPONSE');\n      return stream.authInfoRes();\n    }\n    // we sent a keyboard-interactive user authentication request and now the\n    // server is sending us the prompts we need to present to the user\n    self.emit('keyboard-interactive',\n              name,\n              instructions,\n              lang,\n              prompts,\n              function(answers) {\n                stream.authInfoRes(answers);\n              }\n    );\n  }\n  function onUSERAUTH_PK_OK() {\n    if (curAuth === 'agent') {\n      var agentKey = agentKeys[agentKeyPos];\n      var keyLen = readUInt32BE(agentKey, 0);\n      var pubKeyFullType = agentKey.toString('ascii', 4, 4 + keyLen);\n      var pubKeyType = pubKeyFullType.slice(4);\n      // Check that we support the key type first\n      // TODO: move key type checking logic to ssh2-streams\n      switch (pubKeyFullType) {\n        case 'ssh-rsa':\n        case 'ssh-dss':\n        case 'ecdsa-sha2-nistp256':\n        case 'ecdsa-sha2-nistp384':\n        case 'ecdsa-sha2-nistp521':\n          break;\n        default:\n          if (EDDSA_SUPPORTED && pubKeyFullType === 'ssh-ed25519')\n            break;\n          debug('DEBUG: Agent: Skipping unsupported key type: '\n                + pubKeyFullType);\n          return tryNextAgentKey();\n      }\n      stream.authPK(self.config.username, \n                    agentKey,\n                    function(buf, cb) {\n        agentQuery(self.config.agent,\n                   agentKey,\n                   pubKeyType,\n                   buf,\n                   function(err, signed) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n          } else {\n            var sigFullTypeLen = readUInt32BE(signed, 0);\n            if (4 + sigFullTypeLen + 4 < signed.length) {\n              var sigFullType = signed.toString('ascii', 4, 4 + sigFullTypeLen);\n              if (sigFullType !== pubKeyFullType) {\n                err = new Error('Agent key/signature type mismatch');\n                err.level = 'agent';\n                self.emit('error', err);\n              } else {\n                // skip algoLen + algo + sigLen\n                return cb(signed.slice(4 + sigFullTypeLen + 4));\n              }\n            }\n          }\n\n          tryNextAgentKey();\n        });\n      });\n    } else if (curAuth === 'publickey') {\n      stream.authPK(self.config.username, privateKey, function(buf, cb) {\n        var signature = privateKey.sign(buf);\n        if (signature instanceof Error) {\n          signature.message = 'Error while signing data with privateKey: '\n                              + signature.message;\n          signature.level = 'client-authentication';\n          self.emit('error', signature);\n          return tryNextAuth();\n        }\n        cb(signature);\n      });\n    }\n  }\n  function onUSERAUTH_FAILURE(authsLeft, partial) {\n    stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n    if (curAuth === 'agent') {\n      debug('DEBUG: Client: Agent key #' + (agentKeyPos + 1) + ' failed');\n      return tryNextAgentKey();\n    } else {\n      debug('DEBUG: Client: ' + curAuth + ' auth failed');\n    }\n\n    curPartial = partial;\n    curAuthsLeft = authsLeft;\n    tryNextAuth();\n  }\n  stream.once('USERAUTH_SUCCESS', function() {\n    stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n\n    // start keepalive mechanism\n    resetKA();\n\n    clearTimeout(self._readyTimeout);\n\n    self.emit('ready');\n  }).on('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n  // end authentication handling ===============================================\n\n  // handle initial handshake completion\n  stream.once('ready', function() {\n    stream.service('ssh-userauth');\n    stream.once('SERVICE_ACCEPT', function(svcName) {\n      if (svcName === 'ssh-userauth')\n        tryNextAuth();\n    });\n  });\n\n  // handle incoming requests from server, typically a forwarded TCP or X11\n  // connection\n  stream.on('CHANNEL_OPEN', function(info) {\n    onCHANNEL_OPEN(self, info);\n  });\n\n  // handle responses for tcpip-forward and other global requests\n  stream.on('REQUEST_SUCCESS', function(data) {\n    if (callbacks.length)\n      callbacks.shift()(false, data);\n  }).on('REQUEST_FAILURE', function() {\n    if (callbacks.length)\n      callbacks.shift()(true);\n  });\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    // auto-reject all global requests, this can be especially useful if the\n    // server is sending us dummy keepalive global requests\n    if (wantReply)\n      stream.requestFailure();\n  });\n\n  if (!cfg.sock) {\n    var host = this.config.host;\n    var forceIPv4 = this.config.forceIPv4;\n    var forceIPv6 = this.config.forceIPv6;\n\n    debug('DEBUG: Client: Trying '\n          + host\n          + ' on port '\n          + this.config.port\n          + ' ...');\n\n    function doConnect() {\n      startTimeout();\n      self._sock.connect({\n        host: host,\n        port: self.config.port,\n        localAddress: self.config.localAddress,\n        localPort: self.config.localPort\n      });\n      self._sock.setNoDelay(true);\n      self._sock.setMaxListeners(0);\n      self._sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n    }\n\n    if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6))\n      doConnect();\n    else {\n      dnsLookup(host, (forceIPv4 ? 4 : 6), function(err, address, family) {\n        if (err) {\n          var error = new Error('Error while looking up '\n                                + (forceIPv4 ? 'IPv4' : 'IPv6')\n                                + ' address for host '\n                                + host\n                                + ': ' + err);\n          clearTimeout(self._readyTimeout);\n          error.level = 'client-dns';\n          self.emit('error', error);\n          self.emit('close');\n          return;\n        }\n        host = address;\n        doConnect();\n      });\n    }\n  } else {\n    startTimeout();\n    stream.pipe(sock).pipe(stream);\n  }\n\n  function startTimeout() {\n    if (self.config.readyTimeout > 0) {\n      self._readyTimeout = setTimeout(function() {\n        var err = new Error('Timed out while waiting for handshake');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }, self.config.readyTimeout);\n    }\n  }\n};\n\nClient.prototype.end = function() {\n  if (this._sock\n      && this._sock.writable\n      && this._sshstream\n      && this._sshstream.writable)\n    return this._sshstream.disconnect();\n  return false;\n};\n\nClient.prototype.destroy = function() {\n  this._sock && this._sock.destroy();\n};\n\nClient.prototype.exec = function(cmd, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n  return openChannel(this, 'session', extraOpts, function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() {\n        reqAgentFwd(chan, reqCb);\n      });\n    }\n\n    if (typeof opts === 'object' && opts !== null) {\n      if (typeof opts.env === 'object' && opts.env !== null)\n        reqEnv(chan, opts.env);\n      if ((typeof opts.pty === 'object' && opts.pty !== null)\n          || opts.pty === true) {\n        todo.push(function() { reqPty(chan, opts.pty, reqCb); });\n      }\n      if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n          || opts.x11 === 'number'\n          || opts.x11 === true) {\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n      }\n    }\n\n    todo.push(function() { reqExec(chan, cmd, opts, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.shell = function(wndopts, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // start an interactive terminal/shell session\n  var self = this;\n\n  if (typeof wndopts === 'function') {\n    cb = wndopts;\n    wndopts = opts = undefined;\n  } else if (typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n    opts = wndopts;\n    wndopts = undefined;\n  }\n\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() { reqAgentFwd(chan, reqCb); });\n    }\n\n    if (wndopts !== false)\n      todo.push(function() { reqPty(chan, wndopts, reqCb); });\n\n    if (typeof opts === 'object' && opts !== null) {\n      if (typeof opts.env === 'object' && opts.env !== null)\n        reqEnv(chan, opts.env);\n      if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n          || opts.x11 === 'number'\n          || opts.x11 === true) {\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n      }\n    }\n\n    todo.push(function() { reqShell(chan, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.subsys = function(name, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n\treturn openChannel(this, 'session', function(err, chan) {\n\t\tif (err)\n\t\t\treturn cb(err);\n\n\t\treqSubsystem(chan, name, function(err, stream) {\n\t\t\tif (err)\n\t\t\t\treturn cb(err);\n\n\t\t\tcb(undefined, stream);\n\t\t});\n\t});\n};\n\nClient.prototype.sftp = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var self = this;\n\n  // start an SFTP session\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    reqSubsystem(chan, 'sftp', function(err, stream) {\n      if (err)\n        return cb(err);\n\n      var serverIdentRaw = self._sshstream._state.incoming.identRaw;\n      var cfg = { debug: self.config.debug };\n      var sftp = new SFTPStream(cfg, serverIdentRaw);\n\n      function onError(err) {\n        sftp.removeListener('ready', onReady);\n        stream.removeListener('exit', onExit);\n        cb(err);\n      }\n\n      function onReady() {\n        sftp.removeListener('error', onError);\n        stream.removeListener('exit', onExit);\n        cb(undefined, new SFTPWrapper(sftp));\n      }\n\n      function onExit(code, signal) {\n        sftp.removeListener('ready', onReady);\n        sftp.removeListener('error', onError);\n        var msg;\n        if (typeof code === 'number') {\n          msg = 'Received exit code '\n                + code\n                + ' while establishing SFTP session';\n        } else {\n          msg = 'Received signal '\n                + signal\n                + ' while establishing SFTP session';\n        }\n        var err = new Error(msg);\n        err.code = code;\n        err.signal = signal;\n        cb(err);\n      }\n\n      sftp.once('error', onError)\n          .once('ready', onReady)\n          .once('close', function() {\n            stream.end();\n          });\n\n      // OpenSSH server sends an exit-status if there was a problem spinning up\n      // an sftp server child process, so we listen for that here in order to\n      // properly raise an error.\n      stream.once('exit', onExit);\n\n      sftp.pipe(stream).pipe(sftp);\n    });\n  });\n};\n\nClient.prototype.forwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request for the server to start forwarding TCP connections to us\n  // on a particular address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err, data) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to bind to ' + bindAddr + ':' + bindPort));\n      }\n\n      var realPort = bindPort;\n      if (bindPort === 0 && data && data.length >= 4) {\n        realPort = readUInt32BE(data, 0);\n        if (!(self._sshstream.remoteBugs & BUGS.DYN_RPORT_BUG))\n          bindPort = realPort;\n      }\n\n      self._forwarding[bindAddr + ':' + bindPort] = realPort;\n\n      cb(undefined, realPort);\n    });\n  }\n\n  return this._sshstream.tcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.unforwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to stop forwarding us new connections for a particular\n  // address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to unbind from '\n                              + bindAddr + ':' + bindPort));\n      }\n\n      delete self._forwarding[bindAddr + ':' + bindPort];\n\n      cb();\n    });\n  }\n\n  return this._sshstream.cancelTcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.forwardOut = function(srcIP, srcPort, dstIP, dstPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to forward a TCP connection to the server\n\n  var cfg = {\n    srcIP: srcIP,\n    srcPort: srcPort,\n    dstIP: dstIP,\n    dstPort: dstPort\n  };\n\n  return openChannel(this, 'direct-tcpip', cfg, cb);\n};\n\nClient.prototype.openssh_noMoreSessions = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to disable future sessions'));\n        }\n\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_noMoreSessions(wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to bind to ' + socketPath));\n        }\n        self._forwardingUnix[socketPath] = true;\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_streamLocalForward(socketPath, wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_unforwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to unbind on ' + socketPath));\n        }\n        delete self._forwardingUnix[socketPath];\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_cancelStreamLocalForward(socketPath,\n                                                            wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    var cfg = { socketPath: socketPath };\n    return openChannel(this, 'direct-streamlocal@openssh.com', cfg, cb);\n  } else {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = cb;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, onSuccess)\n           .once('CHANNEL_OPEN_FAILURE:' + localChan, onFailure)\n           .once('CHANNEL_CLOSE:' + localChan, onFailure);\n\n  if (type === 'session')\n    ret = sshstream.session(localChan, initWindow, maxPacket);\n  else if (type === 'direct-tcpip')\n    ret = sshstream.directTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'direct-streamlocal@openssh.com') {\n    ret = sshstream.openssh_directStreamLocal(localChan,\n                                              initWindow,\n                                              maxPacket,\n                                              opts);\n  }\n\n  return ret;\n\n  function onSuccess(info) {\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self));\n  }\n\n  function onFailure(info) {\n    sshstream.removeListener('CHANNEL_OPEN_CONFIRMATION:' + localChan,\n                             onSuccess);\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    delete self._channels[localChan];\n\n    var err;\n    if (info instanceof Error)\n      err = info;\n    else if (typeof info === 'object' && info !== null) {\n      err = new Error('(SSH) Channel open failure: ' + info.description);\n      err.reason = info.reason;\n      err.lang = info.lang;\n    } else {\n      err = new Error('(SSH) Channel open failure: '\n                      + 'server closed channel unexpectedly');\n      err.reason = err.lang = '';\n    }\n    cb(err);\n  }\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // optimized path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\nfunction reqX11(chan, screen, cb) {\n  // asks server to start sending us X11 connections\n  var cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string')\n      cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string')\n      cfg.cookie = screen.cookie;\n    else if (Buffer.isBuffer(screen.cookie))\n      cfg.cookie = screen.cookie.toString('hex');\n  }\n  if (cfg.cookie === undefined)\n    cfg.cookie = randomCookie();\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request X11'));\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', function() {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  var rows = 24;\n  var cols = 80;\n  var width = 640;\n  var height = 480;\n  var term = 'vt100';\n  var modes = null;\n\n  if (typeof opts === 'function')\n    cb = opts;\n  else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n    if (typeof opts.modes === 'object')\n      modes = opts.modes;\n  }\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request a pseudo-terminal'));\n      }\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.pty(chan.outgoing.id,\n                                     rows,\n                                     cols,\n                                     height,\n                                     width,\n                                     term,\n                                     modes,\n                                     wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  } else if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return true;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      wantReply && cb(had_err !== true\n                      ? had_err\n                      : new Error('Unable to request agent forwarding'));\n      return;\n    }\n\n    wantReply && cb();\n  });\n\n  return chan._client._sshstream.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to open shell'));\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to exec'));\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return true;\n  var ret = true;\n  var keys = Object.keys(env || {});\n  var key;\n  var val;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    val = env[key];\n    ret = chan._client._sshstream.env(chan.outgoing.id, key, val, false);\n  }\n\n  return ret;\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to start subsystem: ' + name));\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.subsystem(chan.outgoing.id, name, true);\n}\n\nfunction onCHANNEL_OPEN(self, info) {\n  // the server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  var localChan = false;\n  var reason;\n\n  function accept() {\n    var chaninfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: Channel.MAX_WINDOW,\n        packetSize: Channel.PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    var stream = new Channel(chaninfo, self);\n\n    self._sshstream.channelOpenConfirm(info.sender,\n                                       localChan,\n                                       Channel.MAX_WINDOW,\n                                       Channel.PACKET_SIZE);\n    return stream;\n  }\n  function reject() {\n    if (reason === undefined) {\n      if (localChan === false)\n        reason = consts.CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = consts.CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    self._sshstream.channelOpenFail(info.sender, reason, '', '');\n  }\n\n  if (info.type === 'forwarded-tcpip'\n      || info.type === 'x11'\n      || info.type === 'auth-agent@openssh.com'\n      || info.type === 'forwarded-streamlocal@openssh.com') {\n\n    // check for conditions for automatic rejection\n    var rejectConn = (\n     (info.type === 'forwarded-tcpip'\n      && self._forwarding[info.data.destIP\n                         + ':'\n                         + info.data.destPort] === undefined)\n     || (info.type === 'forwarded-streamlocal@openssh.com'\n         && self._forwardingUnix[info.data.socketPath] === undefined)\n     || (info.type === 'x11' && self._acceptX11 === 0)\n     || (info.type === 'auth-agent@openssh.com'\n         && !self._agentFwdEnabled)\n    );\n\n    if (!rejectConn) {\n      localChan = nextChannel(self);\n\n      if (localChan === false) {\n        self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: no channels available');\n        rejectConn = true;\n      } else\n        self._channels[localChan] = true;\n    } else {\n      reason = consts.CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unexpected channel open for: '\n                        + info.type);\n    }\n\n    // TODO: automatic rejection after some timeout?\n\n    if (rejectConn)\n      reject();\n\n    if (localChan !== false) {\n      if (info.type === 'forwarded-tcpip') {\n        if (info.data.destPort === 0) {\n          info.data.destPort = self._forwarding[info.data.destIP\n                                                + ':'\n                                                + info.data.destPort];\n        }\n        self.emit('tcp connection', info.data, accept, reject);\n      } else if (info.type === 'x11') {\n        self.emit('x11', info.data, accept, reject);\n      } else if (info.type === 'forwarded-streamlocal@openssh.com') {\n        self.emit('unix connection', info.data, accept, reject);\n      } else {\n        agentQuery(self.config.agent, accept, reject);\n      }\n    }\n  } else {\n    // automatically reject any unsupported channel open requests\n    self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unsupported type: '\n                      + info.type);\n    reason = consts.CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n    reject();\n  }\n}\n\nvar randomCookie = (function() {\n  if (typeof crypto.randomFillSync === 'function') {\n    var buffer = Buffer.alloc(16);\n    return function randomCookie() {\n      crypto.randomFillSync(buffer, 0, 16);\n      return buffer.toString('hex');\n    };\n  } else {\n    return function randomCookie() {\n      return crypto.randomBytes(16).toString('hex');\n    };\n  }\n})();\n\nClient.Client = Client;\nClient.Server = require('./server');\n// pass some useful utilities on to end user (e.g. parseKey())\nClient.utils = ssh2_streams.utils;\n// expose useful SFTPStream constants for sftp server usage\nClient.SFTP_STATUS_CODE = SFTPStream.STATUS_CODE;\nClient.SFTP_OPEN_MODE = SFTPStream.OPEN_MODE;\n// expose http(s).Agent implementations to allow easy tunneling of HTTP(S)\n// requests\nClient.HTTPAgent = HTTPAgents.SSHTTPAgent;\nClient.HTTPSAgent = HTTPAgents.SSHTTPSAgent;\n\nmodule.exports = Client; // backwards compatibility\n","var HttpAgent = require('http').Agent;\nvar HttpsAgent = require('https').Agent;\nvar inherits = require('util').inherits;\n\nvar Client;\n\n[HttpAgent, HttpsAgent].forEach((ctor) => {\n  function SSHAgent(connectCfg, agentOptions) {\n    if (!(this instanceof SSHAgent))\n      return new SSHAgent(connectCfg, agentOptions);\n\n    ctor.call(this, agentOptions);\n\n    this._connectCfg = connectCfg;\n    this._defaultSrcIP = (agentOptions && agentOptions.srcIP) || 'localhost';\n  }\n  inherits(SSHAgent, ctor);\n\n  SSHAgent.prototype.createConnection = createConnection;\n\n  exports[ctor === HttpAgent ? 'SSHTTPAgent' : 'SSHTTPSAgent'] = SSHAgent;\n});\n\nfunction createConnection(options, cb) {\n  var srcIP = (options && options.localAddress) || this._defaultSrcIP;\n  var srcPort = (options && options.localPort) || 0;\n  var dstIP = options.host;\n  var dstPort = options.port;\n\n  if (Client === undefined)\n    Client = require('./client').Client;\n\n  var client = new Client();\n  var triedForward = false;\n  client.on('ready', () => {\n    client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {\n      triedForward = true;\n      if (err) {\n        client.end();\n        return cb(err);\n      }\n      stream.once('close', () => {\n        client.end();\n      });\n      cb(null, decorateStream(stream));\n    });\n  }).on('error', cb).on('close', () => {\n    if (!triedForward)\n      cb(new Error('Unexpected connection loss'));\n  }).connect(this._connectCfg);\n}\n\nfunction noop() {}\n\nfunction decorateStream(stream) {\n  stream.setKeepAlive = noop;\n  stream.setNoDelay = noop;\n  stream.setTimeout = noop;\n  stream.ref = noop;\n  stream.unref = noop;\n  stream.destroySoon = stream.destroy;\n  return stream;\n}\n","function spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction Manager(interval, streamInterval, kaCountMax) {\n  var streams = this._streams = [];\n  this._timer = undefined;\n  this._timerInterval = interval;\n  this._timerfn = function() {\n    var now = Date.now();\n    for (var i = 0, len = streams.length, s, last; i < len; ++i) {\n      s = streams[i];\n      last = s._kalast;\n      if (last && (now - last) >= streamInterval) {\n        if (++s._kacnt > kaCountMax) {\n          var err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          s.emit('error', err);\n          s.disconnect();\n          spliceOne(streams, i);\n          --i;\n          len = streams.length;\n        } else {\n          s._kalast = now;\n          // XXX: if the server ever starts sending real global requests to the\n          //      client, we will need to add a dummy callback here to keep the\n          //      correct reply order\n          s.ping();\n        }\n      }\n    }\n  };\n}\n\nManager.prototype.start = function() {\n  if (this._timer)\n    this.stop();\n  this._timer = setInterval(this._timerfn, this._timerInterval);\n};\n\nManager.prototype.stop = function() {\n  if (this._timer) {\n    clearInterval(this._timer);\n    this._timer = undefined;\n  }\n};\n\nManager.prototype.add = function(stream) {\n  var streams = this._streams,\n      self = this;\n\n  stream.once('end', function() {\n    self.remove(stream);\n  }).on('packet', resetKA);\n\n  streams[streams.length] = stream;\n\n  resetKA();\n\n  if (!this._timer)\n    this.start();\n\n  function resetKA() {\n    stream._kalast = Date.now();\n    stream._kacnt = 0;\n  }\n};\n\nManager.prototype.remove = function(stream) {\n  var streams = this._streams,\n      index = streams.indexOf(stream);\n  if (index > -1)\n    spliceOne(streams, index);\n  if (!streams.length)\n    this.stop();\n};\n\nmodule.exports = Manager;\n","var net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar listenerCount = EventEmitter.listenerCount;\nvar inherits = require('util').inherits;\n\nvar ssh2_streams = require('ssh2-streams');\nvar parseKey = ssh2_streams.utils.parseKey;\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar ALGORITHMS = consts.ALGORITHMS;\n\nvar Channel = require('./Channel');\nvar KeepaliveManager = require('./keepalivemgr');\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar MAX_PENDING_AUTHS = 10;\n\nvar kaMgr;\n\nfunction Server(cfg, listener) {\n  if (!(this instanceof Server))\n    return new Server(cfg, listener);\n\n  var hostKeys = {\n    'ssh-rsa': null,\n    'ssh-dss': null,\n    'ssh-ed25519': null,\n    'ecdsa-sha2-nistp256': null,\n    'ecdsa-sha2-nistp384': null,\n    'ecdsa-sha2-nistp521': null\n  };\n\n  var hostKeys_ = cfg.hostKeys;\n  if (!Array.isArray(hostKeys_))\n    throw new Error('hostKeys must be an array');\n\n  var i;\n  for (i = 0; i < hostKeys_.length; ++i) {\n    var privateKey;\n    if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')\n      privateKey = parseKey(hostKeys_[i]);\n    else\n      privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n    if (privateKey instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privateKey.message);\n    if (Array.isArray(privateKey))\n      privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now\n    if (privateKey.getPrivatePEM() === null)\n      throw new Error('privateKey value contains an invalid private key');\n    if (hostKeys[privateKey.type])\n      continue;\n    hostKeys[privateKey.type] = privateKey;\n  }\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    var copied = false;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = algoList.length - 1; i >= 0; --i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n        if (!hostKeys[algoList[i]]) {\n          // Silently discard for now\n          if (!copied) {\n            algoList = algoList.slice();\n            copied = true;\n          }\n          algoList.splice(i, 1);\n        }\n      }\n      if (algoList.length > 0)\n        algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n\n  // Make sure we at least have some kind of valid list of support key\n  // formats\n  if (algorithms.serverHostKey === undefined) {\n    var hostKeyAlgos = Object.keys(hostKeys);\n    for (i = hostKeyAlgos.length - 1; i >= 0; --i) {\n      if (!hostKeys[hostKeyAlgos[i]])\n        hostKeyAlgos.splice(i, 1);\n    }\n    algorithms.serverHostKey = hostKeyAlgos;\n  }\n\n  if (!kaMgr\n      && Server.KEEPALIVE_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0) {\n    kaMgr = new KeepaliveManager(Server.KEEPALIVE_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_COUNT_MAX);\n  }\n\n  var self = this;\n\n  EventEmitter.call(this);\n\n  if (typeof listener === 'function')\n    self.on('connection', listener);\n\n  var streamcfg = {\n    algorithms: algorithms,\n    hostKeys: hostKeys,\n    server: true\n  };\n  var keys;\n  var len;\n  for (i = 0, keys = Object.keys(cfg), len = keys.length; i < len; ++i) {\n    var key = keys[i];\n    if (key === 'privateKey'\n        || key === 'publicKey'\n        || key === 'passphrase'\n        || key === 'algorithms'\n        || key === 'hostKeys'\n        || key === 'server') {\n      continue;\n    }\n    streamcfg[key] = cfg[key];\n  }\n\n  if (typeof streamcfg.debug === 'function') {\n    var oldDebug = streamcfg.debug;\n    var cfgKeys = Object.keys(streamcfg);\n  }\n\n  this._srv = new net.Server(function(socket) {\n    if (self._connections >= self.maxConnections) {\n      socket.destroy();\n      return;\n    }\n    ++self._connections;\n    socket.once('close', function(had_err) {\n      --self._connections;\n\n      // since joyent/node#993bb93e0a, we have to \"read past EOF\" in order to\n      // get an `end` event on streams. thankfully adding this does not\n      // negatively affect node versions pre-joyent/node#993bb93e0a.\n      sshstream.read();\n    }).on('error', function(err) {\n      sshstream.reset();\n      sshstream.emit('error', err);\n    });\n\n    var conncfg = streamcfg;\n\n    // prepend debug output with a unique identifier in case there are multiple\n    // clients connected at the same time\n    if (oldDebug) {\n      conncfg = {};\n      for (var i = 0, key; i < cfgKeys.length; ++i) {\n        key = cfgKeys[i];\n        conncfg[key] = streamcfg[key];\n      }\n      var debugPrefix = '[' + process.hrtime().join('.') + '] ';\n      conncfg.debug = function(msg) {\n        oldDebug(debugPrefix + msg);\n      };\n    }\n\n    var sshstream = new SSH2Stream(conncfg);\n    var client = new Client(sshstream, socket);\n\n    socket.pipe(sshstream).pipe(socket);\n\n    // silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    client.on('error', onClientPreHeaderError);\n\n    sshstream.once('header', function(header) {\n      if (sshstream._readableState.ended) {\n        // already disconnected internally in SSH2Stream due to incompatible\n        // protocol version\n        return;\n      } else if (!listenerCount(self, 'connection')) {\n        // auto reject\n        return sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      }\n\n      client.removeListener('error', onClientPreHeaderError);\n\n      self.emit('connection',\n                client,\n                { ip: socket.remoteAddress,\n                  family: socket.remoteFamily,\n                  port: socket.remotePort,\n                  header: header });\n    });\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('listening', function() {\n    self.emit('listening');\n  }).on('close', function() {\n    self.emit('close');\n  });\n  this._connections = 0;\n  this.maxConnections = Infinity;\n}\ninherits(Server, EventEmitter);\n\nServer.prototype.listen = function() {\n  this._srv.listen.apply(this._srv, arguments);\n  return this;\n};\n\nServer.prototype.address = function() {\n  return this._srv.address();\n};\n\nServer.prototype.getConnections = function(cb) {\n  this._srv.getConnections(cb);\n};\n\nServer.prototype.close = function(cb) {\n  this._srv.close(cb);\n  return this;\n};\n\nServer.prototype.ref = function() {\n  this._srv.ref();\n};\n\nServer.prototype.unref = function() {\n  this._srv.unref();\n};\n\n\nfunction Client(stream, socket) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this._sshstream = stream;\n  var channels = this._channels = {};\n  this._curChan = -1;\n  this._sock = socket;\n  this.noMoreSessions = false;\n  this.authenticated = false;\n\n  stream.on('end', function() {\n    socket.resume();\n    self.emit('end');\n  }).on('close', function(hasErr) {\n    self.emit('close', hasErr);\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('drain', function() {\n    self.emit('drain');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n\n  var exchanges = 0;\n  var acceptedAuthSvc = false;\n  var pendingAuths = [];\n  var authCtx;\n\n  // begin service/auth-related ================================================\n  stream.on('SERVICE_REQUEST', function(service) {\n    if (exchanges === 0\n        || acceptedAuthSvc\n        || self.authenticated\n        || service !== 'ssh-userauth')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    acceptedAuthSvc = true;\n    stream.serviceAccept(service);\n  }).on('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n  function onUSERAUTH_REQUEST(username, service, method, methodData) {\n    if (exchanges === 0\n        || (authCtx\n            && (authCtx.username !== username || authCtx.service !== service))\n          // TODO: support hostbased auth\n        || (method !== 'password'\n            && method !== 'publickey'\n            && method !== 'hostbased'\n            && method !== 'keyboard-interactive'\n            && method !== 'none')\n        || pendingAuths.length === MAX_PENDING_AUTHS)\n      return stream.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    else if (service !== 'ssh-connection')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    // XXX: this really shouldn't be reaching into private state ...\n    stream._state.authMethod = method;\n\n    var ctx;\n    if (method === 'keyboard-interactive') {\n      ctx = new KeyboardAuthContext(stream, username, service, method,\n                                    methodData, onAuthDecide);\n    } else if (method === 'publickey') {\n      ctx = new PKAuthContext(stream, username, service, method, methodData,\n                              onAuthDecide);\n    } else if (method === 'hostbased') {\n      ctx = new HostbasedAuthContext(stream, username, service, method,\n                                     methodData, onAuthDecide);\n    } else if (method === 'password') {\n      ctx = new PwdAuthContext(stream, username, service, method, methodData,\n                               onAuthDecide);\n    } else if (method === 'none')\n      ctx = new AuthContext(stream, username, service, method, onAuthDecide);\n\n    if (authCtx) {\n      if (!authCtx._initialResponse)\n        return pendingAuths.push(ctx);\n      else if (authCtx._multistep && !this._finalResponse) {\n        // RFC 4252 says to silently abort the current auth request if a new\n        // auth request comes in before the final response from an auth method\n        // that requires additional request/response exchanges -- this means\n        // keyboard-interactive for now ...\n        authCtx._cleanup && authCtx._cleanup();\n        authCtx.emit('abort');\n      }\n    }\n\n    authCtx = ctx;\n\n    if (listenerCount(self, 'authentication'))\n      self.emit('authentication', authCtx);\n    else\n      authCtx.reject();\n  }\n  function onAuthDecide(ctx, allowed, methodsLeft, isPartial) {\n    if (authCtx === ctx && !self.authenticated) {\n      if (allowed) {\n        stream.removeListener('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n        authCtx = undefined;\n        self.authenticated = true;\n        stream.authSuccess();\n        pendingAuths = [];\n        self.emit('ready');\n      } else {\n        stream.authFailure(methodsLeft, isPartial);\n        if (pendingAuths.length) {\n          authCtx = pendingAuths.pop();\n          if (listenerCount(self, 'authentication'))\n            self.emit('authentication', authCtx);\n          else\n            authCtx.reject();\n        }\n      }\n    }\n  }\n  // end service/auth-related ==================================================\n\n  var unsentGlobalRequestsReplies = [];\n\n  function sendReplies() {\n    var reply;\n    while (unsentGlobalRequestsReplies.length > 0\n           && unsentGlobalRequestsReplies[0].type) {\n      reply = unsentGlobalRequestsReplies.shift();\n      if (reply.type === 'SUCCESS')\n        stream.requestSuccess(reply.buf);\n      if (reply.type === 'FAILURE')\n        stream.requestFailure();\n    }\n  }\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    var reply = {\n      type: null,\n      buf: null\n    };\n\n    function setReply(type, buf) {\n      reply.type = type;\n      reply.buf = buf;\n      sendReplies();\n    }\n\n    if (wantReply)\n      unsentGlobalRequestsReplies.push(reply);\n\n    if ((name === 'tcpip-forward'\n         || name === 'cancel-tcpip-forward'\n         || name === 'no-more-sessions@openssh.com'\n         || name === 'streamlocal-forward@openssh.com'\n         || name === 'cancel-streamlocal-forward@openssh.com')\n        && listenerCount(self, 'request')\n        && self.authenticated) {\n      var accept;\n      var reject;\n\n      if (wantReply) {\n        var replied = false;\n        accept = function(chosenPort) {\n          if (replied)\n            return;\n          replied = true;\n          var bufPort;\n          if (name === 'tcpip-forward'\n              && data.bindPort === 0\n              && typeof chosenPort === 'number') {\n            bufPort = Buffer.allocUnsafe(4);\n            writeUInt32BE(bufPort, chosenPort, 0);\n          }\n          setReply('SUCCESS', bufPort);\n        };\n        reject = function() {\n          if (replied)\n            return;\n          replied = true;\n          setReply('FAILURE');\n        };\n      }\n\n      if (name === 'no-more-sessions@openssh.com') {\n        self.noMoreSessions = true;\n        accept && accept();\n        return;\n      }\n\n      self.emit('request', accept, reject, name, data);\n    } else if (wantReply)\n      setReply('FAILURE');\n  });\n\n  stream.on('CHANNEL_OPEN', function(info) {\n    // do early reject in some cases to prevent wasteful channel allocation\n    if ((info.type === 'session' && self.noMoreSessions)\n        || !self.authenticated) {\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    }\n\n    var localChan = nextChannel(self);\n    var accept;\n    var reject;\n    var replied = false;\n    if (localChan === false) {\n      // auto-reject due to no channels available\n      return stream.channelOpenFail(info.sender,\n                                    CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE);\n    }\n\n    // be optimistic, reserve channel to prevent another request from trying to\n    // take the same channel\n    channels[localChan] = true;\n\n    reject = function() {\n      if (replied)\n        return;\n\n      replied = true;\n\n      delete channels[localChan];\n\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    };\n\n    switch (info.type) {\n      case 'session':\n        if (listenerCount(self, 'session')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            return new Session(self, info, localChan);\n          };\n\n          self.emit('session', accept, reject);\n        } else\n          reject();\n      break;\n      case 'direct-tcpip':\n        if (listenerCount(self, 'tcpip')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('tcpip', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      case 'direct-streamlocal@openssh.com':\n        if (listenerCount(self, 'openssh.streamlocal')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('openssh.streamlocal', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      default:\n        // auto-reject unsupported channel types\n        reject();\n    }\n  });\n\n  stream.on('NEWKEYS', function() {\n    if (++exchanges > 1)\n      self.emit('rekey');\n  });\n\n  if (kaMgr) {\n    this.once('ready', function() {\n      kaMgr.add(stream);\n    });\n  }\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.end = function() {\n  return this._sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n};\n\nClient.prototype.x11 = function(originAddr, originPort, cb) {\n  var opts = {\n    originAddr: originAddr,\n    originPort: originPort\n  };\n  return openChannel(this, 'x11', opts, cb);\n};\n\nClient.prototype.forwardOut = function(boundAddr, boundPort, remoteAddr,\n                                       remotePort, cb) {\n  var opts = {\n    boundAddr: boundAddr,\n    boundPort: boundPort,\n    remoteAddr: remoteAddr,\n    remotePort: remotePort\n  };\n  return openChannel(this, 'forwarded-tcpip', opts, cb);\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  var opts = {\n    socketPath: socketPath\n  };\n  return openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n};\n\nClient.prototype.rekey = function(cb) {\n  var stream = this._sshstream;\n  var ret = true;\n  var error;\n\n  try {\n    ret = stream.rekey();\n  } catch (ex) {\n    error = ex;\n  }\n\n  // TODO: re-throw error if no callback?\n\n  if (typeof cb === 'function') {\n    if (error) {\n      process.nextTick(function() {\n        cb(error);\n      });\n    } else\n      this.once('rekey', cb);\n  }\n\n  return ret;\n};\n\nfunction Session(client, info, localChan) {\n  this.subtype = undefined;\n\n  var ending = false;\n  var self = this;\n  var outgoingId = info.sender;\n  var channel;\n\n  var chaninfo = {\n    type: 'session',\n    incoming: {\n      id: localChan,\n      window: Channel.MAX_WINDOW,\n      packetSize: Channel.PACKET_SIZE,\n      state: 'open'\n    },\n    outgoing: {\n      id: info.sender,\n      window: info.window,\n      packetSize: info.packetSize,\n      state: 'open'\n    }\n  };\n\n  function onREQUEST(info) {\n    var replied = false;\n    var accept;\n    var reject;\n\n    if (info.wantReply) {\n      // \"real session\" requests will have custom accept behaviors\n      if (info.request !== 'shell'\n          && info.request !== 'exec'\n          && info.request !== 'subsystem') {\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          return client._sshstream.channelSuccess(outgoingId);\n        };\n      }\n\n      reject = function() {\n        if (replied || ending || channel)\n          return;\n\n        replied = true;\n\n        return client._sshstream.channelFailure(outgoingId);\n      };\n    }\n\n    if (ending) {\n      reject && reject();\n      return;\n    }\n\n    switch (info.request) {\n      // \"pre-real session start\" requests\n      case 'env':\n        if (listenerCount(self, 'env')) {\n          self.emit('env', accept, reject, {\n            key: info.key,\n            val: info.val\n          });\n        } else\n          reject && reject();\n      break;\n      case 'pty-req':\n        if (listenerCount(self, 'pty')) {\n          self.emit('pty', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height,\n            term: info.term,\n            modes: info.modes,\n          });\n        } else\n          reject && reject();\n      break;\n      case 'window-change':\n        if (listenerCount(self, 'window-change')) {\n          self.emit('window-change', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height\n          });\n        } else\n          reject && reject();\n      break;\n      case 'x11-req':\n        if (listenerCount(self, 'x11')) {\n          self.emit('x11', accept, reject, {\n            single: info.single,\n            protocol: info.protocol,\n            cookie: info.cookie,\n            screen: info.screen\n          });\n        } else\n          reject && reject();\n      break;\n      // \"post-real session start\" requests\n      case 'signal':\n        if (listenerCount(self, 'signal')) {\n          self.emit('signal', accept, reject, {\n            name: info.signal\n          });\n        } else\n          reject && reject();\n      break;\n      // XXX: is `auth-agent-req@openssh.com` really \"post-real session start\"?\n      case 'auth-agent-req@openssh.com':\n        if (listenerCount(self, 'auth-agent'))\n          self.emit('auth-agent', accept, reject);\n        else\n          reject && reject();\n      break;\n      // \"real session start\" requests\n      case 'shell':\n        if (listenerCount(self, 'shell')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('shell', accept, reject);\n        } else\n          reject && reject();\n      break;\n      case 'exec':\n        if (listenerCount(self, 'exec')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('exec', accept, reject, {\n            command: info.command\n          });\n        } else\n          reject && reject();\n      break;\n      case 'subsystem':\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          if (info.wantReply)\n            client._sshstream.channelSuccess(outgoingId);\n\n          channel = new Channel(chaninfo, client, { server: true });\n\n          channel.subtype = self.subtype = (info.request + ':' + info.subsystem);\n\n          if (info.subsystem === 'sftp') {\n            var sftp = new SFTPStream({\n              server: true,\n              debug: client._sshstream.debug\n            });\n            channel.pipe(sftp).pipe(channel);\n\n            return sftp;\n          } else\n            return channel;\n        };\n\n        if (info.subsystem === 'sftp' && listenerCount(self, 'sftp'))\n          self.emit('sftp', accept, reject);\n        else if (info.subsystem !== 'sftp' && listenerCount(self, 'subsystem')) {\n          self.emit('subsystem', accept, reject, {\n            name: info.subsystem\n          });\n        } else\n          reject && reject();\n      break;\n      default:\n        reject && reject();\n    }\n  }\n  function onEOF() {\n    ending = true;\n    self.emit('eof');\n    self.emit('end');\n  }\n  function onCLOSE() {\n    ending = true;\n    self.emit('close');\n  }\n  client._sshstream\n        .on('CHANNEL_REQUEST:' + localChan, onREQUEST)\n        .once('CHANNEL_EOF:' + localChan, onEOF)\n        .once('CHANNEL_CLOSE:' + localChan, onCLOSE);\n}\ninherits(Session, EventEmitter);\n\n\nfunction AuthContext(stream, username, service, method, cb) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this.username = this.user = username;\n  this.service = service;\n  this.method = method;\n  this._initialResponse = false;\n  this._finalResponse = false;\n  this._multistep = false;\n  this._cbfinal = function(allowed, methodsLeft, isPartial) {\n    if (!self._finalResponse) {\n      self._finalResponse = true;\n      cb(self, allowed, methodsLeft, isPartial);\n    }\n  };\n  this._stream = stream;\n}\ninherits(AuthContext, EventEmitter);\nAuthContext.prototype.accept = function() {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(true);\n};\nAuthContext.prototype.reject = function(methodsLeft, isPartial) {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(false, methodsLeft, isPartial);\n};\n\nvar RE_KBINT_SUBMETHODS = /[ \\t\\r\\n]*,[ \\t\\r\\n]*/g;\nfunction KeyboardAuthContext(stream, username, service, method, submethods, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n  this._multistep = true;\n\n  var self = this;\n\n  this._cb = undefined;\n  this._onInfoResponse = function(responses) {\n    if (self._cb) {\n      var callback = self._cb;\n      self._cb = undefined;\n      callback(responses);\n    }\n  };\n  this.submethods = submethods.split(RE_KBINT_SUBMETHODS);\n  this.on('abort', function() {\n    self._cb && self._cb(new Error('Authentication request aborted'));\n  });\n}\ninherits(KeyboardAuthContext, AuthContext);\nKeyboardAuthContext.prototype._cleanup = function() {\n  this._stream.removeListener('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n};\nKeyboardAuthContext.prototype.prompt = function(prompts, title, instructions,\n                                                cb) {\n  if (!Array.isArray(prompts))\n    prompts = [ prompts ];\n\n  if (typeof title === 'function') {\n    cb = title;\n    title = instructions = undefined;\n  } else if (typeof instructions === 'function') {\n    cb = instructions;\n    instructions = undefined;\n  }\n\n  for (var i = 0; i < prompts.length; ++i) {\n    if (typeof prompts[i] === 'string') {\n      prompts[i] = {\n        prompt: prompts[i],\n        echo: true\n      };\n    }\n  }\n\n  this._cb = cb;\n  this._initialResponse = true;\n  this._stream.once('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n\n  return this._stream.authInfoReq(title, instructions, prompts);\n};\n\nfunction PKAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    // TODO: move key type checking logic to ssh2-streams\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n      case 'ssh-dss':\n        sigAlgo = 'sha1';\n        break;\n      case 'ssh-ed25519':\n        sigAlgo = null;\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n}\ninherits(PKAuthContext, AuthContext);\nPKAuthContext.prototype.accept = function() {\n  if (!this.signature) {\n    this._initialResponse = true;\n    this._stream.authPKOK(this.key.algo, this.key.data);\n  } else {\n    AuthContext.prototype.accept.call(this);\n  }\n};\n\nfunction HostbasedAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    // TODO: move key type checking logic to ssh2-streams\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n      case 'ssh-dss':\n        sigAlgo = 'sha1';\n        break;\n      case 'ssh-ed25519':\n        sigAlgo = null;\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n  this.localHostname = pkInfo.localHostname;\n  this.localUsername = pkInfo.localUsername;\n}\ninherits(HostbasedAuthContext, AuthContext);\n\nfunction PwdAuthContext(stream, username, service, method, password, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.password = password;\n}\ninherits(PwdAuthContext, AuthContext);\n\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the client to open a channel for some purpose\n  // (e.g. a forwarded TCP connection)\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = true;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_FAILURE:' + localChan);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self, { server: true }));\n  }).once('CHANNEL_OPEN_FAILURE:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_CONFIRMATION:' + localChan);\n\n    delete self._channels[localChan];\n\n    var err = new Error('(SSH) Channel open failure: ' + info.description);\n    err.reason = info.reason;\n    err.lang = info.lang;\n    cb(err);\n  });\n\n  if (type === 'forwarded-tcpip')\n    ret = sshstream.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'x11')\n    ret = sshstream.x11(localChan, initWindow, maxPacket, opts);\n  else if (type === 'forwarded-streamlocal@openssh.com') {\n    ret = sshstream.openssh_forwardedStreamLocal(localChan,\n                                                 initWindow,\n                                                 maxPacket,\n                                                 opts);\n  }\n\n  return ret;\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // fast path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\n\nServer.createServer = function(cfg, listener) {\n  return new Server(cfg, listener);\n};\nServer.KEEPALIVE_INTERVAL = 1000;\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;\n","/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","var chownr = require('chownr')\nvar tar = require('tar-stream')\nvar pump = require('pump')\nvar mkdirp = require('mkdirp-classic')\nvar fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\nvar win32 = os.platform() === 'win32'\n\nvar noop = function () {}\n\nvar echo = function (name) {\n  return name\n}\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_')\n}\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.']\n\n  return function loop (callback) {\n    if (!queue.length) return callback()\n    var next = queue.shift()\n    var nextAbs = path.join(cwd, next)\n\n    stat(nextAbs, function (err, stat) {\n      if (err) return callback(err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    var linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  var strict = opts.strict !== false\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var pack = opts.pack || tar.pack()\n  var finish = opts.finish || noop\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    var entry = pack.entry(header, onnextentry)\n    if (!entry) return\n\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename)), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  onnextentry()\n\n  return pack\n}\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1\n}\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0\n}\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var own = opts.chown !== false && !win32 && processGetuid() === 0\n  var extract = opts.extract || tar.extract()\n  var stack = []\n  var now = new Date()\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var strict = opts.strict !== false\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var utimesParent = function (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    var top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink'\n\n    /* eslint-disable node/no-deprecated-api */\n    var chmod = link ? xfs.lchmod : xfs.chmod\n    var chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n    chmod(name, mode, function (err) {\n      if (err) return cb(err)\n      if (!own) return cb()\n      if (!chown) return cb()\n      chown(name, header.uid, header.gid, cb)\n    })\n  }\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n    var name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    var stat = function (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    var onsymlink = function () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    var onlink = function () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname))\n\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath)\n            return onfile()\n          }\n\n          stat(err)\n        })\n      })\n    }\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name)\n      var rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime])\n      return mkdirfix(name, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, stat)\n    }\n\n    var dir = path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      mkdirfix(dir, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n  })\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction mkdirfix (name, opts, cb) {\n  mkdirp(name, { fs: opts.fs }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb)\n    } else {\n      cb(err)\n    }\n  })\n}\n","var util = require('util')\nvar bl = require('bl')\nvar headers = require('./headers')\n\nvar Writable = require('readable-stream').Writable\nvar PassThrough = require('readable-stream').PassThrough\n\nvar noop = function () {}\n\nvar overflow = function (size) {\n  size &= 511\n  return size && 512 - size\n}\n\nvar emptyStream = function (self, offset) {\n  var s = new Source(self, offset)\n  s.end()\n  return s\n}\n\nvar mixinPax = function (header, pax) {\n  if (pax.path) header.name = pax.path\n  if (pax.linkpath) header.linkname = pax.linkpath\n  if (pax.size) header.size = parseInt(pax.size, 10)\n  header.pax = pax\n  return header\n}\n\nvar Source = function (self, offset) {\n  this._parent = self\n  this.offset = offset\n  PassThrough.call(this, { autoDestroy: false })\n}\n\nutil.inherits(Source, PassThrough)\n\nSource.prototype.destroy = function (err) {\n  this._parent.destroy(err)\n}\n\nvar Extract = function (opts) {\n  if (!(this instanceof Extract)) return new Extract(opts)\n  Writable.call(this, opts)\n\n  opts = opts || {}\n\n  this._offset = 0\n  this._buffer = bl()\n  this._missing = 0\n  this._partial = false\n  this._onparse = noop\n  this._header = null\n  this._stream = null\n  this._overflow = null\n  this._cb = null\n  this._locked = false\n  this._destroyed = false\n  this._pax = null\n  this._paxGlobal = null\n  this._gnuLongPath = null\n  this._gnuLongLinkPath = null\n\n  var self = this\n  var b = self._buffer\n\n  var oncontinue = function () {\n    self._continue()\n  }\n\n  var onunlock = function (err) {\n    self._locked = false\n    if (err) return self.destroy(err)\n    if (!self._stream) oncontinue()\n  }\n\n  var onstreamend = function () {\n    self._stream = null\n    var drain = overflow(self._header.size)\n    if (drain) self._parse(drain, ondrain)\n    else self._parse(512, onheader)\n    if (!self._locked) oncontinue()\n  }\n\n  var ondrain = function () {\n    self._buffer.consume(overflow(self._header.size))\n    self._parse(512, onheader)\n    oncontinue()\n  }\n\n  var onpaxglobalheader = function () {\n    var size = self._header.size\n    self._paxGlobal = headers.decodePax(b.slice(0, size))\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onpaxheader = function () {\n    var size = self._header.size\n    self._pax = headers.decodePax(b.slice(0, size))\n    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulongpath = function () {\n    var size = self._header.size\n    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulonglinkpath = function () {\n    var size = self._header.size\n    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onheader = function () {\n    var offset = self._offset\n    var header\n    try {\n      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat)\n    } catch (err) {\n      self.emit('error', err)\n    }\n    b.consume(512)\n\n    if (!header) {\n      self._parse(512, onheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-path') {\n      self._parse(header.size, ongnulongpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-link-path') {\n      self._parse(header.size, ongnulonglinkpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader)\n      oncontinue()\n      return\n    }\n\n    if (self._gnuLongPath) {\n      header.name = self._gnuLongPath\n      self._gnuLongPath = null\n    }\n\n    if (self._gnuLongLinkPath) {\n      header.linkname = self._gnuLongLinkPath\n      self._gnuLongLinkPath = null\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax)\n      self._pax = null\n    }\n\n    self._locked = true\n\n    if (!header.size || header.type === 'directory') {\n      self._parse(512, onheader)\n      self.emit('entry', header, emptyStream(self, offset), onunlock)\n      return\n    }\n\n    self._stream = new Source(self, offset)\n\n    self.emit('entry', header, self._stream, onunlock)\n    self._parse(header.size, onstreamend)\n    oncontinue()\n  }\n\n  this._onheader = onheader\n  this._parse(512, onheader)\n}\n\nutil.inherits(Extract, Writable)\n\nExtract.prototype.destroy = function (err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream) this._stream.emit('close')\n}\n\nExtract.prototype._parse = function (size, onparse) {\n  if (this._destroyed) return\n  this._offset += size\n  this._missing = size\n  if (onparse === this._onheader) this._partial = false\n  this._onparse = onparse\n}\n\nExtract.prototype._continue = function () {\n  if (this._destroyed) return\n  var cb = this._cb\n  this._cb = noop\n  if (this._overflow) this._write(this._overflow, undefined, cb)\n  else cb()\n}\n\nExtract.prototype._write = function (data, enc, cb) {\n  if (this._destroyed) return\n\n  var s = this._stream\n  var b = this._buffer\n  var missing = this._missing\n  if (data.length) this._partial = true\n\n  // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length\n    this._overflow = null\n    if (s) return s.write(data, cb)\n    b.append(data)\n    return cb()\n  }\n\n  // end-of-chunk. the parser should call cb.\n\n  this._cb = cb\n  this._missing = 0\n\n  var overflow = null\n  if (data.length > missing) {\n    overflow = data.slice(missing)\n    data = data.slice(0, missing)\n  }\n\n  if (s) s.end(data)\n  else b.append(data)\n\n  this._overflow = overflow\n  this._onparse()\n}\n\nExtract.prototype._final = function (cb) {\n  if (this._partial) return this.destroy(new Error('Unexpected end of data'))\n  cb()\n}\n\nmodule.exports = Extract\n","var alloc = Buffer.alloc\n\nvar ZEROS = '0000000000000000000'\nvar SEVENS = '7777777777777777777'\nvar ZERO_OFFSET = '0'.charCodeAt(0)\nvar USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary')\nvar USTAR_VER = Buffer.from('00', 'binary')\nvar GNU_MAGIC = Buffer.from('ustar\\x20', 'binary')\nvar GNU_VER = Buffer.from('\\x20\\x00', 'binary')\nvar MASK = parseInt('7777', 8)\nvar MAGIC_OFFSET = 257\nvar VERSION_OFFSET = 263\n\nvar clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nvar toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nvar toTypeflag = function (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nvar indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nvar cksum = function (block) {\n  var sum = 8 * 32\n  for (var i = 0; i < 148; i++) sum += block[i]\n  for (var j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nvar encodeOct = function (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  else return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  var tuple = []\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  var sum = 0\n  var l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nvar decodeOct = function (val, offset, length) {\n  val = val.slice(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(val.slice(offset, end).toString(), 8)\n  }\n}\n\nvar decodeStr = function (val, offset, length, encoding) {\n  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)\n}\n\nvar addLength = function (str) {\n  var len = Buffer.byteLength(str)\n  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n\nexports.decodeLongPath = function (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function (opts) { // TODO: encode more stuff in pax\n  var result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  var pax = opts.pax\n  if (pax) {\n    for (var key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return Buffer.from(result)\n}\n\nexports.decodePax = function (buf) {\n  var result = {}\n\n  while (buf.length) {\n    var i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    var len = parseInt(buf.slice(0, i).toString(), 10)\n    if (!len) return result\n\n    var b = buf.slice(i + 1, len - 1).toString()\n    var keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.slice(len)\n  }\n\n  return result\n}\n\nexports.encode = function (opts) {\n  var buf = alloc(512)\n  var name = opts.name\n  var prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (Buffer.byteLength(name) !== name.length) return null // utf-8\n\n  while (Buffer.byteLength(name) > 100) {\n    var i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null\n  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null\n\n  buf.write(name)\n  buf.write(encodeOct(opts.mode & MASK, 6), 100)\n  buf.write(encodeOct(opts.uid, 6), 108)\n  buf.write(encodeOct(opts.gid, 6), 116)\n  buf.write(encodeOct(opts.size, 11), 124)\n  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) buf.write(opts.linkname, 157)\n\n  USTAR_MAGIC.copy(buf, MAGIC_OFFSET)\n  USTAR_VER.copy(buf, VERSION_OFFSET)\n  if (opts.uname) buf.write(opts.uname, 265)\n  if (opts.gname) buf.write(opts.gname, 297)\n  buf.write(encodeOct(opts.devmajor || 0, 6), 329)\n  buf.write(encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) buf.write(prefix, 345)\n\n  buf.write(encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function (buf, filenameEncoding, allowUnknownFormat) {\n  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  var name = decodeStr(buf, 0, 100, filenameEncoding)\n  var mode = decodeOct(buf, 100, 8)\n  var uid = decodeOct(buf, 108, 8)\n  var gid = decodeOct(buf, 116, 8)\n  var size = decodeOct(buf, 124, 12)\n  var mtime = decodeOct(buf, 136, 12)\n  var type = toType(typeflag)\n  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  var uname = decodeStr(buf, 265, 32)\n  var gname = decodeStr(buf, 297, 32)\n  var devmajor = decodeOct(buf, 329, 8)\n  var devminor = decodeOct(buf, 337, 8)\n\n  var c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 &&\n             GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor\n  }\n}\n","exports.extract = require('./extract')\nexports.pack = require('./pack')\n","var constants = require('fs-constants')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar alloc = Buffer.alloc\n\nvar Readable = require('readable-stream').Readable\nvar Writable = require('readable-stream').Writable\nvar StringDecoder = require('string_decoder').StringDecoder\n\nvar headers = require('./headers')\n\nvar DMODE = parseInt('755', 8)\nvar FMODE = parseInt('644', 8)\n\nvar END_OF_TAR = alloc(1024)\n\nvar noop = function () {}\n\nvar overflow = function (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.slice(0, 512 - size))\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nvar Sink = function (to) {\n  Writable.call(this)\n  this.written = 0\n  this._to = to\n  this._destroyed = false\n}\n\ninherits(Sink, Writable)\n\nSink.prototype._write = function (data, enc, cb) {\n  this.written += data.length\n  if (this._to.push(data)) return cb()\n  this._to._drain = cb\n}\n\nSink.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar LinkSink = function () {\n  Writable.call(this)\n  this.linkname = ''\n  this._decoder = new StringDecoder('utf-8')\n  this._destroyed = false\n}\n\ninherits(LinkSink, Writable)\n\nLinkSink.prototype._write = function (data, enc, cb) {\n  this.linkname += this._decoder.write(data)\n  cb()\n}\n\nLinkSink.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Void = function () {\n  Writable.call(this)\n  this._destroyed = false\n}\n\ninherits(Void, Writable)\n\nVoid.prototype._write = function (data, enc, cb) {\n  cb(new Error('No body allowed for this entry'))\n}\n\nVoid.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Pack = function (opts) {\n  if (!(this instanceof Pack)) return new Pack(opts)\n  Readable.call(this, opts)\n\n  this._drain = noop\n  this._finalized = false\n  this._finalizing = false\n  this._destroyed = false\n  this._stream = null\n}\n\ninherits(Pack, Readable)\n\nPack.prototype.entry = function (header, buffer, callback) {\n  if (this._stream) throw new Error('already piping an entry')\n  if (this._finalized || this._destroyed) return\n\n  if (typeof buffer === 'function') {\n    callback = buffer\n    buffer = null\n  }\n\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!header.size || header.type === 'symlink') header.size = 0\n  if (!header.type) header.type = modeToType(header.mode)\n  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n  if (!header.uid) header.uid = 0\n  if (!header.gid) header.gid = 0\n  if (!header.mtime) header.mtime = new Date()\n\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer)\n  if (Buffer.isBuffer(buffer)) {\n    header.size = buffer.length\n    this._encode(header)\n    var ok = this.push(buffer)\n    overflow(self, header.size)\n    if (ok) process.nextTick(callback)\n    else this._drain = callback\n    return new Void()\n  }\n\n  if (header.type === 'symlink' && !header.linkname) {\n    var linkSink = new LinkSink()\n    eos(linkSink, function (err) {\n      if (err) { // stream was closed\n        self.destroy()\n        return callback(err)\n      }\n\n      header.linkname = linkSink.linkname\n      self._encode(header)\n      callback()\n    })\n\n    return linkSink\n  }\n\n  this._encode(header)\n\n  if (header.type !== 'file' && header.type !== 'contiguous-file') {\n    process.nextTick(callback)\n    return new Void()\n  }\n\n  var sink = new Sink(this)\n\n  this._stream = sink\n\n  eos(sink, function (err) {\n    self._stream = null\n\n    if (err) { // stream was closed\n      self.destroy()\n      return callback(err)\n    }\n\n    if (sink.written !== header.size) { // corrupting tar\n      self.destroy()\n      return callback(new Error('size mismatch'))\n    }\n\n    overflow(self, header.size)\n    if (self._finalizing) self.finalize()\n    callback()\n  })\n\n  return sink\n}\n\nPack.prototype.finalize = function () {\n  if (this._stream) {\n    this._finalizing = true\n    return\n  }\n\n  if (this._finalized) return\n  this._finalized = true\n  this.push(END_OF_TAR)\n  this.push(null)\n}\n\nPack.prototype.destroy = function (err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream && this._stream.destroy) this._stream.destroy()\n}\n\nPack.prototype._encode = function (header) {\n  if (!header.pax) {\n    var buf = headers.encode(header)\n    if (buf) {\n      this.push(buf)\n      return\n    }\n  }\n  this._encodePax(header)\n}\n\nPack.prototype._encodePax = function (header) {\n  var paxHeader = headers.encodePax({\n    name: header.name,\n    linkname: header.linkname,\n    pax: header.pax\n  })\n\n  var newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  }\n\n  this.push(headers.encode(newHeader))\n  this.push(paxHeader)\n  overflow(this, paxHeader.length)\n\n  newHeader.size = header.size\n  newHeader.type = header.type\n  this.push(headers.encode(newHeader))\n}\n\nPack.prototype._read = function (n) {\n  var drain = this._drain\n  this._drain = noop\n  drain()\n}\n\nmodule.exports = Pack\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  mlen = -1;\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  mlen = n;\n  return mlen;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  var t, i;\n  for (i = 0; i < arguments.length; i++) {\n     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')\n       throw new TypeError('unexpected type ' + t + ', use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\n// TODO: Completely remove this in v0.15.\nif (!nacl.util) {\n  nacl.util = {};\n  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {\n    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');\n  };\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return false;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  if (arguments.length !== 2)\n    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto');\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n","\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"timers\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3109);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACxpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACxcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC3hCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AClvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7FA;;;A;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;AC1BA;;;A;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC3jDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACxdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC96CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACtjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7vKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC3fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6VA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;;;;;ACpYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACliDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACtSA;AACA;;;A;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC9PA;;;A;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACn1EA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;A;;A;;;;;;AChCA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;;;;A","sourceRoot":""}